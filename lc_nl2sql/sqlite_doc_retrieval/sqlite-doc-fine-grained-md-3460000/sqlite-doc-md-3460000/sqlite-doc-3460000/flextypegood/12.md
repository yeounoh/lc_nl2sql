## 4\.2\. Rigid type enforcement helps prevent application bugs


 It has become a point of doctrine among many programmers that the
best way to prevent application bugs is strict type enforcement. But I
find no evidence in support of this.



 To be sure, strict type enforcement does help prevent some kinds of
bugs in lower\-level languages like C and C\+\+ that present a model that is
close to machine hardware. But this does not seem to
be the case for higher\-abstraction languages in which all data is
passed around in a "Value" superclass of some kind which is subclassed
for the various lower\-level data types. When everything is a Value
object, specific datatypes cease to be important.



 This technical note is authored by the original author of SQLite.
I having been writing TCL programs for 27 years. TCL has no type enforcement
whatsoever. The "Value" class in TCL (called Tcl\_Obj) can hold many
different datatypes, but it presents the content to the program and to
the application user as a string. And I've had a lot of bugs in
those TCL programs over the years. But I do not recall a single instance
where the bugs might have been caught by a rigid type system. I have
also written a lot of C code over a span of 35 years, not the
least of which is SQLite itself. I have found the type system in C
to be very helpful at finding and preventing problems. For the
[Fossil Version Control System](https://fossil-scm.org/), which is written
in C, I have even implemented supplemental static analysis programs that
scan the Fossil source code prior to compilation, looking for problems
that compilers miss. This works well for compiled programs.



 The SQL language model is a higher\-level abstraction than C/C\+\+.
In SQLite, every data item is stored in memory as an "sqlite3\_value" object.
There are subclasses of this object for strings, integer, floating\-point
numbers, blobs, and other representations. Everything is passed around
inside the SQL language implemented by SQLite as "sqlite3\_value" objects
so the underlying datatype does not really matter. I have never found
rigid type enforcement to be helpful in languages like TCL and SQLite
that have a single "Value" superclass used to represent any data element.
Fossil makes extensive use of SQLite in its implementation. There have
been many bugs in Fossil over its 14\-years history, but I cannot recall
a single bug that might have been prevented by rigid type enforcement in
the SQLite. Some C\-language bugs might have been caught by better type
enforcement (which is why I wrote the supplemental source code scanners),
but no SQL bugs.



 Based on decades of experience, I reject the thesis that rigid
type enforcement helps prevent application bugs. I will accept and
believe a slightly modified thesis: Rigid type enforcement helps to
prevent applications bugs *in languages that lack a single
top\-level "Value" superclass*. But SQLite does have the
single "sqlite3\_value" superclass, so that proverb does not apply.



