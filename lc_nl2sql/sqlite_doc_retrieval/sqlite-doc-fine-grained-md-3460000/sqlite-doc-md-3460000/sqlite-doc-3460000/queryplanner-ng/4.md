## 2\.2\.  The SQLite Query Planner Stability Guarantee


When the Query Planner Stability Guarantee (QPSG) is enabled
SQLite will always pick the same query plan for any
given SQL statement as long as:



1. the database schema does not change in significant ways such as
 adding or dropping indexes,
2. the ANALYZE command is not rerun,
3. the same version of SQLite is used.


The QPSG is disabled by default. It can be enabled at compile\-time
using the [SQLITE\_ENABLE\_QPSG](compile.html#enable_qpsg) compile\-time option, or at run\-time by
invoking [sqlite3\_db\_config](c3ref/db_config.html)(db,[SQLITE\_DBCONFIG\_ENABLE\_QPSG](c3ref/c_dbconfig_defensive.html#sqlitedbconfigenableqpsg),1,0\).



The QPSG means that if all of your queries run efficiently
during testing, and if your application does not change the schema,
then SQLite will not suddenly decide to start using a different
query plan, possibly causing a performance problem after your application
is released to users. If your application works in the lab, it
will continue working the same way after deployment.


Client/server SQL database engines do not normally
make this guarantee.
In client/server SQL database engines, the server keeps track of
statistics on the sizes of tables and on the quality of indexes
and the query planner uses those statistics to help select the best plans.
As content is added, deleted, or changed in the database, the statistics
will evolve and may cause the query planner to begin using a different
query plan for some particular query. Usually the new plan will be better
for the evolving structure of the data. But sometimes the new query plan will
cause a performance reduction. With a client/server database engine, there
is typically a Database Administrator (DBA) on hand to deal with these
rare problems as they come up. But DBAs are not available to fix problems
in an embedded database like SQLite, and hence SQLite is careful to
ensure that plans do not change unexpectedly after deployment.


It is important to note that changing versions of SQLite might cause
changes in query plans.
The same version of SQLite will
always pick the same query plan, but if you relink your application to use
a different version of SQLite, then query plans might change. In rare
cases, an SQLite version change might lead to a performance regression.
This is one reason
you should consider statically linking your applications against SQLite
rather than use a system\-wide SQLite shared library which might
change without your knowledge or control.


See also:


* [Recommended usage patterns for ANALYZE](lang_analyze.html#req)
* [PRAGMA optimize](pragma.html#pragma_optimize)


