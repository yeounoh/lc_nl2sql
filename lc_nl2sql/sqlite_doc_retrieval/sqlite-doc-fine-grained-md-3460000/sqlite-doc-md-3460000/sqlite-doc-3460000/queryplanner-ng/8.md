## 3\.3\.  Finding The Best Query Plan


Prior to [version 3\.8\.0](releaselog/3_8_0.html) (2013\-08\-26\), SQLite always used
the "Nearest Neighbor" or "NN" heuristic when searching for the best query plan.
The NN heuristic makes a single traversal of the graph, always choosing
the lowest\-cost arc as the next step.
The NN heuristic works surprisingly well in most cases.
And NN is fast, so that SQLite is able to quickly find good plans
for even large 64\-way joins. In contrast, other SQL database engines that
do more extensive searching tend to bog down when the
number of tables in a join goes above 10 or 15\.


Unfortunately, the query plan computed by NN for TPC\-H Q8 is not optimal.
The plan computed using NN is R\-N1\-N2\-S\-C\-O\-L\-P with a cost of 36\.92\.
The notation
in the previous sentence means that the R table is run in the outer loop,
N1 is in the next inner loop, N2 is in the third loop, and so forth down
to P which is in the inner\-most loop. The shortest path through the
graph (as found via exhaustive search) is P\-L\-O\-C\-N1\-R\-S\-N2
with a cost of 27\.38\. The difference might not seem like much, but
remember that
the costs are logarithmic, so the shortest path is nearly 750 times
faster than that path found using the NN heuristic.


One solution to this problem is to change SQLite to do an exhaustive
search for the best path. But an exhaustive search requires time
proportional to
K! (where K is the number of tables in the join) and so when you get
beyond a 10\-way join, the time
to run [sqlite3\_prepare()](c3ref/prepare.html) becomes very large.


