# 5\.  Checklist For Avoiding Or Fixing Query Planner Problems


1. **Don't panic!**
Cases where the query planner picks an inferior plan are actually quite
rare. You are unlikely to run across any problems in your application.
If you are not having performance issues, you do not need to worry
about any of this.
2. **Create appropriate indexes.**
Most SQL performance problems arise not because of query planner issues
but rather due to lack of appropriate indexes. Make sure indexes are
available to assist all large queries. Most performance issues can be
resolved by one or two CREATE INDEX commands and with no changes to
application code.
3. **Avoid creating low\-quality indexes.**.
A low\-quality index (for the purpose of this checklist) is one where
there are more than 10 or 20 rows in the table that have the same value
for the left\-most column of the index. In particular, avoid using
boolean or "enum" columns as the left\-most columns of your indexes.


The Fossil performance problem described in the previous section of
this document arose because there were over
ten\-thousand entries in the TAGXREF table with the same value for the
left\-most column (the TAGID column) of the TAGXREF\_I1 index.
4. **If you must use a low\-quality index, be sure to run [ANALYZE](lang_analyze.html).**
Low\-quality indexes will not confuse the query planner as long as the
query planner knows that the indexes are of low quality. And the way
the query planner knows this is by the content of the [SQLITE\_STAT1](fileformat2.html#stat1tab) table,
which is computed by the ANALYZE command.


Of course, ANALYZE only works effectively if you have a significant
amount of content in your database in the first place. When creating a
new database that you expect to accumulate a lot of data, you can run
the command "ANALYZE sqlite\_schema" to create the SQLITE\_STAT1 table,
then prepopulate the [sqlite\_stat1](fileformat2.html#stat1tab) table (using ordinary INSERT statements)
with content that describes a typical
database for your application \- perhaps content that you extracted after
running ANALYZE on a well\-populated template database in the lab.
Or, you could just run "[PRAGMA optimize](pragma.html#pragma_optimize)" before shutting down
database connections so that ANALYZE will be run automatically as
needed to keep the [sqlite\_stat1](fileformat2.html#stat1tab) table current.
5. **Instrument your code.**
Add logic that lets you know quickly and easily which queries are taking
too much time. Then work on just those specific queries.







---


*Update 2024: The query planner has been improved so much over
the years that you should never need to use any of the
hacks described below. The capabilities described below are still
available, for backwards compatibility. But you shouldn't use
them. If you do find a case where you are getting a suboptimal query
plan, please report it to the SQLite developers on the 
[SQLite Forum](https://sqlite.org/forum) so that they can try to fix
the problem. In other words:



**Stop Reading Here!**
To help encourage you to stop reading, the remainder of this checklist
is now grayed out.




---*
6. Use [unlikely()](lang_corefunc.html#unlikely) and [likelihood()](lang_corefunc.html#likelihood) SQL functions.
SQLite normally assumes that terms in the WHERE clause that cannot be used
by indexes have a strong probability of being true. If this assumption
is incorrect, it could lead to a suboptimal query plan. The
[unlikely()](lang_corefunc.html#unlikely) and [likelihood()](lang_corefunc.html#likelihood) SQL functions can be used to provide
hints to the query planner about WHERE clause terms that are probably
not true, and thus aid the query planner in selecting the best possible
plan.
7. Use the [CROSS JOIN](optoverview.html#crossjoin) syntax to enforce a particular
loop nesting order on queries that might use low\-quality indexes in an
unanalyzed database.
SQLite [treats the CROSS JOIN operator specially](lang_select.html#crossjoin), forcing the table to
the left to be an outer loop relative to the table on the right.
8. Use unary "\+" operators to disqualify WHERE clause terms.
If the query planner insists on selecting a poor\-quality index for a particular
query when a much higher\-quality index is available, then
[careful use of unary "\+" operators](optoverview.html#uplus) in the WHERE clause
can force the query planner away from the poor\-quality index.
Avoid using this trick if at all possible, and especially avoid it
early in the application development cycle. Beware that
adding a unary "\+" operator to an equality expression might change
the result of that expression if
[type affinity](datatype3.html#affinity) is involved.
9. Use the [INDEXED BY](lang_indexedby.html) syntax to enforce the selection of
particular indexes on problem queries.
As with the previous two bullets, avoid this step if possible, and
especially avoid doing this early in development as it is clearly a
premature optimization.


