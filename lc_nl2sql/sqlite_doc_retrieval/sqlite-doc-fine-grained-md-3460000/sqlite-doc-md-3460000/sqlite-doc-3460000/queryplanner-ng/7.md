## 3\.2\.  Complications


The presentation of the query planner problem above is a simplification.
The costs are estimates. We cannot
know what the true cost of running a loop is until we actually run the loop.
SQLite makes guesses for the cost of running a loop based on
the availability of indexes and constraints found in the WHERE
clause. These guesses are usually pretty good, but they can sometimes be
off. Using the [ANALYZE](lang_analyze.html) command to collect additional statistical
information about the database can sometimes enable SQLite to make better
guesses about the cost.


The costs are comprised of multiple numbers, not a single number as
shown in the graph.
SQLite computes several different estimated costs for each loop that apply at
different times. For example, there is a "setup" cost that is incurred
just once when the query starts. The setup cost is the cost of computing
an [query\-time index](optoverview.html#autoindex) for a table that does not already
have an index. Then there
is the cost of running each step of the loop. Finally, there is an estimate
of the number rows generated by the loop, which is information needed in
estimating the costs of inner loops. Sorting costs may come into play
if the query has an ORDER BY clause.


In a general query, dependencies need not be on a single loop, and hence
the matrix of dependencies might not be representable as a graph.
For example, one of the WHERE clause constraints might be
S.a\=L.b\+P.c, implying that the S loop must be an inner loop of both
L and P. Such dependencies cannot be drawn as a graph
since there is no way for an arc to originate at two or more nodes at
once.


If the query contains an ORDER BY clause or a GROUP BY clause or if
the query uses the DISTINCT keyword then it is advantageous to select a
path through the graph that causes rows to naturally appear in sorted order,
so that no separate sorting step is required. Automatic elimination of
ORDER BY clauses
can make a large performance difference, so this is another factor
that needs to be considered in a complete implementation.


In the TPC\-H Q8 query, the setup costs are all negligible,
all dependencies are between individual nodes, and there is no ORDER BY,
GROUP BY, or DISTINCT clause. So for TPC\-H Q8,
the graph above is a reasonable representation of what needs to be computed.
The general case involves a lot of extra complication, which for clarity
is neglected in the remainder of this article.


