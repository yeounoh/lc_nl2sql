## 2\.2\.  Posix advisory locks canceled by a separate thread doing close()


The default locking mechanism used by SQLite on unix platforms is
POSIX advisory locking. Unfortunately, POSIX advisory locking has design
quirks that make it prone to misuse and failure. In particular, any
thread in the same process with a file descriptor that is holding a POSIX
advisory lock can override that lock using a different file descriptor.
One particularly pernicious problem is that the close() system
call will cancel all POSIX advisory locks on the same file for all
threads and all file descriptors in the process.


So, for example, suppose a multi\-thread process has
two or more threads with separate SQLite database connections to the
same database file. Then a third thread comes along and wants to read
something out of that same database file on its own, without using the 
SQLite library.
The third thread does an open(), a read() and then
a close().
One would think this would be harmless.
But the close() system call caused the
locks held on the database by all the other threads to be dropped. Those
other threads have no way of knowing that their locks have just been
trashed (POSIX does not provide any mechanism to determine this) and so
they keep on running under the assumption that their locks are still valid.
This can lead to two or more threads or processes trying to write to the
database at the same time, resulting in database corruption.


Note that it is perfectly safe for two or more threads to access the
same SQLite database file using the SQLite library. The unix drivers for
SQLite know about the POSIX advisory locking quirks and work around them.
This problem only arises when a thread tries to bypass the SQLite library
and read the database file directly.


