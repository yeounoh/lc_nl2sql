# 4\. The Truncate Optimization


When the WHERE clause and RETURNING clause are both omitted
from a DELETE statement and the table being deleted has no triggers,
SQLite uses an optimization to erase the entire table content
without having to visit each row of the table individually.
This "truncate" optimization makes the delete run much faster.
Prior to SQLite [version 3\.6\.5](releaselog/3_6_5.html) (2008\-11\-12\), the truncate optimization
also meant that the [sqlite3\_changes()](c3ref/changes.html) and
[sqlite3\_total\_changes()](c3ref/total_changes.html) interfaces
and the [count\_changes pragma](pragma.html#pragma_count_changes)
will not actually return the number of deleted rows. 
That problem has been fixed as of [version 3\.6\.5](releaselog/3_6_5.html) (2008\-11\-12\).



The truncate optimization can be permanently disabled for all queries
by recompiling
SQLite with the [SQLITE\_OMIT\_TRUNCATE\_OPTIMIZATION](compile.html#omit_truncate_optimization) compile\-time switch.


The truncate optimization can also be disabled at runtime using
the [sqlite3\_set\_authorizer()](c3ref/set_authorizer.html) interface. If an authorizer callback
returns [SQLITE\_IGNORE](c3ref/c_deny.html) for an [SQLITE\_DELETE](c3ref/c_alter_table.html) action code, then
the DELETE operation will proceed but the truncate optimization will
be bypassed and rows will be deleted one by one.


*This page last modified on [2022\-01\-08 05:02:57](https://sqlite.org/docsrc/honeypot) UTC* 


