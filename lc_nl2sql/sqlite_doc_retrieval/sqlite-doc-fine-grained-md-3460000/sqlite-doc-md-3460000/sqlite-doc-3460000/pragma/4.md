## List Of PRAGMAs



* [analysis\_limit](pragma.html#pragma_analysis_limit)
* [application\_id](pragma.html#pragma_application_id)
* [auto\_vacuum](pragma.html#pragma_auto_vacuum)
* [automatic\_index](pragma.html#pragma_automatic_index)
* [busy\_timeout](pragma.html#pragma_busy_timeout)
* [cache\_size](pragma.html#pragma_cache_size)
* [cache\_spill](pragma.html#pragma_cache_spill)
* [~~case\_sensitive\_like¹~~](pragma.html#pragma_case_sensitive_like)
* [cell\_size\_check](pragma.html#pragma_cell_size_check)
* [checkpoint\_fullfsync](pragma.html#pragma_checkpoint_fullfsync)
* [collation\_list](pragma.html#pragma_collation_list)
* [compile\_options](pragma.html#pragma_compile_options)
* [~~count\_changes¹~~](pragma.html#pragma_count_changes)
* [~~data\_store\_directory¹~~](pragma.html#pragma_data_store_directory)
* [data\_version](pragma.html#pragma_data_version)
* [database\_list](pragma.html#pragma_database_list)
* [~~default\_cache\_size¹~~](pragma.html#pragma_default_cache_size)
* [defer\_foreign\_keys](pragma.html#pragma_defer_foreign_keys)
* [~~empty\_result\_callbacks¹~~](pragma.html#pragma_empty_result_callbacks)
* [encoding](pragma.html#pragma_encoding)
* [foreign\_key\_check](pragma.html#pragma_foreign_key_check)
* [foreign\_key\_list](pragma.html#pragma_foreign_key_list)
* [foreign\_keys](pragma.html#pragma_foreign_keys)
* [freelist\_count](pragma.html#pragma_freelist_count)
* [~~full\_column\_names¹~~](pragma.html#pragma_full_column_names)
* [fullfsync](pragma.html#pragma_fullfsync)
* [function\_list](pragma.html#pragma_function_list)
* [hard\_heap\_limit](pragma.html#pragma_hard_heap_limit)
* [ignore\_check\_constraints](pragma.html#pragma_ignore_check_constraints)
* [incremental\_vacuum](pragma.html#pragma_incremental_vacuum)
* [index\_info](pragma.html#pragma_index_info)
* [index\_list](pragma.html#pragma_index_list)
* [index\_xinfo](pragma.html#pragma_index_xinfo)
* [integrity\_check](pragma.html#pragma_integrity_check)
* [journal\_mode](pragma.html#pragma_journal_mode)
* [journal\_size\_limit](pragma.html#pragma_journal_size_limit)
* [legacy\_alter\_table](pragma.html#pragma_legacy_alter_table)
* [legacy\_file\_format](pragma.html#pragma_legacy_file_format)
* [locking\_mode](pragma.html#pragma_locking_mode)
* [max\_page\_count](pragma.html#pragma_max_page_count)
* [mmap\_size](pragma.html#pragma_mmap_size)
* [module\_list](pragma.html#pragma_module_list)
* [optimize](pragma.html#pragma_optimize)
* [page\_count](pragma.html#pragma_page_count)
* [page\_size](pragma.html#pragma_page_size)
* [parser\_trace²](pragma.html#pragma_parser_trace)
* [pragma\_list](pragma.html#pragma_pragma_list)
* [query\_only](pragma.html#pragma_query_only)
* [quick\_check](pragma.html#pragma_quick_check)
* [read\_uncommitted](pragma.html#pragma_read_uncommitted)
* [recursive\_triggers](pragma.html#pragma_recursive_triggers)
* [reverse\_unordered\_selects](pragma.html#pragma_reverse_unordered_selects)
* [schema\_version³](pragma.html#pragma_schema_version)
* [secure\_delete](pragma.html#pragma_secure_delete)
* [~~short\_column\_names¹~~](pragma.html#pragma_short_column_names)
* [shrink\_memory](pragma.html#pragma_shrink_memory)
* [soft\_heap\_limit](pragma.html#pragma_soft_heap_limit)
* [stats³](pragma.html#pragma_stats)
* [synchronous](pragma.html#pragma_synchronous)
* [table\_info](pragma.html#pragma_table_info)
* [table\_list](pragma.html#pragma_table_list)
* [table\_xinfo](pragma.html#pragma_table_xinfo)
* [temp\_store](pragma.html#pragma_temp_store)
* [~~temp\_store\_directory¹~~](pragma.html#pragma_temp_store_directory)
* [threads](pragma.html#pragma_threads)
* [trusted\_schema](pragma.html#pragma_trusted_schema)
* [user\_version](pragma.html#pragma_user_version)
* [vdbe\_addoptrace²](pragma.html#pragma_vdbe_addoptrace)
* [vdbe\_debug²](pragma.html#pragma_vdbe_debug)
* [vdbe\_listing²](pragma.html#pragma_vdbe_listing)
* [vdbe\_trace²](pragma.html#pragma_vdbe_trace)
* [wal\_autocheckpoint](pragma.html#pragma_wal_autocheckpoint)
* [wal\_checkpoint](pragma.html#pragma_wal_checkpoint)
* [writable\_schema³](pragma.html#pragma_writable_schema)



Notes:
1. Pragmas whose names are ~~struck through~~
are deprecated. Do not use them. They exist
for historical compatibility.
- These pragmas are only available in builds using non\-standard
compile\-time options.
- These pragmas are used for testing SQLite and are not recommended
for use in application programs.




 PRAGMA analysis\_limit

---


**PRAGMA analysis\_limit;
   
PRAGMA analysis\_limit \=** *N***;**


Query or change a limit on the [approximate ANALYZE](lang_analyze.html#approx) setting.
 This is the approximate number of
 rows examined in each index by the [ANALYZE](lang_analyze.html) command.
 If the argument *N* is omitted, then the analysis limit
 is unchanged.
 If the limit is zero, then the analysis limit is disabled and
 the ANALYZE command will examine all rows of each index.
 If N is greater than zero, then the analysis limit is set to N
 and subsequent ANALYZE commands will stop analyzing
 each index after it has examined approximately N rows.
 If N is a negative number or something other than an integer value,
 then the pragma behaves as if the N argument was omitted.
 In all cases, the value returned is the new analysis limit used
 for subsequent ANALYZE commands.
 This pragma can be used to help the ANALYZE command run faster
 on large databases. The results of analysis are not as good
 when only part of each index is examined, but the results are
 usually good enough. Setting N to 100 or 1000 allows the
 ANALYZE command to run quickly, even on enormous
 database files.
 This pragma was added in SQLite version 3\.32\.0 (2020\-05\-22\).
 The current implementation only uses the lower 31 bits of the
 N value \- higher order bits are silently ignored. Future versions
 of SQLite might begin using higher order bits.
 Beginning with SQLite version 3\.46\.0 (2024\-05\-23\),
 the recommended way of running [ANALYZE](lang_analyze.html) is with the
 [PRAGMA optimize](pragma.html#pragma_optimize) command. The [PRAGMA optimize](pragma.html#pragma_optimize) will automatically
 set a reasonable, temporary analysis limit that ensures that the
 [PRAGMA optimize](pragma.html#pragma_optimize) command will finish quickly even on enormous
 databases. Applications that use the [PRAGMA optimize](pragma.html#pragma_optimize) instead of
 running [ANALYZE](lang_analyze.html) directly do not need to set an analysis limit.

 PRAGMA application\_id

---


**PRAGMA** *schema.***application\_id;
   
PRAGMA** *schema.***application\_id \=** *integer* **;**
The application\_id PRAGMA is used to query or set the 32\-bit
 signed big\-endian "Application ID" integer located at offset
 68 into the [database header](fileformat2.html#database_header). Applications that use SQLite as their
 [application file\-format](appfileformat.html) should set the Application ID integer to
 a unique integer so that utilities such as 
 [file(1\)](http://www.darwinsys.com/file/) can determine the specific
 file type rather than just reporting "SQLite3 Database". A list of
 assigned application IDs can be seen by consulting the
 [magic.txt](https://www.sqlite.org/src/artifact?ci=trunk&filename=magic.txt) file in the SQLite source repository.

 See also the [user\_version pragma](pragma.html#pragma_user_version).

 PRAGMA auto\_vacuum

---


**PRAGMA** *schema.***auto\_vacuum;  

 PRAGMA** *schema.***auto\_vacuum \=** 
*0 \| NONE \| 1 \| FULL \| 2 \| INCREMENTAL***;**


Query or set the auto\-vacuum status in the database.


The default setting for auto\-vacuum is 0 or "none",
 unless the [SQLITE\_DEFAULT\_AUTOVACUUM](compile.html#default_autovacuum) compile\-time option is used.
 The "none" setting means that auto\-vacuum is disabled.
 When auto\-vacuum is disabled and data is deleted data from a database,
 the database file remains the same size. Unused database file 
 pages are added to a "[freelist](fileformat2.html#freelist)" and reused for subsequent inserts. So
 no database file space is lost. However, the database file does not
 shrink. In this mode the [VACUUM](lang_vacuum.html)
 command can be used to rebuild the entire database file and
 thus reclaim unused disk space.


When the auto\-vacuum mode is 1 or "full", the freelist pages are
 moved to the end of the database file and the database file is truncated
 to remove the freelist pages at every transaction commit.
 Note, however, that auto\-vacuum only truncates the freelist pages
 from the file. Auto\-vacuum does not defragment the database nor
 repack individual database pages the way that the
 [VACUUM](lang_vacuum.html) command does. In fact, because
 it moves pages around within the file, auto\-vacuum can actually
 make fragmentation worse.


Auto\-vacuuming is only possible if the database stores some
 additional information that allows each database page to be
 traced backwards to its referrer. Therefore, auto\-vacuuming must
 be turned on before any tables are created. It is not possible
 to enable or disable auto\-vacuum after a table has been created.


When the value of auto\-vacuum is 2 or "incremental" then the additional
 information needed to do auto\-vacuuming is stored in the database file
 but auto\-vacuuming does not occur automatically at each commit as it
 does with auto\_vacuum\=full. In incremental mode, the separate
 [incremental\_vacuum](pragma.html#pragma_incremental_vacuum) pragma must
 be invoked to cause the auto\-vacuum to occur.


The database connection can be changed between full and incremental
 autovacuum mode at any time. However, changing from
 "none" to "full" or "incremental" can only occur when the database 
 is new (no tables
 have yet been created) or by running the [VACUUM](lang_vacuum.html) command. To
 change auto\-vacuum modes, first use the auto\_vacuum pragma to set
 the new desired mode, then invoke the [VACUUM](lang_vacuum.html) command to 
 reorganize the entire database file. To change from "full" or
 "incremental" back to "none" always requires running [VACUUM](lang_vacuum.html) even
 on an empty database.
 


When the auto\_vacuum pragma is invoked with no arguments, it
 returns the current auto\_vacuum mode.



 PRAGMA automatic\_index

---


**PRAGMA automatic\_index;
   
PRAGMA automatic\_index \=** *boolean***;**


Query, set, or clear the [automatic indexing](optoverview.html#autoindex) capability.
 [Automatic indexing](optoverview.html#autoindex) is enabled by default as of 
 [version 3\.7\.17](releaselog/3_7_17.html) (2013\-05\-20\),
 but this might change in future releases of SQLite.

 PRAGMA busy\_timeout

---


**PRAGMA busy\_timeout;
   
PRAGMA busy\_timeout \=** *milliseconds***;**


Query or change the setting of the
 [busy timeout](c3ref/busy_timeout.html).
 This pragma is an alternative to the [sqlite3\_busy\_timeout()](c3ref/busy_timeout.html) C\-language
 interface which is made available as a pragma for use with language
 bindings that do not provide direct access to [sqlite3\_busy\_timeout()](c3ref/busy_timeout.html).

 Each database connection can only have a single
 [busy handler](c3ref/busy_handler.html). This PRAGMA sets the busy handler
 for the process, possibly overwriting any previously set busy handler.

 PRAGMA cache\_size

---


**PRAGMA** *schema.***cache\_size;
   
PRAGMA** *schema.***cache\_size \=** *pages***;
   
PRAGMA** *schema.***cache\_size \= \-***kibibytes***;**


Query or change the suggested maximum number of database disk pages
 that SQLite will hold in memory at once per open database file. Whether
 or not this suggestion is honored is at the discretion of the
 [Application Defined Page Cache](c3ref/pcache_methods2.html).
 The default page cache that is built into SQLite honors the request,
 however alternative application\-defined page cache implementations
 may choose to interpret the suggested cache size in different ways
 or to ignore it all together.
 The default suggested cache size is \-2000, which means the cache size
 is limited to 2048000 bytes of memory.
 The default suggested cache size can be altered using the
 [SQLITE\_DEFAULT\_CACHE\_SIZE](compile.html#default_cache_size) compile\-time options.
 The TEMP database has a default suggested cache size of 0 pages.


If the argument N is positive then the suggested cache size is set 
 to N. If the argument N is negative, then the
 number of cache pages is adjusted to be a number of pages that would
 use approximately abs(N\*1024\) bytes of memory based on the current
 page size. SQLite remembers the number of pages in the page cache,
 not the amount of memory used. So if you set the cache size using
 a negative number and subsequently change the page size (using the
 [PRAGMA page\_size](pragma.html#pragma_page_size) command) then the maximum amount of cache
 memory will go up or down in proportion to the change in page size.

 *Backwards compatibility note:*
 The behavior of cache\_size with a negative N
 was different prior to [version 3\.7\.10](releaselog/3_7_10.html) (2012\-01\-16\). In
 earlier versions, the number of pages in the cache was set
 to the absolute value of N.


When you change the cache size using the cache\_size pragma, the
 change only endures for the current session. The cache size reverts
 to the default value when the database is closed and reopened.


The default page cache implemention does not allocate
 the full amount of cache memory all at once. Cache memory
 is allocated in smaller chunks on an as\-needed basis. The page\_cache
 setting is a (suggested) upper bound on the amount of memory that the
 cache can use, not the amount of memory it will use all of the time.
 This is the behavior of the default page cache implementation, but an
 [application defined page cache](c3ref/pcache_methods2.html) is free
 to behave differently if it wants.

 PRAGMA cache\_spill

---


**PRAGMA cache\_spill;
   
PRAGMA cache\_spill\=***boolean***;
   
PRAGMA** *schema.***cache\_spill\=*N*;**


The cache\_spill pragma enables or disables the ability of the pager
 to spill dirty cache pages to the database file in the middle of a 
 transaction. Cache\_spill is enabled by default and most applications
 should leave it that way as cache spilling is usually advantageous.
 However, a cache spill has the side\-effect of acquiring an
 [EXCLUSIVE lock](lockingv3.html#excl_lock) on the database file. Hence, some applications that
 have large long\-running transactions may want to disable cache spilling
 in order to prevent the application from acquiring an exclusive lock
 on the database until the moment that the transaction [COMMIT](lang_transaction.html)s.
 The "PRAGMA cache\_spill\=*N*" form of this pragma sets a minimum
 cache size threshold required for spilling to occur. The number of pages
 in cache must exceed both the cache\_spill threshold and the maximum cache
 size set by the [PRAGMA cache\_size](pragma.html#pragma_cache_size) statement in order for spilling to
 occur.
 The "PRAGMA cache\_spill\=*boolean*" form of this pragma applies
 across all databases attached to the database connection. But the
 "PRAGMA cache\_spill\=*N*" form of this statement only applies to
 the "main" schema or whatever other schema is specified as part of the
 statement.

 PRAGMA case\_sensitive\_like

---


**PRAGMA case\_sensitive\_like \=** *boolean***;**


The default behavior of the [LIKE](lang_expr.html#like) operator is to ignore case
 for ASCII characters. Hence, by default **'a' LIKE 'A'** is
 true. The case\_sensitive\_like pragma installs a new application\-defined
 LIKE function that is either case sensitive or insensitive depending
 on the value of the case\_sensitive\_like pragma.
 When case\_sensitive\_like is disabled, the default LIKE behavior is
 expressed. When case\_sensitive\_like is enabled, case becomes
 significant. So, for example,
 **'a' LIKE 'A'** is false but **'a' LIKE 'a'** is still true.


This pragma uses [sqlite3\_create\_function()](c3ref/create_function.html) to overload the
 LIKE and GLOB functions, which may override previous implementations
 of LIKE and GLOB registered by the application. This pragma
 only changes the behavior of the SQL [LIKE](lang_expr.html#like) operator. It does not
 change the behavior of the [sqlite3\_strlike()](c3ref/strlike.html) C\-language interface,
 which is always case insensitive.


**WARNING:** If a database uses the LIKE operator anywhere in
 the schema, such as in a [CHECK constraint](lang_createtable.html#ckconst) or in an
 [expression index](expridx.html) or in the WHERE clause of a [partial index](partialindex.html), then
 changing the definition of the LIKE operator using this PRAGMA can
 cause the database to appear to be corrupt. [PRAGMA integrity\_check](pragma.html#pragma_integrity_check)
 will report errors. The database is not really corrupt in that
 changing the behavior of LIKE back to the way
 it was when the schema was defined and the database was populated
 will clear the problem. If the use of LIKE occurs only in indexes,
 then the problem can be cleared by running [REINDEX](lang_reindex.html). Nevertheless, 
 the use of the case\_sensitive\_like pragma is discouraged.



**This pragma is deprecated** and exists
 for backwards compatibility only. New applications
 should avoid using this pragma. Older applications should discontinue
 use of this pragma at the earliest opportunity. This pragma may be omitted
 from the build when SQLite is compiled using [SQLITE\_OMIT\_DEPRECATED](compile.html#omit_deprecated).
 



 PRAGMA cell\_size\_check

---


**PRAGMA cell\_size\_check
   
PRAGMA cell\_size\_check \=** *boolean***;**


The cell\_size\_check pragma enables or disables additional sanity
 checking on database b\-tree pages as they are initially read from disk.
 With cell size checking enabled, database corruption is detected earlier
 and is less likely to "spread". However, there is a small performance
 hit for doing the extra checks and so cell size checking is turned off
 by default.

 PRAGMA checkpoint\_fullfsync

---


**PRAGMA checkpoint\_fullfsync
   
PRAGMA checkpoint\_fullfsync \=** *boolean***;**


Query or change the fullfsync flag for [checkpoint](wal.html#ckpt) operations.
 If this flag is set, then the F\_FULLFSYNC syncing method is used
 during checkpoint operations on systems that support F\_FULLFSYNC. 
 The default value of the checkpoint\_fullfsync flag
 is off. Only Mac OS\-X supports F\_FULLFSYNC.


If the [fullfsync](pragma.html#pragma_fullfsync) flag is set, then the F\_FULLFSYNC syncing
 method is used for all sync operations and the checkpoint\_fullfsync
 setting is irrelevant.



 PRAGMA collation\_list

---


**PRAGMA collation\_list;**


Return a list of the collating sequences defined for the current
 database connection.



 PRAGMA compile\_options

---


**PRAGMA compile\_options;**


This pragma returns the names of [compile\-time options](compile.html) used when
 building SQLite, one option per row. The "SQLITE\_" prefix is omitted
 from the returned option names. See also the
 [sqlite3\_compileoption\_get()](c3ref/compileoption_get.html) C/C\+\+ interface and the
 [sqlite\_compileoption\_get()](lang_corefunc.html#sqlite_compileoption_get) SQL functions.



 PRAGMA count\_changes

---


**PRAGMA count\_changes;
   
PRAGMA count\_changes \=** boolean**;**


Query or change the count\-changes flag. Normally, when the
 count\-changes flag is not set, [INSERT](lang_insert.html), [UPDATE](lang_update.html) and [DELETE](lang_delete.html) statements
 return no data. When count\-changes is set, each of these commands 
 returns a single row of data consisting of one integer value \- the
 number of rows inserted, modified or deleted by the command. The 
 returned change count does not include any insertions, modifications
 or deletions performed by triggers, any changes made automatically
 by [foreign key actions](foreignkeys.html#fk_actions), or updates caused by an [upsert](lang_upsert.html).


Another way to get the row change counts is to use the
 [sqlite3\_changes()](c3ref/changes.html) or [sqlite3\_total\_changes()](c3ref/total_changes.html) interfaces.
 There is a subtle different, though. When an INSERT, UPDATE, or
 DELETE is run against a view using an [INSTEAD OF trigger](lang_createtrigger.html#instead_of_trigger),
 the count\_changes pragma reports the number of rows in the view
 that fired the trigger, whereas [sqlite3\_changes()](c3ref/changes.html) and
 [sqlite3\_total\_changes()](c3ref/total_changes.html) do not.

 
 
**This pragma is deprecated** and exists
 for backwards compatibility only. New applications
 should avoid using this pragma. Older applications should discontinue
 use of this pragma at the earliest opportunity. This pragma may be omitted
 from the build when SQLite is compiled using [SQLITE\_OMIT\_DEPRECATED](compile.html#omit_deprecated).
 



 PRAGMA data\_store\_directory

---


**PRAGMA data\_store\_directory;
   
PRAGMA data\_store\_directory \= '***directory\-name***';**


Query or change the value of the [sqlite3\_data\_directory](c3ref/data_directory.html) global
 variable, which windows operating\-system interface backends use to
 determine where to store database files specified using a relative
 pathname.


Changing the data\_store\_directory setting is not threadsafe.
 Never change the data\_store\_directory setting if another thread
 within the application is running any SQLite interface at the same time.
 Doing so results in undefined behavior. Changing the data\_store\_directory
 setting writes to the [sqlite3\_data\_directory](c3ref/data_directory.html) global
 variable and that global variable is not protected by a mutex.


This facility is provided for WinRT which does not have an OS
 mechanism for reading or changing the current working directory.
 The use of this pragma in any other context is discouraged and may
 be disallowed in future releases.



**This pragma is deprecated** and exists
 for backwards compatibility only. New applications
 should avoid using this pragma. Older applications should discontinue
 use of this pragma at the earliest opportunity. This pragma may be omitted
 from the build when SQLite is compiled using [SQLITE\_OMIT\_DEPRECATED](compile.html#omit_deprecated).
 



 PRAGMA data\_version

---


**PRAGMA** *schema.***data\_version;**


The "PRAGMA data\_version" command provides an indication that the
 database file has been modified.
 Interactive programs that hold database content in memory or that
 display database content on\-screen can use the PRAGMA data\_version
 command to determine if they need to flush and reload their memory
 or update the screen display.


The integer values returned by two
 invocations of "PRAGMA data\_version" from the same connection
 will be different if changes were committed to the database 
 by any other connection in the interim.
 The "PRAGMA data\_version" value is unchanged for commits made
 on the same database connection.
 The behavior of "PRAGMA data\_version" is the same for all database
 connections, including database connections in separate processes
 and [shared cache](sharedcache.html) database connections.

 The "PRAGMA data\_version" value is a local property of each
 database connection and so values returned by two concurrent invocations
 of "PRAGMA data\_version" on separate database connections are 
 often different even though the underlying database is identical.
 It is only meaningful to compare the "PRAGMA data\_version" values
 returned by the same database connection at two different points in
 time.

 PRAGMA database\_list

---


**PRAGMA database\_list;**


This pragma works like a query to return one row for each database
 attached to the current database connection.
 The second column is "main" for the main database file, "temp"
 for the database file used to store TEMP objects, or the name of the
 ATTACHed database for other database files.
 The third column is the name of the database file itself, or an empty
 string if the database is not associated with a file.



 PRAGMA default\_cache\_size

---


**PRAGMA** *schema.***default\_cache\_size;
   
PRAGMA** *schema.***default\_cache\_size
 \=** *Number\-of\-pages***;**


This pragma queries or sets the suggested maximum number of pages
 of disk cache that will be allocated per open database file.
 The difference between this pragma and [cache\_size](pragma.html#pragma_cache_size) is that the
 value set here persists across database connections.
 The value of the default cache size is stored in the 4\-byte
 big\-endian integer located at offset 48 in the header of the
 database file.
 



**This pragma is deprecated** and exists
 for backwards compatibility only. New applications
 should avoid using this pragma. Older applications should discontinue
 use of this pragma at the earliest opportunity. This pragma may be omitted
 from the build when SQLite is compiled using [SQLITE\_OMIT\_DEPRECATED](compile.html#omit_deprecated).
 



 PRAGMA defer\_foreign\_keys

---


**PRAGMA defer\_foreign\_keys
   
PRAGMA defer\_foreign\_keys \=** *boolean***;**


When the defer\_foreign\_keys [PRAGMA](pragma.html#syntax) is on,
 enforcement of all [foreign key constraints](foreignkeys.html) is delayed until the
 outermost transaction is committed. The defer\_foreign\_keys pragma
 defaults to OFF so that foreign key constraints are only deferred if
 they are created as "DEFERRABLE INITIALLY DEFERRED". The 
 defer\_foreign\_keys pragma is automatically switched off at each
 COMMIT or ROLLBACK. Hence, the defer\_foreign\_keys pragma must be
 separately enabled for each transaction. This pragma is
 only meaningful if foreign key constraints are enabled, of course.


The [sqlite3\_db\_status](c3ref/db_status.html)(db,[SQLITE\_DBSTATUS\_DEFERRED\_FKS](c3ref/c_dbstatus_options.html#sqlitedbstatusdeferredfks),...)
 C\-language interface can be used during a transaction to determine 
 if there are deferred and unresolved foreign key constraints.



 PRAGMA empty\_result\_callbacks

---


**PRAGMA empty\_result\_callbacks;
   
PRAGMA empty\_result\_callbacks \=** *boolean***;**


Query or change the empty\-result\-callbacks flag.


The empty\-result\-callbacks flag affects the [sqlite3\_exec()](c3ref/exec.html) API only.
 Normally, when the empty\-result\-callbacks flag is cleared, the
 callback function supplied to the [sqlite3\_exec()](c3ref/exec.html) is not invoked
 for commands that return zero rows of data. When empty\-result\-callbacks
 is set in this situation, the callback function is invoked exactly once,
 with the third parameter set to 0 (NULL). This is to enable programs 
 that use the [sqlite3\_exec()](c3ref/exec.html) API to retrieve column\-names even when
 a query returns no data.



**This pragma is deprecated** and exists
 for backwards compatibility only. New applications
 should avoid using this pragma. Older applications should discontinue
 use of this pragma at the earliest opportunity. This pragma may be omitted
 from the build when SQLite is compiled using [SQLITE\_OMIT\_DEPRECATED](compile.html#omit_deprecated).
 



 PRAGMA encoding

---


**PRAGMA encoding;
   
PRAGMA encoding \= 'UTF\-8';
   
PRAGMA encoding \= 'UTF\-16';
   
PRAGMA encoding \= 'UTF\-16le';
   
PRAGMA encoding \= 'UTF\-16be';**


In first form, if the main database has already been
 created, then this pragma returns the text encoding used by the
 main database, one of 'UTF\-8', 'UTF\-16le' (little\-endian UTF\-16
 encoding) or 'UTF\-16be' (big\-endian UTF\-16 encoding). If the main
 database has not already been created, then the value returned is the
 text encoding that will be used to create the main database, if 
 it is created by this session.


The second through fifth forms of this pragma
 set the encoding that the main database will be created with if
 it is created by this session. The string 'UTF\-16' is interpreted
 as "UTF\-16 encoding using native machine byte\-ordering". It is not
 possible to change the text encoding of a database after it has been
 created and any attempt to do so will be silently ignored.


If no encoding is first set with this pragma,
 then the encoding with which the main database will be created
 defaults to one determined by the
 [API used to open the connection](c3ref/open.html).


Once an encoding has been set for a database, it cannot be changed.


Databases created by the [ATTACH](lang_attach.html) command always use the same encoding
 as the main database. An attempt to [ATTACH](lang_attach.html) a database with a different
 text encoding from the "main" database will fail.



 PRAGMA foreign\_key\_check

---


**PRAGMA** *schema.***foreign\_key\_check;
   
PRAGMA** *schema.***foreign\_key\_check(***table\-name***);**


The foreign\_key\_check pragma checks the database, or the table
 called "*table\-name*", for 
 [foreign key constraints](foreignkeys.html) that are violated. The foreign\_key\_check
 pragma returns one row output for each foreign key violation.
 There are four columns in each result row.
 The first column is the name of the table that contains the REFERENCES
 clause. The second column is the [rowid](lang_createtable.html#rowid) of the row that
 contains the invalid REFERENCES clause, or NULL if the child table is a
 [WITHOUT ROWID](withoutrowid.html) table. The third column is the name
 of the table that is referred to. The fourth column is the index of
 the specific foreign key constraint that failed. The fourth column
 in the output of the foreign\_key\_check pragma is the same integer as
 the first column in the output of the [foreign\_key\_list pragma](pragma.html#pragma_foreign_key_list).
 When a "*table\-name*" is specified, the only foreign key constraints
 checked are those created by REFERENCES clauses in the
 CREATE TABLE statement for *table\-name*.



 PRAGMA foreign\_key\_list

---


**PRAGMA foreign\_key\_list(***table\-name***);**


This pragma returns one row for each [foreign key constraint](foreignkeys.html)
 created by a REFERENCES clause in the CREATE TABLE statement of
 table "*table\-name*".

 PRAGMA foreign\_keys

---


**PRAGMA foreign\_keys;
   
PRAGMA foreign\_keys \=** *boolean***;**


Query, set, or clear the enforcement of [foreign key constraints](foreignkeys.html).

 This pragma is a no\-op within a transaction; foreign key constraint
 enforcement may only be enabled or disabled when there is no pending
 [BEGIN](lang_transaction.html) or [SAVEPOINT](lang_savepoint.html).

 Changing the foreign\_keys setting affects the execution of
 all statements prepared
 using the database connection, including those prepared before the
 setting was changed. Any existing statements prepared using the legacy 
 [sqlite3\_prepare()](c3ref/prepare.html) interface may fail with an [SQLITE\_SCHEMA](rescode.html#schema) error
 after the foreign\_keys setting is changed.

 As of SQLite [version 3\.6\.19](releaselog/3_6_19.html), the default setting for foreign
 key enforcement is OFF. However, that might change in a future
 release of SQLite. The default setting for foreign key enforcement
 can be specified at compile\-time using the [SQLITE\_DEFAULT\_FOREIGN\_KEYS](compile.html#default_foreign_keys)
 preprocessor macro. To minimize future problems, applications should
 set the foreign key enforcement flag as required by the application
 and not depend on the default setting.

 PRAGMA freelist\_count

---


**PRAGMA** *schema.***freelist\_count;**


Return the number of unused pages in the database file.



 PRAGMA full\_column\_names

---


**PRAGMA full\_column\_names;
   
PRAGMA full\_column\_names \=** *boolean***;**


Query or change the full\_column\_names flag. This flag together 
 with the [short\_column\_names](pragma.html#pragma_short_column_names) flag determine
 the way SQLite assigns names to result columns of [SELECT](lang_select.html) statements.
 Result columns are named by applying the following rules in order:
 1. If there is an AS clause on the result, then the name of
 the column is the right\-hand side of the AS clause.
2. If the result is a general expression, not a just the name of
 a source table column,
 then the name of the result is a copy of the expression text.
3. If the [short\_column\_names](pragma.html#pragma_short_column_names) pragma is ON, then the name of the
 result is the name of the source table column without the 
 source table name prefix: COLUMN.
4. If both pragmas [short\_column\_names](pragma.html#pragma_short_column_names) and [full\_column\_names](pragma.html#pragma_full_column_names)
 are OFF then case (2\) applies.
5. The name of the result column is a combination of the source table
 and source column name: TABLE.COLUMN



**This pragma is deprecated** and exists
 for backwards compatibility only. New applications
 should avoid using this pragma. Older applications should discontinue
 use of this pragma at the earliest opportunity. This pragma may be omitted
 from the build when SQLite is compiled using [SQLITE\_OMIT\_DEPRECATED](compile.html#omit_deprecated).
 



 PRAGMA fullfsync

---


**PRAGMA fullfsync
   
PRAGMA fullfsync \=** *boolean***;**


Query or change the fullfsync flag. This flag
 determines whether or not the F\_FULLFSYNC syncing method is used
 on systems that support it. The default value of the fullfsync flag
 is off. Only Mac OS X supports F\_FULLFSYNC.


See also [checkpoint\_fullfsync](pragma.html#pragma_checkpoint_fullfsync).



 PRAGMA function\_list

---


**PRAGMA function\_list;**
This pragma returns a list of SQL functions
 known to the database connection. Each row of the result
 describes a single calling signature for a single SQL function.
 Some SQL functions will have multiple rows in the result set
 if they can (for example) be invoked with a varying number of
 arguments or can accept text in various encodings.

 PRAGMA hard\_heap\_limit

---


**PRAGMA hard\_heap\_limit  

 PRAGMA hard\_heap\_limit\=***N*


This pragma invokes the [sqlite3\_hard\_heap\_limit64()](c3ref/hard_heap_limit64.html) interface with
 the argument N, if N is specified and N is a positive integer that
 is less than the current hard heap limit.
 The hard\_heap\_limit pragma always returns the same integer
 that would be returned by the [sqlite3\_hard\_heap\_limit64](c3ref/hard_heap_limit64.html)(\-1\) C\-language
 function. That is to say, it always returns the value of the hard
 heap limit that is set after any changes imposed by this PRAGMA.
 


This pragma can only lower the heap limit, never raise it.
 The C\-language interface [sqlite3\_hard\_heap\_limit64()](c3ref/hard_heap_limit64.html) must be used
 to raise the heap limit.


See also the [soft\_heap\_limit pragma](pragma.html#pragma_soft_heap_limit).

 PRAGMA ignore\_check\_constraints

---


**PRAGMA ignore\_check\_constraints \=** *boolean***;**


This pragma enables or disables the enforcement of CHECK constraints.
 The default setting is off, meaning that CHECK constraints are
 enforced by default.



 PRAGMA incremental\_vacuum

---


**PRAGMA** *schema.***incremental\_vacuum***(N)***;  

 PRAGMA** *schema.***incremental\_vacuum;**


The incremental\_vacuum pragma causes up to *N* pages to
 be removed from the [freelist](fileformat2.html#freelist). The database file is truncated by
 the same amount. The incremental\_vacuum pragma has no effect if
 the database is not in
 [auto\_vacuum\=incremental](#pragma_auto_vacuum) mode
 or if there are no pages on the freelist. If there are fewer than
 *N* pages on the freelist, or if *N* is less than 1, or
 if the "(*N*)" argument is omitted, then the entire
 freelist is cleared.



 PRAGMA index\_info

---


**PRAGMA** *schema.***index\_info(***index\-name***);**


This pragma returns one row for each key column in the named index.
 A key column is a column that is actually named in the [CREATE INDEX](lang_createindex.html)
 index statement or [UNIQUE constraint](lang_createtable.html#uniqueconst) or [PRIMARY KEY constraint](lang_createtable.html#primkeyconst) that
 created the index. Index entries also usually contain auxiliary
 columns that point back to the table row being indexed. The auxiliary
 index\-columns are not shown by the index\_info pragma, but they are
 listed by the [index\_xinfo pragma](pragma.html#pragma_index_xinfo).


Output columns from the index\_info pragma are as follows:
 1. The rank of the column within the index. (0 means left\-most.)
 - The rank of the column within the table being indexed.
 A value of \-1 means [rowid](lang_createtable.html#rowid) and a value of \-2 means that an
 [expression](expridx.html) is being used.
 - The name of the column being indexed. This columns is NULL
 if the column is the [rowid](lang_createtable.html#rowid) or an [expression](expridx.html).


If there is no index named *index\-name* but there is a
 [WITHOUT ROWID](withoutrowid.html) table with that name, then (as of
 SQLite [version 3\.30\.0](releaselog/3_30_0.html) on 2019\-10\-04\) this pragma returns the
 PRIMARY KEY columns of the WITHOUT ROWID table as they are used
 in the records of the underlying b\-tree, which is to say with
 duplicate columns removed.

 PRAGMA index\_list

---


**PRAGMA** *schema.***index\_list(***table\-name***);**


This pragma returns one row for each index associated with the
 given table.
 Output columns from the index\_list pragma are as follows:
 1. A sequence number assigned to each index for internal tracking
 purposes.
 - The name of the index.
 - "1" if the index is UNIQUE and "0" if not.
 - "c" if the index was created by a [CREATE INDEX](lang_createindex.html) statement,
 "u" if the index was created by a [UNIQUE constraint](lang_createtable.html#uniqueconst), or
 "pk" if the index was created by a [PRIMARY KEY constraint](lang_createtable.html#primkeyconst).
 - "1" if the index is a [partial index](partialindex.html) and "0" if not.






 PRAGMA index\_xinfo

---


**PRAGMA** *schema.***index\_xinfo(***index\-name***);**


This pragma returns information about every column in an index.
 Unlike this [index\_info pragma](pragma.html#pragma_index_info), this pragma returns information about
 every column in the index, not just the key columns.
 (A key column is a column that is actually named in the [CREATE INDEX](lang_createindex.html)
 index statement or [UNIQUE constraint](lang_createtable.html#uniqueconst) or [PRIMARY KEY constraint](lang_createtable.html#primkeyconst) that
 created the index. Auxiliary columns are additional columns needed to
 locate the table entry that corresponds to each index entry.)

 Output columns from the index\_xinfo pragma are as follows:
 1. The rank of the column within the index. (0 means left\-most.
 Key columns come before auxiliary columns.)
 - The rank of the column within the table being indexed, or \-1 if
 the index\-column is the [rowid](lang_createtable.html#rowid) of the table being indexed and \-2
 if the [index is on an expression](expridx.html).
 - The name of the column being indexed, or NULL if the index\-column
 is the [rowid](lang_createtable.html#rowid) of the table being indexed or an
 [expression](expridx.html).
 - 1 if the index\-column is sorted in reverse (DESC) order by the
 index and 0 otherwise.
 - The name for the [collating sequence](datatype3.html#collation)
 used to compare values in the index\-column.
 - 1 if the index\-column is a key column and 0 if the index\-column
 is an auxiliary column.


If there is no index named *index\-name* but there is a
 [WITHOUT ROWID](withoutrowid.html) table with that name, then (as of
 SQLite [version 3\.30\.0](releaselog/3_30_0.html) on 2019\-10\-04\) this pragma returns the
 columns of the WITHOUT ROWID table as they are used
 in the records of the underlying b\-tree, which is to say with
 de\-duplicated PRIMARY KEY columns first followed by data columns.

 PRAGMA integrity\_check

---


**PRAGMA** *schema.***integrity\_check;
   
PRAGMA** *schema.***integrity\_check(***N***)
   
PRAGMA** *schema.***integrity\_check(***TABLENAME***)**


This pragma does a low\-level formatting and consistency check
 of the database. The integrity\_check pragma look for:
 * Table or index entries that are out of sequence
 * Misformatted records
 * Missing pages
 * Missing or surplus index entries
 * UNIQUE, CHECK, and NOT NULL constraint errors
 * Integrity of the freelist
 * Sections of the database that are used more than once, or not at all


If the integrity\_check pragma finds problems, strings are returned
 (as multiple rows with a single column per row) which describe
 the problems. Pragma integrity\_check will return at most *N*
 errors before the analysis quits, with N defaulting
 to 100\. If pragma integrity\_check finds no errors, a
 single row with the value 'ok' is returned.


The usual case is that the entire database file is checked. However,
 if the argument is *TABLENAME*, then checking is only performed for the
 the table named and its associated indexes.
 This is called a "partial integrity check". Because only a subset of the
 database is checked, errors such as unused sections of the file or duplication
 use of the same section of the file by two or more tables cannot be detected.
 The freelist is only verified on a
 partial integrity check if *TABLENAME* is [sqlite\_schema](schematab.html) or one of its
 aliases. Support for partial integrity checks was added with
 version 3\.33\.0 (2020\-08\-14\).

 PRAGMA integrity\_check does not find
 [FOREIGN KEY](foreignkeys.html) errors. 
 Use the [PRAGMA foreign\_key\_check](pragma.html#pragma_foreign_key_check) command to find errors in
 FOREIGN KEY constraints.


See also the [PRAGMA quick\_check](pragma.html#pragma_quick_check) command which does most of the
 checking of PRAGMA integrity\_check but runs much faster.



 PRAGMA journal\_mode

---


**PRAGMA** *schema.***journal\_mode;
   
PRAGMA** *schema.***journal\_mode
 \= *DELETE \| TRUNCATE \| PERSIST \| MEMORY \| WAL \| OFF***


This pragma queries or sets the journal mode for databases
 associated with the current [database connection](c3ref/sqlite3.html).


The first form of this pragma queries the current journaling
 mode for *database*. When *database* is omitted, the
 "main" database is queried.


The second form changes the journaling mode for "*database*"
 or for all attached databases if "*database*" is omitted.
 The new journal mode is returned. If the journal mode
 could not be changed, the original journal mode is returned.


The DELETE journaling mode is the normal behavior. In the DELETE
 mode, the rollback journal is deleted at the conclusion of each
 transaction. Indeed, the delete operation is the action that causes
 the transaction to commit.
 (See the document titled [Atomic Commit In SQLite](atomiccommit.html) for additional detail.)


The TRUNCATE journaling mode commits transactions by truncating
 the rollback journal to zero\-length instead of deleting it. On many
 systems, truncating a file is much faster than deleting the file since
 the containing directory does not need to be changed.


The PERSIST journaling mode prevents the rollback journal from
 being deleted at the end of each transaction. Instead, the header
 of the journal is overwritten with zeros. This will prevent other
 database connections from rolling the journal back. The PERSIST
 journaling mode is useful as an optimization on platforms where
 deleting or truncating a file is much more expensive than overwriting
 the first block of a file with zeros. See also:
 [PRAGMA journal\_size\_limit](pragma.html#pragma_journal_size_limit) and [SQLITE\_DEFAULT\_JOURNAL\_SIZE\_LIMIT](compile.html#default_journal_size_limit).


The MEMORY journaling mode stores the rollback journal in 
 volatile RAM. This saves disk I/O but at the expense of database
 safety and integrity. If the application using SQLite crashes in
 the middle of a transaction when the MEMORY journaling mode is set,
 then the database file will very likely 
 [go corrupt](howtocorrupt.html#cfgerr).


The WAL journaling mode uses a [write\-ahead log](wal.html) instead of a
 rollback journal to implement transactions. The WAL journaling mode
 is persistent; after being set it stays in effect
 across multiple database connections and after closing and
 reopening the database. A database in WAL journaling mode
 can only be accessed by SQLite [version 3\.7\.0](releaselog/3_7_0.html) (2010\-07\-21\)
 or later.


The OFF journaling mode disables the rollback journal completely.
 No rollback journal is ever created and hence there is never a rollback
 journal to delete. The OFF journaling mode disables the atomic
 commit and rollback capabilities of SQLite. The [ROLLBACK](lang_transaction.html) command
 no longer works; it behaves in an undefined way. Applications must
 avoid using the [ROLLBACK](lang_transaction.html) command when the journal mode is OFF.
 If the application crashes
 in the middle of a transaction when the OFF journaling mode is
 set, then the database file will very likely
 [go corrupt](howtocorrupt.html#cfgerr). Without a journal, there is no way for
 a statement to unwind partially completed operations following
 a constraint error. This might also leave the database in a corrupted
 state. For example, if a duplicate entry causes a 
 [CREATE UNIQUE INDEX](lang_createindex.html) statement to fail half\-way through,
 it will leave behind a partially created, and hence corrupt, index.
 Because OFF journaling
 mode allows the database file to be corrupted using ordinary SQL,
 it is disabled when [SQLITE\_DBCONFIG\_DEFENSIVE](c3ref/c_dbconfig_defensive.html#sqlitedbconfigdefensive) is enabled.


Note that the journal\_mode for an [in\-memory database](inmemorydb.html)
 is either MEMORY or OFF and can not be changed to a different value.
 An attempt to change the journal\_mode of an [in\-memory database](inmemorydb.html) to
 any setting other than MEMORY or OFF is ignored. Note also that
 the journal\_mode cannot be changed while a transaction is active.



 PRAGMA journal\_size\_limit

---


**PRAGMA** *schema.***journal\_size\_limit  

 PRAGMA** *schema.***journal\_size\_limit \=** *N* **;**
If a database connection is operating in
 [exclusive locking mode](pragma.html#pragma_locking_mode) or in
 [persistent journal mode](pragma.html#pragma_journal_mode) 
 (PRAGMA journal\_mode\=persist) then
 after committing a transaction the [rollback journal](lockingv3.html#rollback) file may remain in
 the file\-system. This increases performance for subsequent transactions
 since overwriting an existing file is faster than append to a file,
 but it also consumes
 file\-system space. After a large transaction (e.g. a [VACUUM](lang_vacuum.html)),
 the rollback journal file may consume a very large amount of space.

 Similarly, in [WAL mode](wal.html), the write\-ahead log file is not truncated
 following a [checkpoint](wal.html#ckpt). Instead, SQLite reuses the existing file
 for subsequent WAL entries since overwriting is faster than appending.

 The journal\_size\_limit pragma may be used to limit the size of 
 rollback\-journal and WAL files left
 in the file\-system after transactions or checkpoints.
 Each time a transaction is committed or a WAL file resets, SQLite 
 compares the size of the rollback journal file or WAL file left in 
 the file\-system to the size limit
 set by this pragma and if the journal or WAL file is larger 
 it is truncated to the limit.

 The second form of the pragma listed above is used to set a new limit
 in bytes for the specified database. A negative number implies no limit.
 To always truncate rollback journals and WAL files to their minimum size, 
 set the journal\_size\_limit to zero.
 Both the first and second forms of the pragma listed above return a single
 result row containing a single integer column \- the value of the journal
 size limit in bytes. The default journal size limit is \-1 (no limit). The
 [SQLITE\_DEFAULT\_JOURNAL\_SIZE\_LIMIT](compile.html#default_journal_size_limit) preprocessor macro can be used to change
 the default journal size limit at compile\-time.


This pragma only operates on the single database specified prior
 to the pragma name (or on the "main" database if no database is specified.)
 There is no way to change the journal size limit on all attached databases
 using a single PRAGMA statement. The size limit must be set separately for
 each attached database.

 PRAGMA legacy\_alter\_table

---


**PRAGMA legacy\_alter\_table;
   
PRAGMA legacy\_alter\_table \= *boolean***


This pragma sets or queries the value of the legacy\_alter\_table
 flag. When this flag is on, the [ALTER TABLE RENAME](lang_altertable.html#altertabrename)
 command (for changing the name of a table) works as it did
 in SQLite 3\.24\.0 (2018\-06\-04\) and earlier. More specifically,
 when this flag is on
 the [ALTER TABLE RENAME](lang_altertable.html#altertabrename) command only rewrites the initial occurrence
 of the table name in its [CREATE TABLE](lang_createtable.html) statement and in any associated
 [CREATE INDEX](lang_createindex.html) and [CREATE TRIGGER](lang_createtrigger.html) statements. Other references to the
 table are unmodified, including:
 * References to the table within the bodies of triggers and views.
 * References to the table within CHECK constraints in the original
 CREATE TABLE statement.
 * References to the table within the WHERE clauses of [partial indexes](partialindex.html).


 The default setting for this pragma is OFF, which means that all
 references to the table anywhere in the schema are converted to the new name.
 This pragma is provided as a work\-around for older programs that
 contain code that expect the incomplete behavior
 of [ALTER TABLE RENAME](lang_altertable.html#altertabrename) found in older versions of SQLite.
 New applications should leave this flag turned off.
 For compatibility with older [virtual table](vtab.html) implementations,
 this flag is turned on temporarily while the [sqlite3\_module.xRename](vtab.html#xrename)
 method is being run. The value of this flag is restored after the 
 [sqlite3\_module.xRename](vtab.html#xrename) method finishes.
 The legacy alter table behavior can also be toggled on and off
 using the [SQLITE\_DBCONFIG\_LEGACY\_ALTER\_TABLE](c3ref/c_dbconfig_defensive.html#sqlitedbconfiglegacyaltertable) option to the
 [sqlite3\_db\_config()](c3ref/db_config.html) interface.
 The legacy alter table behavior is a per\-connection setting. Turning
 this features on or off affects all attached database files within the
 [database connection](c3ref/sqlite3.html).
 The setting does not persist. Changing this setting in one connection
 does not affect any other connections.

 PRAGMA legacy\_file\_format

---


**PRAGMA legacy\_file\_format;**
This pragma no longer functions. It has become a no\-op.
 The capabilities formerly provided by PRAGMA legacy\_file\_format
 are now available using the [SQLITE\_DBCONFIG\_LEGACY\_FILE\_FORMAT](c3ref/c_dbconfig_defensive.html#sqlitedbconfiglegacyfileformat)
 option to the [sqlite3\_db\_config()](c3ref/db_config.html) C\-language interface.
 

 PRAGMA locking\_mode

---


**PRAGMA** *schema.***locking\_mode;
   
PRAGMA** *schema.***locking\_mode
 \= *NORMAL \| EXCLUSIVE***


This pragma sets or queries the database connection locking\-mode. 
 The locking\-mode is either NORMAL or EXCLUSIVE.

 In NORMAL locking\-mode (the default unless overridden at compile\-time
 using [SQLITE\_DEFAULT\_LOCKING\_MODE](compile.html#default_locking_mode)), a database connection
 unlocks the database file at the conclusion of each read or
 write transaction. When the locking\-mode is set to EXCLUSIVE, the
 database connection never releases file\-locks. The first time the
 database is read in EXCLUSIVE mode, a shared lock is obtained and 
 held. The first time the database is written, an exclusive lock is
 obtained and held.


Database locks obtained by a connection in EXCLUSIVE mode may be
 released either by closing the database connection, or by setting the
 locking\-mode back to NORMAL using this pragma and then accessing the
 database file (for read or write). Simply setting the locking\-mode to
 NORMAL is not enough \- locks are not released until the next time
 the database file is accessed.


There are three reasons to set the locking\-mode to EXCLUSIVE.
 1. The application wants to prevent other processes from
 accessing the database file.
 - The number of system calls for filesystem operations is reduced,
 possibly resulting in a small performance increase.
 - [WAL](wal.html) databases can be accessed in EXCLUSIVE mode without the
 use of shared memory. 
 ([Additional information](wal.html#noshm))





When the locking\_mode pragma specifies a particular database,
 for example:



> PRAGMA **main.**locking\_mode\=EXCLUSIVE;


then the locking mode applies only to the named database. If no
 database name qualifier precedes the "locking\_mode" keyword then
 the locking mode is applied to all databases, including any new
 databases added by subsequent [ATTACH](lang_attach.html) commands.


The "temp" database (in which TEMP tables and indices are stored)
 and [in\-memory databases](inmemorydb.html)
 always uses exclusive locking mode. The locking mode of temp and
 [in\-memory databases](inmemorydb.html) cannot
 be changed. All other databases use the normal locking mode by default
 and are affected by this pragma.


If the locking mode is EXCLUSIVE when first entering
 [WAL journal mode](wal.html), then the locking mode cannot be changed to
 NORMAL until after exiting WAL journal mode. 
 If the locking mode is NORMAL when first entering WAL
 journal mode, then the locking mode can be changed between NORMAL and
 EXCLUSIVE and back again at any time and without needing to exit
 WAL journal mode.



 PRAGMA max\_page\_count

---


**PRAGMA** *schema.***max\_page\_count;
   
PRAGMA** *schema.***max\_page\_count \=** *N***;**


Query or set the maximum number of pages in the database file.
 Both forms of the pragma return the maximum page count. The second
 form attempts to modify the maximum page count. The maximum page
 count cannot be reduced below the current database size.
 



 PRAGMA mmap\_size

---


  
**PRAGMA** *schema.***mmap\_size;
   
PRAGMA** *schema.***mmap\_size\=***N*


Query or change the maximum number of bytes that are set
 aside for memory\-mapped I/O on a single database. The first form
 (without an argument) queries the current limit. The second
 form (with a numeric argument) sets the limit for the specified
 database, or for all databases if the optional database name is
 omitted. In the second form, if the database name is omitted, the
 limit that is set becomes the default limit for all databases that
 are added to the [database connection](c3ref/sqlite3.html) by subsequent [ATTACH](lang_attach.html)
 statements.


The argument N is the maximum number of bytes of the database file
 that will be accessed using memory\-mapped I/O. If N is zero then
 memory mapped I/O is disabled. If N is negative, then the limit
 reverts to the default value determined by the most recent
 [sqlite3\_config](c3ref/config.html)([SQLITE\_CONFIG\_MMAP\_SIZE](c3ref/c_config_covering_index_scan.html#sqliteconfigmmapsize)), or to the compile
 time default determined by [SQLITE\_DEFAULT\_MMAP\_SIZE](compile.html#default_mmap_size) if not
 start\-time limit has been set.


The [PRAGMA mmap\_size](pragma.html#pragma_mmap_size) statement will never increase the amount
 of address space used for memory\-mapped I/O above the
 hard limit set by the [SQLITE\_MAX\_MMAP\_SIZE](compile.html#max_mmap_size) compile\-time option,
 nor the hard limit set at startup\-time by the second argument to
 sqlite3\_config([SQLITE\_CONFIG\_MMAP\_SIZE](c3ref/c_config_covering_index_scan.html#sqliteconfigmmapsize))


The size of the memory\-mapped I/O region cannot be changed while
 the memory\-mapped I/O region is in active use, to avoid unmapping
 memory out from under running SQL statements. For this reason,
 the mmap\_size pragma may be a no\-op if the prior mmap\_size is non\-zero
 and there are other SQL statements running concurrently on the same
 [database connection](c3ref/sqlite3.html).



 PRAGMA module\_list

---


**PRAGMA module\_list;**
This pragma returns a list of 
 [virtual table](vtab.html) modules registered with the database connection.

 PRAGMA optimize

---


**PRAGMA optimize;
   
PRAGMA optimize(***MASK***);
   
PRAGMA** *schema***.optimize;
   
PRAGMA** *schema***.optimize(***MASK***);**


Attempt to optimize the database. All schemas are optimized in the 
 first two forms, and only the specified schema is optimized in the latter
 two.


In most applications, using PRAGMA optimize as follows will help
 SQLite to achieve the best possible query performance:
 1. Applications with short\-lived database connections should run
 "PRAGMA optimize;" once, just prior to closing each database connection.

 - Applications that use long\-lived database connections should run
 "PRAGMA optimize\=0x10002;" when the connection is first opened, and then
 also run "PRAGMA optimize;" periodically, perhaps once per day or once
 per hour.

 - All applications should run "PRAGMA optimize;" after a schema change,
 especially after one or more [CREATE INDEX](lang_createindex.html) statements.


This pragma is usually a no\-op or nearly so and is very fast. On the
 occasions where it does need to run ANALYZE on one or more tables, it
 sets a temporary [analysis limit](pragma.html#pragma_analysis_limit), valid for the duration
 of this pragma only, that prevents the ANALYZE invocations from running for
 to long.


Recommended practice is that applications with short\-lived database
 connections should run "PRAGMA optimize" once when the database connection
 closes. Applications with long\-lived database connections should run
 "PRAGMA optimize\=0x10002" when the database connection first opens, then
 run "PRAGMA optimize" again at periodic intervals \- perhaps once per day.
 All applications should run "PRAGMA optimize" after schema changes, especially
 [CREATE INDEX](lang_createindex.html). 


The details of optimizations performed by this pragma are expected
 to change and improve over time. Applications should anticipate that
 this pragma will perform new optimizations in future releases.


The optional MASK argument is a bitmask of optimizations to perform:

 

| 0x00001   Debugging mode. Do not actually perform any optimizations  but instead return one line of text for each optimization  that would have been done. Off by default.  | 0x00002   Run [ANALYZE](lang_analyze.html) on tables that might benefit. On by default.| 0x00010   When running [ANALYZE](lang_analyze.html), set a temporary [PRAGMA analysis\_limit](pragma.html#pragma_analysis_limit) to  prevent excess run\-time. On by default.  | 0x10000   Check the size of all tables, not just tables that have not been  recently used, to see if any have grown and shrunk significantly  and hence might  benefit from being re\-analyzed. Off by default. | | | | | | | |
| --- | --- | --- | --- | --- | --- | --- | --- |


The default MASK is 0xfffe.


To see all optimizations that would have been done without actually
 doing them, run "PRAGMA optimize(\-1\)".


**Determination Of When To Run Analyze**


 In the current implementation, a table is analyzed if and only if 
 all of the following are true:
 1. MASK bit 0x02 is set.
 - The table is an ordinary table, not a view or virtual table.
 - The table name does not begin with "sqlite\_".
 - One or more of the following are true:
	1. The 0x10000 bit of MASK is set
	 - One or more indexes on the table lack entries in the sqlite\_stat1 table.
	 - The query planner used sqlite\_stat1 statistics for one or more indexes
	 of this table at some point during the lifetime of the current database
	 connection.- One or more of the following are true:
	1. One or more indexes on the table lack entries in the sqlite\_stat1 table.
	 - The number of rows in the table has increased or decreased by 10\-fold
	 since the last time ANALYZE was run on the table.


 The rules for when tables are analyzed are likely to change in
 future releases. New MASK values may be added in the future. Future
 versions of this pragma might accept a string literal argument instead
 of a bit mask, though the bit mask argument will continue to be supported
 for backwards compatibility.

 PRAGMA page\_count

---


**PRAGMA** *schema.***page\_count;**


Return the total number of pages in the database file.



 PRAGMA page\_size

---


**PRAGMA** *schema.***page\_size;
   
PRAGMA** *schema.***page\_size \=** *bytes***;**


Query or set the page size of the database. The page
 size must be a power of two between 512 and 65536 inclusive.
 


When a new database is created, SQLite assigns a page size to
 the database based on platform and filesystem. For many years,
 the default page size was almost always 1024 bytes, but beginning
 with SQLite [version 3\.12\.0](releaselog/3_12_0.html) (2016\-03\-29\), 
 the default page size increased to 4096\.
 The default page size is recommended for most applications.

 Specifying a new page size does not change the page size
 immediately. Instead, the new page size is remembered and is used
 to set the page size when the database is first created, if it does
 not already exist when the page\_size pragma is issued, or at the
 next [VACUUM](lang_vacuum.html) command that is run on the same database connection
 while not in [WAL mode](wal.html).


The [SQLITE\_DEFAULT\_PAGE\_SIZE](compile.html#default_page_size) compile\-time option can be used
 to change the default page size assigned to new databases.

 PRAGMA parser\_trace

---


**PRAGMA parser\_trace \=** *boolean***;** 


If SQLite has been compiled with the [SQLITE\_DEBUG](compile.html#debug) compile\-time
 option, then the parser\_trace pragma can be used to turn on tracing
 for the SQL parser used internally by SQLite.
 This feature is used for debugging SQLite itself.



 This pragma is intended for use when debugging SQLite itself. It
 is only available when the [SQLITE\_DEBUG](compile.html#debug) compile\-time option
 is used.



 PRAGMA pragma\_list

---


**PRAGMA pragma\_list;**
This pragma returns a list of PRAGMA commands
 known to the database connection.

 PRAGMA query\_only

---


**PRAGMA query\_only;
   
PRAGMA query\_only \=** *boolean***;**


The query\_only pragma prevents data changes on database files when
 enabled. When this pragma is enabled, any attempt to CREATE, DELETE,
 DROP, INSERT, or UPDATE will result in an [SQLITE\_READONLY](rescode.html#readonly) error.
 However, the database is not truly read\-only. You can still run
 a [checkpoint](wal.html#ckpt) or a [COMMIT](lang_transaction.html) and the return value of the
 [sqlite3\_db\_readonly()](c3ref/db_readonly.html) routine is not affected.
 



 PRAGMA quick\_check

---


**PRAGMA** *schema.***quick\_check;
   
PRAGMA** *schema.***quick\_check(***N***)**
  
PRAGMA *schema.***quick\_check(***TABLENAME***)**


The pragma is like [integrity\_check](pragma.html#pragma_integrity_check) except that it does not verify
 UNIQUE constraints and does not verify
 that index content matches table content. By skipping UNIQUE
 and index consistency checks, quick\_check is able to run faster.
 PRAGMA quick\_check runs in O(N) time whereas [PRAGMA integrity\_check](pragma.html#pragma_integrity_check)
 requires O(NlogN) time where N is the total number of rows in the 
 database. Otherwise the two pragmas are the same.
 



 PRAGMA read\_uncommitted

---


**PRAGMA read\_uncommitted;
   
PRAGMA read\_uncommitted \=** *boolean***;**


Query, set, or clear READ UNCOMMITTED isolation. The default isolation
 level for SQLite is SERIALIZABLE. Any process or thread can select
 READ UNCOMMITTED isolation, but SERIALIZABLE will still be used except
 between connections that share a common page and schema cache.
 Cache sharing is enabled using the [sqlite3\_enable\_shared\_cache()](c3ref/enable_shared_cache.html) API.
 Cache sharing is disabled by default.
 


See [SQLite Shared\-Cache Mode](sharedcache.html) for additional information.



 PRAGMA recursive\_triggers

---


**PRAGMA recursive\_triggers;
   
PRAGMA recursive\_triggers \=** *boolean***;**


Query, set, or clear the recursive trigger capability.

 Changing the recursive\_triggers setting affects the execution of
 all statements prepared
 using the database connection, including those prepared before the
 setting was changed. Any existing statements prepared using the legacy 
 [sqlite3\_prepare()](c3ref/prepare.html) interface may fail with an [SQLITE\_SCHEMA](rescode.html#schema) error
 after the recursive\_triggers setting is changed.

 Prior to SQLite [version 3\.6\.18](releaselog/3_6_18.html) (2009\-09\-11\), 
 recursive triggers were not supported.
 The behavior of SQLite was always as if this pragma was
 set to OFF. Support for recursive triggers was added in version 3\.6\.18
 but was initially turned OFF by default, for compatibility. Recursive
 triggers may be turned on by default in future versions of SQLite.
 


The depth of recursion for triggers has a hard upper limit set by
 the [SQLITE\_MAX\_TRIGGER\_DEPTH](limits.html#max_trigger_depth) compile\-time option and a run\-time
 limit set by [sqlite3\_limit](c3ref/limit.html)(db,[SQLITE\_LIMIT\_TRIGGER\_DEPTH](c3ref/c_limit_attached.html#sqlitelimittriggerdepth),...).



 PRAGMA reverse\_unordered\_selects

---


**PRAGMA reverse\_unordered\_selects;
   
PRAGMA reverse\_unordered\_selects \=** *boolean***;**


When enabled, this PRAGMA causes many [SELECT](lang_select.html) statements without
 an ORDER BY clause to emit their results in the reverse order from what
 they normally would. This can help debug applications that are
 making invalid assumptions about the result order. 
 The reverse\_unordered\_selects pragma works for most SELECT statements,
 however the query planner may sometimes choose an algorithm that is
 not easily reversed, in which case the output will appear in the same
 order regardless of the reverse\_unordered\_selects setting.
 SQLite makes no
 guarantees about the order of results if a SELECT omits the ORDER BY
 clause. Even so, the order of results does not change from one
 run to the next, and so many applications mistakenly come to depend
 on the arbitrary output order whatever that order happens to be. However, 
 sometimes new versions of SQLite will contain optimizer enhancements
 that will cause the output order of queries without ORDER BY clauses
 to shift. When that happens, applications that depend on a certain
 output order might malfunction. By running the application multiple
 times with this pragma both disabled and enabled, cases where the
 application makes faulty assumptions about output order can be
 identified and fixed early, reducing problems
 that might be caused by linking against a different version of SQLite.
 



 PRAGMA schema\_version

---


**PRAGMA** *schema.***schema\_version; 
   
PRAGMA** *schema.***schema\_version \=** *integer* ;

 The schema\_version pragma will get or set
 the value of the schema\-version integer at offset 40 in the
 [database header](fileformat2.html#database_header). 

 SQLite automatically increments the schema\-version whenever the
 schema changes. As each SQL statement runs, the schema version is
 checked to ensure that the schema has not changed since the SQL
 statement was [prepared](c3ref/prepare.html).
 Subverting this mechanism by using "PRAGMA schema\_version\=N"
 to change the value of the schema\_version
 may cause SQL statement to run using an obsolete schema,
 which can lead to incorrect answers and/or
 [database corruption](howtocorrupt.html#cfgerr).
 It is always safe to read the schema\_version, but changing the
 schema\_version can cause problems. For this reason, attempts
 to change the value of schema\_version are a silent no\-op when
 [defensive mode](c3ref/c_dbconfig_defensive.html#sqlitedbconfigdefensive) is enabled for a
 database connection.

 
 
**Warning:**
 Misuse of this pragma can result in [database corruption](howtocorrupt.html#cfgerr).
 


 For the purposes of this pragma, the [VACUUM](lang_vacuum.html) command is considered
 a schema change, since [VACUUM](lang_vacuum.html) will usually alter the "rootpage"
 values for entries in the [sqlite\_schema table](schematab.html).


 See also the [application\_id pragma](pragma.html#pragma_application_id) and [user\_version pragma](pragma.html#pragma_user_version).

 PRAGMA secure\_delete

---


**PRAGMA** *schema.***secure\_delete;
   
PRAGMA** *schema.***secure\_delete \=** *boolean*\|**FAST**


Query or change the secure\-delete setting. When secure\_delete is
 on, SQLite overwrites deleted content with zeros. The default
 setting for secure\_delete is determined by the [SQLITE\_SECURE\_DELETE](compile.html#secure_delete)
 compile\-time option and is normally off. The off setting for
 secure\_delete improves performance by reducing the number of CPU cycles
 and the amount of disk I/O. Applications that wish to avoid leaving
 forensic traces after content is deleted or updated should enable the
 secure\_delete pragma prior to performing the delete or update, or else
 run [VACUUM](lang_vacuum.html) after the delete or update.

 The "fast" setting for secure\_delete (added circa 2017\-08\-01\)
 is an intermediate setting in between "on" and "off".
 When secure\_delete is set to "fast",
 SQLite will overwrite deleted content with zeros only if doing so
 does not increase the amount of I/O. In other words, the "fast"
 setting uses more CPU cycles but does not use more I/O.
 This has the effect of purging all old content from [b\-tree pages](fileformat2.html#btree),
 but leaving forensic traces on [freelist pages](fileformat2.html#freelist).

 
 When there are [attached databases](lang_attach.html) and no database
 is specified in the pragma, all databases have their secure\-delete
 setting altered.
 The secure\-delete setting for newly attached databases is the setting
 of the main database at the time the ATTACH command is evaluated.

 
 When multiple database connections share the same cache, changing
 the secure\-delete flag on one database connection changes it for them
 all.
 


**Limitation:**
 The secure\_delete pragma only causes deleted content to be scrubbed
 from ordinary tables. If [virtual tables](vtab.html) store content in
 [shadow tables](vtab.html#xshadowname), then deleting content from the virtual table does
 not necessarily remove forensic traces from the shadow tables.
 In particular, the [FTS3](fts3.html) and [FTS5](fts5.html) virtual tables that come
 bundled with SQLite might leave forensic traces in their shadow tables
 even if the secure\_delete pragma is enabled.
 



 PRAGMA short\_column\_names

---


**PRAGMA short\_column\_names;
   
PRAGMA short\_column\_names \=** *boolean***;**


Query or change the short\-column\-names flag. This flag affects
 the way SQLite names columns of data returned by [SELECT](lang_select.html) statements.
 See the [full\_column\_names](pragma.html#pragma_full_column_names) pragma for full details.
 



**This pragma is deprecated** and exists
 for backwards compatibility only. New applications
 should avoid using this pragma. Older applications should discontinue
 use of this pragma at the earliest opportunity. This pragma may be omitted
 from the build when SQLite is compiled using [SQLITE\_OMIT\_DEPRECATED](compile.html#omit_deprecated).
 



 PRAGMA shrink\_memory

---


**PRAGMA shrink\_memory**


This pragma causes the database connection on which it is invoked
 to free up as much memory as it can, by calling
 [sqlite3\_db\_release\_memory()](c3ref/db_release_memory.html).
 



 PRAGMA soft\_heap\_limit

---


**PRAGMA soft\_heap\_limit  

 PRAGMA soft\_heap\_limit\=***N*


This pragma invokes the [sqlite3\_soft\_heap\_limit64()](c3ref/hard_heap_limit64.html) interface with
 the argument N, if N is specified and is a non\-negative integer.
 The soft\_heap\_limit pragma always returns the same integer
 that would be returned by the [sqlite3\_soft\_heap\_limit64](c3ref/hard_heap_limit64.html)(\-1\) C\-language
 function.
 


See also the [hard\_heap\_limit pragma](pragma.html#pragma_hard_heap_limit).

 PRAGMA stats

---


**PRAGMA stats;** 


This pragma returns auxiliary information about tables and
 indices. The returned information is used during testing to help
 verify that the query planner is operating correctly. The format
 and meaning of this pragma will likely change from one release
 to the next. Because of its volatility, the behavior and output
 format of this pragma are deliberately undocumented.



 The intended use of this pragma is only for testing and validation of
 SQLite. This pragma is subject to change without notice and is not
 recommended for use by application programs.



 PRAGMA synchronous

---


**PRAGMA** *schema.***synchronous;
   
PRAGMA** *schema.***synchronous \=** 
*0 \| OFF \| 1 \| NORMAL \| 2 \| FULL \| 3 \| EXTRA***;**


Query or change the setting of the "synchronous" flag.
 The first (query) form will return the synchronous setting as an 
 integer. The second form changes the synchronous setting.
 The meanings of the various synchronous settings are as follows:



**EXTRA** (3\)

 EXTRA synchronous is like FULL with the addition that the directory
 containing a [rollback journal](lockingv3.html#rollback) is synced after that journal is unlinked
 to commit a transaction in DELETE mode. EXTRA provides additional
 durability if the commit is followed closely by a power loss.
**FULL** (2\)

 When synchronous is FULL (2\), the SQLite database engine will
 use the xSync method of the [VFS](vfs.html) to ensure that all content is safely
 written to the disk surface prior to continuing.
 This ensures that an operating system crash or power failure will
 not corrupt the database.
 FULL synchronous is very safe, but it is also slower. FULL is the
 most commonly used synchronous setting when not in [WAL mode](wal.html).
**NORMAL** (1\)

 When synchronous is NORMAL (1\), the SQLite database
 engine will still sync at the most critical moments, but less often
 than in FULL mode. There is a very small (though non\-zero) chance that
 a power failure at just the wrong time could corrupt the database in
 [journal\_mode](pragma.html#pragma_journal_mode)\=DELETE on an older filesystem.
 [WAL mode](wal.html) is safe from corruption with synchronous\=NORMAL, and probably
 DELETE mode is safe too on modern filesystems. WAL mode is always consistent
 with synchronous\=NORMAL, but WAL mode does lose durability. A transaction
 committed in WAL mode with synchronous\=NORMAL might roll back following
 a power loss or system crash. Transactions are durable across application
 crashes regardless of the synchronous setting or journal mode.
 The synchronous\=NORMAL setting is a good choice for most applications
 running in [WAL mode](wal.html).
**OFF** (0\)

 With synchronous OFF (0\), SQLite continues without syncing
 as soon as it has handed data off to the operating system.
 If the application running SQLite crashes, the data will be safe, but
 the database [might become corrupted](howtocorrupt.html#cfgerr) if the operating system
 crashes or the computer loses power before that data has been written
 to the disk surface. On the other hand, commits can be orders of
 magnitude faster with synchronous OFF.
 



In [WAL](wal.html) mode when synchronous is NORMAL (1\), the WAL file is
 synchronized before each [checkpoint](wal.html#ckpt) and the database file is
 synchronized after each completed [checkpoint](wal.html#ckpt) and the WAL file
 header is synchronized when a WAL file begins to be reused after
 a checkpoint, but no sync operations occur during most transactions.
 With synchronous\=FULL in WAL mode, an additional
 sync operation of the WAL file happens after each transaction commit.
 The extra WAL sync following each transaction helps ensure that 
 transactions are durable across a power loss. Transactions are
 consistent with or without the extra syncs provided by
 synchronous\=FULL.
 If durability is not a concern, then synchronous\=NORMAL is normally
 all one needs in WAL mode.


The TEMP schema always has synchronous\=OFF since the content of
 of TEMP is ephemeral and is not expected to survive a power outage.
 Attempts to change the synchronous setting for TEMP are
 silently ignored.

 See also the [fullfsync](pragma.html#pragma_fullfsync) and [checkpoint\_fullfsync](pragma.html#pragma_checkpoint_fullfsync) pragmas.



 PRAGMA table\_info

---


**PRAGMA** *schema.***table\_info(***table\-name***);**


This pragma returns one row for each normal column
 in the named table.
 Columns in the result set include: "name" (its name); "type"
 (data type if given, else ''); "notnull" (whether or not the column
 can be NULL); "dflt\_value" (the default value for the column);
 and "pk" (either zero for columns that are not part of the primary key,
 or the 1\-based index of the column within the primary key).


The "cid" column should not be taken to mean more than
 "rank within the current result set".


The table named in the table\_info pragma can also be a view.


This pragma does not show information about [generated columns](gencol.html) or
 [hidden columns](vtab.html#hiddencol). Use [PRAGMA table\_xinfo](pragma.html#pragma_table_xinfo) to get a more complete list
 of columns that includes generated and hidden columns.

 PRAGMA table\_list

---


 **PRAGMA table\_list;
   
PRAGMA** *schema.***table\_list;
   
PRAGMA table\_list(***table\-name***);**


This pragma returns information about the tables and views in the schema,
 one table per row of output. The table\_list pragma first appeared
 in SQLite version 3\.37\.0 (2021\-11\-27\). As of its initial release
 the columns returned by the table\_list pragma include those listed below.
 Future versions of SQLite will probably add additional columns of
 output.
 
1. **schema**: the schema in which the table or view appears
 (for example "main" or "temp").
 - **name**: the name of the table or view.
 - **type**: the type of object \- one of "table", "view",
 "shadow" (for [shadow tables](vtab.html#xshadowname)), or "virtual" for
 [virtual tables](vtab.html).
 - **ncol**: the number of columns in the table, including
 [generated columns](gencol.html) and [hidden columns](vtab.html#hiddencol).
 - **wr**: 1 if the table is a [WITHOUT ROWID](withoutrowid.html) table or 0 if is not.
 - **strict**: 1 if the table is a [STRICT table](stricttables.html) or 0 if it is not.
 - *Additional columns will likely be added in future releases.*



 The default behavior is to show all tables in all schemas. If the
 *schema.* name appears before the pragma, then only tables in that
 one schema are shown. If a *table\-name* argument is supplied, then
 only information about that one table is returned.

 PRAGMA table\_xinfo

---


**PRAGMA** *schema.***table\_xinfo(***table\-name***);**


This pragma returns one row for each column in the named table,
 including [generated columns](gencol.html) and [hidden columns](vtab.html#hiddencol).
 The output has the same columns as for [PRAGMA table\_info](pragma.html#pragma_table_info) plus
 a column, "hidden", whose value signifies a normal column (0\),
 a dynamic or stored generated column (2 or 3\),
 or a hidden column in a virtual table (1\). The rows for which
 this field is non\-zero are those omitted for [PRAGMA table\_info](pragma.html#pragma_table_info).

 PRAGMA temp\_store

---


**PRAGMA temp\_store;
   
PRAGMA temp\_store \=** 
*0 \| DEFAULT \| 1 \| FILE \| 2 \| MEMORY***;**


Query or change the setting of the "**temp\_store**" parameter.
 When temp\_store is DEFAULT (0\), the compile\-time C preprocessor macro
 [SQLITE\_TEMP\_STORE](compile.html#temp_store) is used to determine where temporary tables and indices
 are stored. When
 temp\_store is MEMORY (2\) [temporary tables](inmemorydb.html#temp_db) and indices are kept
 as if they were in pure [in\-memory databases](inmemorydb.html).
 When temp\_store is FILE (1\) [temporary tables](inmemorydb.html#temp_db) and indices are stored
 in a file. The [temp\_store\_directory](pragma.html#pragma_temp_store_directory) pragma can be used to specify
 the directory containing temporary files when
 **FILE** is specified. When the temp\_store setting is changed,
 all existing temporary tables, indices, triggers, and views are
 immediately deleted.


It is possible for the library compile\-time C preprocessor symbol
 [SQLITE\_TEMP\_STORE](compile.html#temp_store) to override this pragma setting.
 The following table summarizes
 the interaction of the [SQLITE\_TEMP\_STORE](compile.html#temp_store) preprocessor macro and the
 temp\_store pragma:



> | [SQLITE\_TEMP\_STORE](compile.html#temp_store) | PRAGMAtemp\_store | Storage used forTEMP tables and indices |
> | --- | --- | --- |
> | 0 | *any* | file |
> | 1 | 0 | file |
> | 1 | 1 | file |
> | 1 | 2 | memory |
> | 2 | 0 | memory |
> | 2 | 1 | file |
> | 2 | 2 | memory |
> | 3 | *any* | memory |



 PRAGMA temp\_store\_directory

---


**PRAGMA temp\_store\_directory;
   
PRAGMA temp\_store\_directory \= '***directory\-name***';**


Query or change the value of the [sqlite3\_temp\_directory](c3ref/temp_directory.html) global
 variable, which many operating\-system interface backends use to
 determine where to store [temporary tables](inmemorydb.html#temp_db) and indices.


When the temp\_store\_directory setting is changed, all existing temporary
 tables, indices, triggers, and viewers in the database connection that
 issued the pragma are immediately deleted. In
 practice, temp\_store\_directory should be set immediately after the first
 database connection for a process is opened. If the temp\_store\_directory
 is changed for one database connection while other database connections
 are open in the same process, then the behavior is undefined and
 probably undesirable.


Changing the temp\_store\_directory setting is not threadsafe.
 Never change the temp\_store\_directory setting if another thread
 within the application is running any SQLite interface at the same time.
 Doing so results in undefined behavior. Changing the temp\_store\_directory
 setting writes to the [sqlite3\_temp\_directory](c3ref/temp_directory.html) global
 variable and that global variable is not protected by a mutex.


The value *directory\-name* should be enclosed in single quotes.
 To revert the directory to the default, set the *directory\-name* to
 an empty string, e.g., *PRAGMA temp\_store\_directory \= ''*. An
 error is raised if *directory\-name* is not found or is not
 writable. 


The default directory for temporary files depends on the OS. Some
 OS interfaces may choose to ignore this variable and place temporary
 files in some other directory different from the directory specified
 here. In that sense, this pragma is only advisory.



**This pragma is deprecated** and exists
 for backwards compatibility only. New applications
 should avoid using this pragma. Older applications should discontinue
 use of this pragma at the earliest opportunity. This pragma may be omitted
 from the build when SQLite is compiled using [SQLITE\_OMIT\_DEPRECATED](compile.html#omit_deprecated).
 



 PRAGMA threads

---


**PRAGMA threads;
   
PRAGMA threads \=** *N***;**


Query or change the value of the 
 [sqlite3\_limit](c3ref/limit.html)(db,[SQLITE\_LIMIT\_WORKER\_THREADS](c3ref/c_limit_attached.html#sqlitelimitworkerthreads),...) limit for
 the current database connection. This limit sets an upper bound
 on the number of auxiliary threads that a [prepared statement](c3ref/stmt.html) is
 allowed to launch to assist with a query. The default limit is 0
 unless it is changed using the [SQLITE\_DEFAULT\_WORKER\_THREADS](compile.html#default_worker_threads)
 compile\-time option. When the limit is zero, that means no
 auxiliary threads will be launched.


This pragma is a thin wrapper around the
 [sqlite3\_limit](c3ref/limit.html)(db,[SQLITE\_LIMIT\_WORKER\_THREADS](c3ref/c_limit_attached.html#sqlitelimitworkerthreads),...) interface.
 



 PRAGMA trusted\_schema

---


**PRAGMA trusted\_schema;
   
PRAGMA trusted\_schema \=** *boolean***;**


The trusted\_schema setting is a per\-connection boolean that
 determines whether or not SQL functions and virtual tables that
 have not been security audited are allowed to be run by views,
 triggers, or in expressions of the schema such as [CHECK constraints](lang_createtable.html#ckconst),
 [DEFAULT clauses](lang_createtable.html#dfltval), [generated columns](gencol.html), [expression indexes](expridx.html), and/or
 [partial indexes](partialindex.html). This setting can also be controlled using
 the [sqlite3\_db\_config](c3ref/db_config.html)(db,[SQLITE\_DBCONFIG\_TRUSTED\_SCHEMA](c3ref/c_dbconfig_defensive.html#sqlitedbconfigtrustedschema),...)
 C\-language interface.
 In order to maintain backwards compatibility, this setting is
 ON by default. There are advantages to turning it off, and most
 applications will be unaffected if it is turned off. For that reason,
 all applications are encouraged to switch this setting off on every
 database connection as soon as that connection is opened.
 The [\-DSQLITE\_TRUSTED\_SCHEMA\=0](compile.html#trusted_schema) compile\-time option will cause
 this setting to default to OFF.

 PRAGMA user\_version

---


**PRAGMA** *schema.***user\_version;
   
PRAGMA** *schema.***user\_version \=** *integer* **;**
 The user\_version pragma will get or set
 the value of the user\-version integer at offset 60 in the
 [database header](fileformat2.html#database_header). The user\-version is an integer that is
 available to applications to use however they want. SQLite
 makes no use of the user\-version itself.

 See also the [application\_id pragma](pragma.html#pragma_application_id) and [schema\_version pragma](pragma.html#pragma_schema_version).

 PRAGMA vdbe\_addoptrace

---


**PRAGMA vdbe\_addoptrace \=** *boolean***;**


If SQLite has been compiled with the [SQLITE\_DEBUG](compile.html#debug) compile\-time
 option, then the vdbe\_addoptrace pragma can be used to cause a complete
 VDBE opcodes to be displayed as they are created during code generation.
 This feature is used for debugging SQLite itself. See the 
 [VDBE documentation](vdbe.html#trace) for more 
 information.



 This pragma is intended for use when debugging SQLite itself. It
 is only available when the [SQLITE\_DEBUG](compile.html#debug) compile\-time option
 is used.



 PRAGMA vdbe\_debug

---


**PRAGMA vdbe\_debug \=** *boolean***;**


If SQLite has been compiled with the [SQLITE\_DEBUG](compile.html#debug) compile\-time
 option, then the vdbe\_debug pragma is a shorthand for three other
 debug\-only pragmas: vdbe\_addoptrace, vdbe\_listing, and vdbe\_trace.
 This feature is used for debugging SQLite itself. See the 
 [VDBE documentation](vdbe.html#trace) for more 
 information.



 This pragma is intended for use when debugging SQLite itself. It
 is only available when the [SQLITE\_DEBUG](compile.html#debug) compile\-time option
 is used.



 PRAGMA vdbe\_listing

---


**PRAGMA vdbe\_listing \=** *boolean***;**


If SQLite has been compiled with the [SQLITE\_DEBUG](compile.html#debug) compile\-time
 option, then the vdbe\_listing pragma can be used to cause a complete
 listing of the virtual machine opcodes to appear on standard output
 as each statement is evaluated.
 With listing is on, the entire content of a program is printed
 just prior to beginning execution. The statement
 executes normally after the listing is printed.
 This feature is used for debugging SQLite itself. See the 
 [VDBE documentation](vdbe.html#trace) for more 
 information.



 This pragma is intended for use when debugging SQLite itself. It
 is only available when the [SQLITE\_DEBUG](compile.html#debug) compile\-time option
 is used.



 PRAGMA vdbe\_trace

---


**PRAGMA vdbe\_trace \=** *boolean***;**


If SQLite has been compiled with the [SQLITE\_DEBUG](compile.html#debug) compile\-time
 option, then the vdbe\_trace pragma can be used to cause virtual machine
 opcodes to be printed on standard output as they are evaluated.
 This feature is used for debugging SQLite. See the 
 [VDBE documentation](vdbe.html#trace) for more 
 information.



 This pragma is intended for use when debugging SQLite itself. It
 is only available when the [SQLITE\_DEBUG](compile.html#debug) compile\-time option
 is used.



 PRAGMA wal\_autocheckpoint

---


**PRAGMA wal\_autocheckpoint;  

 PRAGMA wal\_autocheckpoint\=***N***;**


This pragma queries or sets the [write\-ahead log](wal.html)
[auto\-checkpoint](wal.html#ckpt) interval.
 When the [write\-ahead log](wal.html) is enabled (via the
 [journal\_mode pragma](pragma.html#pragma_journal_mode)) a checkpoint will be run automatically whenever
 the write\-ahead log equals or exceeds *N* pages in length.
 Setting the auto\-checkpoint size to zero or a negative value
 turns auto\-checkpointing off.


This pragma is a wrapper around the
 [sqlite3\_wal\_autocheckpoint()](c3ref/wal_autocheckpoint.html) C interface.
 All automatic checkpoints are [PASSIVE](c3ref/wal_checkpoint_v2.html).


Autocheckpointing is enabled by default with an interval
 of 1000 or [SQLITE\_DEFAULT\_WAL\_AUTOCHECKPOINT](compile.html#default_wal_autocheckpoint).



 PRAGMA wal\_checkpoint

---


**PRAGMA** *schema.***wal\_checkpoint;**  

**PRAGMA** *schema.***wal\_checkpoint(PASSIVE);**  

**PRAGMA** *schema.***wal\_checkpoint(FULL);**  

**PRAGMA** *schema.***wal\_checkpoint(RESTART);**  

**PRAGMA** *schema.***wal\_checkpoint(TRUNCATE);**



If the [write\-ahead log](wal.html) is enabled (via the [journal\_mode pragma](pragma.html#pragma_journal_mode)),
 this pragma causes a [checkpoint](wal.html#ckpt) operation to run on database
 *database*, or on all attached databases if *database*
 is omitted. If [write\-ahead log](wal.html) mode is disabled, this pragma is a
 harmless no\-op.


Invoking this
 pragma without an argument is equivalent to calling the
 [sqlite3\_wal\_checkpoint()](c3ref/wal_checkpoint.html) C interface.


 Invoking this pragma with an argument is equivalent to calling the
 [sqlite3\_wal\_checkpoint\_v2()](c3ref/wal_checkpoint_v2.html) C interface with a 
 [3rd parameter](c3ref/c_checkpoint_full.html)
 corresponding to the argument:

 
PASSIVE
 Checkpoint as many frames as possible without waiting for any database 
 readers or writers to finish. Sync the db file if all frames in the log
 are checkpointed. This mode is the same as calling the
 [sqlite3\_wal\_checkpoint()](c3ref/wal_checkpoint.html) C interface. The
 [busy\-handler callback](c3ref/busy_handler.html) is never invoked in
 this mode.
 
 FULL
 This mode blocks 
 (invokes the [busy\-handler callback](c3ref/busy_handler.html))
 until there is no
 database writer and all readers are reading from the most recent database
 snapshot. It then checkpoints all frames in the log file and syncs the
 database file. FULL blocks concurrent writers while it is
 running, but readers can proceed.
 
 RESTART
 This mode works the same way as FULL with the addition that after 
 checkpointing the log file it blocks (calls the 
 [busy\-handler callback](c3ref/busy_handler.html))
 until all readers are finished with the log file. This ensures 
 that the next client to write to the database file restarts the log file 
 from the beginning. RESTART blocks concurrent writers while it is
 running, but allowed readers to proceed.
 
 TRUNCATE
 This mode works the same way as RESTART with the 
 addition that the WAL file is truncated to zero bytes upon successful
 completion.
 
The wal\_checkpoint pragma returns a single row with three
 integer columns. The first column is usually 0 but will be
 1 if a RESTART or FULL or TRUNCATE checkpoint was blocked from completing,
 for example because another thread or process was actively
 using the database. In other words, the first column is 0 if the
 equivalent call to [sqlite3\_wal\_checkpoint\_v2()](c3ref/wal_checkpoint_v2.html) would have returned
 [SQLITE\_OK](rescode.html#ok) or 1 if the equivalent call would have returned [SQLITE\_BUSY](rescode.html#busy).
 The second column is the number of modified pages that have been
 written to the write\-ahead log file.
 The third column is the number of pages in the write\-ahead log file
 that have been successfully moved back into the database file at
 the conclusion of the checkpoint.
 The second and third column are \-1 if there is no
 write\-ahead log, for example if this pragma is invoked on a database
 connection that is not in [WAL mode](wal.html).



 PRAGMA writable\_schema

---


**PRAGMA writable\_schema \=** *boolean***;**  

**PRAGMA writable\_schema \= RESET**


When this pragma is on, and the [SQLITE\_DBCONFIG\_DEFENSIVE](c3ref/c_dbconfig_defensive.html#sqlitedbconfigdefensive) flag
 is off, then the [sqlite\_schema](schematab.html) table
 can be changed using ordinary [UPDATE](lang_update.html), [INSERT](lang_insert.html), and [DELETE](lang_delete.html)
 statements. If the argument is "RESET" then schema writing is
 disabled (as with "PRAGMA writable\_schema\=OFF") and, in addition, the
 schema is reloaded. **Warning:**
 misuse of this pragma can easily result in
 a [corrupt database file](howtocorrupt.html#cfgerr).


---


*This page last modified on [2024\-04\-16 16:29:07](https://sqlite.org/docsrc/honeypot) UTC* 




















































































































































































