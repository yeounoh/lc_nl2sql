## 4\.1\. Accessing STRICT tables in earlier versions of SQLite


Because of a quirk in the SQL language parser, versions of SQLite prior
to 3\.37\.0 can still read and write STRICT tables if they set
"[PRAGMA writable\_schema\=ON](pragma.html#pragma_writable_schema)" immediately after opening the database
file, prior to doing anything else that requires knowing the schema.
One of the features of PRAGMA writable\_schema\=ON is that it disables
errors in the schema parser. This is intentional, because a big reason for
having PRAGMA writable\_schema\=ON is to facilitate recovery of database files
with corrupt schemas. So with writable\_schema\=ON, when the schema
parser reaches the STRICT keyword, it says to itself "I don't know what
to do with this, but everything up to this point seems like a valid
table definition so I'll just use what I have." Hence, the STRICT
keyword is effectively ignored. Because nothing else about the file
format changes for STRICT tables, everything else will work normally.
Of course, rigid type enforcement will not occur because the earlier
versions of SQLite do not know how to do that.



The [.dump](cli.html#dump) command in the [CLI](cli.html) sets [PRAGMA writable\_schema\=ON](pragma.html#pragma_writable_schema), because
.dump is designed to extract as much content as it can even from a corrupt
database file. Hence, if you are using an older version of SQLite and
you open a database with STRICT tables in the CLI and issue the ".dump"
command before doing anything else, you will be able to read and write
to the STRICT tables without rigid type enforcement. This could, potentially,
corrupt the database, by allowing incorrect types into STRICT tables.
Reopening the database with a newer version of SQLite and running
"[PRAGMA quick\_check](pragma.html#pragma_quick_check)" will detect and report all such corruption.



