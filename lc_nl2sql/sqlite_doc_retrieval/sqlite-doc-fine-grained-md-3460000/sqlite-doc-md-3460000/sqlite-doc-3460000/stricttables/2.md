# 2\. STRICT Tables


In a [CREATE TABLE](lang_createtable.html) statement, if the "STRICT" table\-option keyword is
added to the end, after the closing ")", then strict typing rules apply
to that table. 
The STRICT keyword causes the following differences:



1. Every column definition must specify a datatype for that column.
The freedom to specify a column without a datatype is removed.
2. The datatype must be one of following:



	* INT
	* INTEGER
	* REAL
	* TEXT
	* BLOB
	* ANYNo other datatype names are allowed, though new types might be added in
future releases of SQLite.
3. Content inserted into the column with a datatype other than ANY
must be either a NULL (assuming there
is no NOT NULL constraint on the column) or the type specified.
SQLite attempts to coerce the data into the appropriate type using the usual
affinity rules, as PostgreSQL, MySQL, SQL Server,
and Oracle all do. If the value cannot be
losslessly converted in the specified datatype, then an
SQLITE\_CONSTRAINT\_DATATYPE error is raised.
4. Columns with datatype ANY can accept any kind of data (except they will
reject NULL values if they have a NOT NULL constraint, of course). No
type coercion occurs for a column of type ANY in a STRICT table.
5. Columns that are part of the PRIMARY KEY are implicitly NOT NULL.
However, even though the PRIMARY KEY has an implicit NOT NULL constraint,
when a NULL value is inserted into an [INTEGER PRIMARY KEY](lang_createtable.html#rowid) column, the
NULL is automatically converted into a unique integer, using the same
rules for [INTEGER PRIMARY KEY](lang_createtable.html#rowid) on ordinary, non\-strict tables.
6. The [PRAGMA integrity\_check](pragma.html#pragma_integrity_check) and [PRAGMA quick\_check](pragma.html#pragma_quick_check) commands check the
type of the content of all columns in STRICT tables and show errors if
anything is amiss.



Everything else about a STRICT table works the same as it does in an
ordinary non\-strict table:



* [CHECK constraints](lang_createtable.html#ckconst) work the same.
* [NOT NULL constraints](lang_createtable.html#notnullconst) work the same.
* [FOREIGN KEY constraints](foreignkeys.html) work the same.
* [UNIQUE constraints](lang_createtable.html#uniqueconst) work the same.
* [DEFAULT clauses](lang_createtable.html#dfltval) work the same.
* [COLLATE clauses](lang_createtable.html#collateclause) work the same.
* [Generated columns](gencol.html) work the same.
* [ON CONFLICT clauses](lang_conflict.html) work the same.
* [Indexes](lang_createindex.html) work the same.
* [AUTOINCREMENT](autoinc.html) works the same.
* An [INTEGER PRIMARY KEY](lang_createtable.html#rowid) column is an alias for the [rowid](lang_createtable.html#rowid), but an
INT PRIMARY KEY column is not.
* The [on\-disk format](fileformat2.html) for the [table data](fileformat2.html##sqltab) is the same.


