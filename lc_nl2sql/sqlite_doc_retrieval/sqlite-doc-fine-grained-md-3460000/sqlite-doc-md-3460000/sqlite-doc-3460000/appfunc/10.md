# 3\. Security Implications



Application\-defined SQL functions can become security vulnerabilities if
not carefully managed. Suppose, for example, an application defines
a new "system(X)" SQL function that runs its argument X as a command and
returns the integer result code. Perhaps the implementation is like this:




```
static void systemFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const char *zCmd = (const char*)sqlite3_value_text(argv[0]);
  if( zCmd!=0 ){
    int rc = system(zCmd);
    sqlite3_result_int(context, rc);
  }
}

```


This is a function with powerful side\-effects. Most programmers would
be naturally cautious about using it, but probably would not see the
harm in merely having it available. But there is great risk in merely
defining such a function, even if the application itself never invokes
it!




Suppose the application normally does a query against table TAB1
when it starts up. If an attacker can gain access to the database
file and modify the schema like this:




```
ALTER TABLE tab1 RENAME TO tab1_real;
CREATE VIEW tab1 AS SELECT * FROM tab1 WHERE system('rm -rf *') IS NOT NULL;

```


Then, when the application attempts to open the database, register the
system() function, then run an innocent query against the "tab1" table,
it instead deletes all the files in its working directory. Yikes!




To prevent this kind of mischief, applications that create their own
custom SQL functions should take one or more of the following safety
precautions. The more precautions taken the better:



1. Invoke [sqlite3\_db\_config](c3ref/db_config.html)(db,[SQLITE\_DBCONFIG\_TRUSTED\_SCHEMA](c3ref/c_dbconfig_defensive.html#sqlitedbconfigtrustedschema),0,0\)
on each [database connection](c3ref/sqlite3.html) as soon as it is opened.
This prevents application\-defined functions from being used in places
where an attacker might be able to surreptiously invoke them by modifying
a database schema:



	* In VIEWs.
	* In TRIGGERs.
	* In CHECK constraints of a table definition.
	* In DEFAULT constraints of a table definition.
	* In the definitions of generated columns.
	* In the expression part of an index on an expression.
	* In the WHERE clause of a partial index.
To put it another way, this setting requires that application\-defined
functions only be run directly by top\-level SQL invoked from the application
itself, not as a consequence of doing some other innocent\-looking query.
2. Use the [PRAGMA trusted\_schema\=OFF](pragma.html#pragma_trusted_schema) SQL statement to disable trusted
schema. This has the same effect as the previous bullet, but does not
require the use of C\-code and hence can be performed in programs written
in another programming language and that do not have access SQLite
C\-language APIs.
3. Compile SQLite using the [\-DSQLITE\_TRUSTED\_SCHEMA\=0](compile.html#trusted_schema) compile\-time option.
This make SQLite distrust application\-defined functions inside of
the schema by default.
4. If any application\-defined SQL functions have potentially dangerous
side\-effects, or if they could potentially leak sensitive information
to an attacker if misused, then tag those functions using the
[SQLITE\_DIRECTONLY](c3ref/c_deterministic.html#sqlitedirectonly) option on the "enc" parameter. This means
that the function can never be run from schema\-code even if the
trusted\-schema option is on.
5. Never tag an application\-defined SQL function with [SQLITE\_INNOCUOUS](c3ref/c_deterministic.html#sqliteinnocuous)
unless you really need to and you have checked the implementation closely
and are certain that it can do no harm even if it falls under the
control of an attacker.


*This page last modified on [2024\-04\-16 17:22:18](https://sqlite.org/docsrc/honeypot) UTC* 


