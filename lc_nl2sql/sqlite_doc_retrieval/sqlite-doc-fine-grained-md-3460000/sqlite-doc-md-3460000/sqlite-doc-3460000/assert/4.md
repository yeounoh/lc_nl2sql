# 2\. Examples


An assert() statement is often used to validate pre\-conditions on 
internal functions and methods.
Example: [https://sqlite.org/src/artifact/c1e97e4c6f?ln\=1048](https://sqlite.org/src/artifact/c1e97e4c6f?ln=1048).
This is deemed better than simply stating the pre\-condition in a header 
comment, since the assert() is actually executed. In a highly tested
program like SQLite, the reader knows that the pre\-condition is true
for all of the hundreds of millions of test cases run against SQLite,
since it has been verified by the assert().
In contrast, a text pre\-condition statement in a header comment
is untested. It might have been true when the code was written, 
but who is to say that it is still true now?




Sometimes SQLite uses compile\-time evaluatable assert() statements.
Consider the code at
[https://sqlite.org/src/artifact/c1e97e4c6f?ln\=2130\-2138](https://sqlite.org/src/artifact/c1e97e4c6f?ln=2130-2138).
Four assert() statements verify the values for compile\-time constants
so that the reader can quickly check the validity of the if\-statement
that follows, without having to look up the constant values in a separate
header file.




Sometimes compile\-time assert() statements are used to verify that
SQLite has been correctly compiled. For example, the code at
[https://sqlite.org/src/artifact/c1e97e4c6f?ln\=157](https://sqlite.org/src/artifact/c1e97e4c6f?ln=157)
verifies that the SQLITE\_PTRSIZE preprocessor macro is set correctly
for the target architecture.




The CORRUPT\_DB macro is used in many assert() statements.
In functional testing builds, CORRUPT\_DB references a global variable
that is true if the database file might contain corruption. This variable
is true by default, since we do not normally know whether or not a database
is corrupt, but during testing while working on databases that are known
to be well\-formed, that global variable can be set to false.
Then the CORRUPT\_DB macro
can be used in assert() statements such as seen at
[https://sqlite.org/src/artifact/18a53540aa3?ln\=1679\-1680](https://sqlite.org/src/artifact/18a53540aa3?ln=1679-1680).
Those assert()s specify pre\-conditions to the routine that are true for
consistent database files, but which might be false if the database file
is corrupt. Knowledge of these kinds of conditions is very helpful to
readers who are trying to understand a block of code in isolation.




ALWAYS(X) and NEVER(X) functions are used in places where we always
want the test to occur even though the developers believe the value of
X is always true or false. For example, the sqlite3BtreeCloseCursor()
routine shown must remove the closing cursor from a linked list of all
cursors. We know that the cursor is on the list, so that the loop
must terminate by the "break" statement, but it is convenient to
use the ALWAYS(X) test at
[https://sqlite.org/src/artifact/18a53540aa3?ln\=4371](https://sqlite.org/src/artifact/18a53540aa3?ln=4371) to prevent
running off the end of the linked list in case there is an error in some
other part of the code that has corrupted the linked list.




An ALWAYS(X) or NEVER(X) sometimes verifies pre\-conditions that are
subject to change if other parts of the code are modified in
subtle ways. At [https://sqlite.org/src/artifact/18a53540aa3?ln\=5512\-5516](https://sqlite.org/src/artifact/18a53540aa3?ln=5512-5516)
we have a test for two pre\-conditions that are true only because
of the limited scope of use of the sqlite3BtreeRowCountEst() function.
Future enhancements to SQLite might use sqlite3BtreeRowCountEst() in
new ways where those preconditions no longer hold, and the NEVER()
macros will quickly alert the developers to that fact when the
situation arises. But if, for some reason, the pre\-conditions are
not satisfied in a release build, the program will still behave sanely
and will not do an undefined memory access.




The testcase() macro is often used to verify that boundary
cases of an inequality comparison are checked. For example, at
[https://sqlite.org/src/artifact/18a53540aa3?ln\=5766](https://sqlite.org/src/artifact/18a53540aa3?ln=5766). These
kind of checks help to prevent off\-by\-one errors.


*This page last modified on [2022\-01\-08 05:02:57](https://sqlite.org/docsrc/honeypot) UTC* 


