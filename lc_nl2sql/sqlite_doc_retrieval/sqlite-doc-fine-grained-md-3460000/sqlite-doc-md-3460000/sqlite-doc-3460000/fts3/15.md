## 4\.3\. The Matchinfo Function



 The matchinfo function returns a blob value. If it is used within a query
 that does not use the full\-text index (a "query by rowid" or "linear scan"),
 then the blob is zero bytes in size. Otherwise, the blob consists of zero
 or more 32\-bit unsigned integers in machine byte\-order. The exact number
 of integers in the returned array depends on both the query and the value
 of the second argument (if any) passed to the matchinfo function.




 The matchinfo function is called with either one or two arguments. As for
 all auxiliary functions, the first argument must be the special
 [FTS hidden column](fts3.html#hiddencol). The second argument, if it is specified, must be a text value
 comprised only of the characters 'p', 'c', 'n', 'a', 'l', 's', 'x', 'y' and 'b'.
 If no second argument is explicitly supplied, it defaults to "pcx". The
 second argument is referred to as the "format string" below.




 Characters in the matchinfo format string are processed from left to right.
 Each character in the format string causes one or more 32\-bit unsigned
 integer values to be added to the returned array. The "values" column in
 the following table contains the number of integer values appended to the
 output buffer for each supported format string character. In the formula
 given, *cols* is the number of columns in the FTS table, and
 *phrases* is the number of [matchable phrases](#matchable) in
 the query.





| Character | Values | Description |
| --- | --- | --- |
| p | 1 | The number of matchable phrases in the query. |
| c | 1 | The number of user defined columns in the FTS  table (i.e. not including the docid or the [FTS hidden column](fts3.html#hiddencol)). |
| x | 3 \* *cols* \* *phrases* | For each distinct combination of a phrase and table column, the  following three values:  * In the current row, the number of times the phrase appears in  the column. * The total number of times the phrase appears in the column in  all rows in the FTS table. * The total number of rows in the FTS table for which the  column contains at least one instance of the phrase.    The first set of three values corresponds to the left\-most column  of the table (column 0\) and the left\-most matchable phrase in the  query (phrase 0\). If the table has more than one column, the second  set of three values in the output array correspond to phrase 0 and  column 1\. Followed by phrase 0, column 2 and so on for all columns of  the table. And so on for phrase 1, column 0, then phrase 1, column 1  etc. In other words, the data for occurrences of phrase *p* in  column *c* may be found using the following formula:  ```            hits_this_row  = array[3 * (c + p*cols) + 0]           hits_all_rows  = array[3 * (c + p*cols) + 1]           docs_with_hits = array[3 * (c + p*cols) + 2]  ``` |
| y | *cols* \* *phrases* | For each distinct combination of a phrase and table column, the  number of usable phrase matches that appear in the column. This is  usually identical to the first value in each set of three returned by the  [matchinfo 'x' flag](fts3.html#matchinfo-x). However, the number of hits reported by the  'y' flag is zero for any phrase that is part of a sub\-expression  that does not match the current row. This makes a difference for  expressions that contain AND operators that are descendants of OR  operators. For example, consider the expression:  ```            a OR (b AND c)  ```   and the document:  ```            "a c d"  ```   The [matchinfo 'x' flag](fts3.html#matchinfo-x) would report a single hit for the phrases "a" and "c".  However, the 'y' directive reports the number of hits for "c" as zero, as  it is part of a sub\-expression that does not match the document \- (b AND c).  For queries that do not contain AND operators descended from OR  operators, the result values returned by 'y' are always the same as  those returned by 'x'.    The first value in the array of integer values corresponds to the  leftmost column of the table (column 0\) and the first phrase in the query  (phrase 0\). The values corresponding to other column/phrase combinations  may be located using the following formula:   ```            hits_for_phrase_p_column_c  = array[c + p*cols]  ```   For queries that use OR expressions, or those that use LIMIT or return  many rows, the 'y' matchinfo option may be faster than 'x'. |
| b | *((cols\+31\)/32\)* \* *phrases* | The matchinfo 'b' flag provides similar information to the  [matchinfo 'y' flag](fts3.html#matchinfo-y), but in a more  compact form. Instead of the precise number of hits, 'b' provides a single  boolean flag for each phrase/column combination. If the phrase is present in  the column at least once (i.e. if the corresponding integer output of 'y' would  be non\-zero), the corresponding flag is set. Otherwise cleared.    If the table has 32 or fewer columns, a single unsigned integer is output for  each phrase in the query. The least significant bit of the integer is set if the  phrase appears at least once in column 0\. The second least significant bit is  set if the phrase appears once or more in column 1\. And so on.    If the table has more than 32 columns, an extra integer is added to the output  of each phrase for each extra 32 columns or part thereof. Integers  corresponding to the same phrase are clumped together. For example, if a table  with 45 columns is queried for two phrases, 4 integers are output. The first  corresponds to phrase 0 and columns 0\-31 of the table. The second integer  contains data for phrase 0 and columns 32\-44, and so on.    For example, if nCol is the number of columns in the table, to determine if  phrase p is present in column c:   ```      p_is_in_c = array[p * ((nCol+31)/32)] & (1 << (c % 32))  ``` |
| n | 1 | The number of rows in the FTS4 table. This value is  only available when querying FTS4 tables, not FTS3\. |
| a | *cols* | For each column, the average number of  tokens in the text values stored in the column (considering all rows in  the FTS4 table). This value is only available when querying FTS4 tables,  not FTS3\. |
| l | *cols* | For each column, the length of the value stored in the current row of the  FTS4 table, in tokens. This value is only available when querying  FTS4 tables, not FTS3\. And only if the "matchinfo\=fts3" directive was not  specified as part of the "CREATE VIRTUAL TABLE" statement used to create  the FTS4 table. |
| s | *cols* | For each column, the length of the longest  subsequence of phrase matches that the column value has in common  with the query text. For example, if a table column contains the text  'a b c d e' and the query is 'a c "d e"', then the length of the longest  common subsequence is 2 (phrase "c" followed by phrase "d e"). |



 For example:




```
-- Create and populate an FTS4 table with two columns:
CREATE VIRTUAL TABLE t1 USING fts4(a, b);
INSERT INTO t1 VALUES('transaction default models default', 'Non transaction reads');
INSERT INTO t1 VALUES('the default transaction', 'these semantics present');
INSERT INTO t1 VALUES('single request', 'default data');

-- In the following query, no format string is specified and so it defaults
-- to "pcx". It therefore returns a single row consisting of a single blob
-- value 80 bytes in size (20 32-bit integers - 1 for "p", 1 for "c" and
-- 3*2*3 for "x"). If each block of 4 bytes in the blob is interpreted
-- as an unsigned integer in machine byte-order, the values will be:
--
--     3 2  1 3 2  0 1 1  1 2 2  0 1 1  0 0 0  1 1 1
--
-- The row returned corresponds to the second entry inserted into table t1.
-- The first two integers in the blob show that the query contained three
-- phrases and the table being queried has two columns. The next block of
-- three integers describes column 0 (in this case column "a") and phrase
-- 0 (in this case "default"). The current row contains 1 hit for "default"
-- in column 0, of a total of 3 hits for "default" that occur in column
-- 0 of any table row. The 3 hits are spread across 2 different rows.
--
-- The next set of three integers (0 1 1) pertain to the hits for "default"
-- in column 1 of the table (0 in this row, 1 in all rows, spread across 
-- 1 rows).
--
SELECT matchinfo(t1) FROM t1 WHERE t1 MATCH 'default transaction "these semantics"';

-- The format string for this query is "ns". The output array will therefore
-- contain 3 integer values - 1 for "n" and 2 for "s". The query returns
-- two rows (the first two rows in the table match). The values returned are:
--
--     3  1 1
--     3  2 0
--
-- The first value in the matchinfo array returned for both rows is 3 (the 
-- number of rows in the table). The following two values are the lengths 
-- of the longest common subsequence of phrase matches in each column.
SELECT matchinfo(t1, 'ns') FROM t1 WHERE t1 MATCH 'default transaction';

```


 The matchinfo function is much faster than either the snippet or offsets
 functions. This is because the implementation of both snippet and offsets
 is required to retrieve the documents being analyzed from disk, whereas
 all data required by matchinfo is available as part of the same portions
 of the full\-text index that are required to implement the full\-text query
 itself. This means that of the following two queries, the first may be
 an order of magnitude faster than the second:




```
SELECT docid, matchinfo(tbl) FROM tbl WHERE tbl MATCH <query expression>;
SELECT docid, offsets(tbl) FROM tbl WHERE tbl MATCH <query expression>;

```


 The matchinfo function provides all the information required to calculate
 probabilistic "bag\-of\-words" relevancy scores such as
 [Okapi BM25/BM25F](http://en.wikipedia.org/wiki/Okapi_BM25) that may
 be used to order results in a full\-text search application. Appendix A of this
 document, "[search application tips](fts3.html#appendix_a)", contains an example of using the
 matchinfo() function efficiently.




