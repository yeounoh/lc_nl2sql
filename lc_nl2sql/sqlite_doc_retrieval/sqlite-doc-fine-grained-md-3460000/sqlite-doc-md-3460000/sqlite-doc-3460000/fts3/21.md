### 6\.2\.2\.  External Content FTS4 Tables



 An "external content" FTS4 table is similar to a contentless table, except
 that if evaluation of a query requires the value of a column other than
 docid, FTS4 attempts to retrieve that value from a table (or view, or
 virtual table) nominated by the user (hereafter referred to as the "content
 table"). The FTS4 module never writes to the content table, and writing
 to the content table does not affect the full\-text index. It is the
 responsibility of the user to ensure that the content table and the
 full\-text index are consistent.




 An external content FTS4 table is created by setting the content option
 to the name of a table (or view, or virtual table) that may be queried by
 FTS4 to retrieve column values when required. If the nominated table does
 not exist, then an external content table behaves in the same way as
 a contentless table. For example:




```
CREATE TABLE t2(id INTEGER PRIMARY KEY, a, b, c);
CREATE VIRTUAL TABLE t3 USING fts4(content="t2", a, c);

```


 Assuming the nominated table does exist, then its columns must be the same
 as or a superset of those defined for the FTS table. The external table
 must also be in the same database file as the FTS table. In other words,
 The external table cannot be in a different database file connected using
 [ATTACH](lang_attach.html) nor may one of the FTS table and the external content be in the
 TEMP database when the other is in a persistent database file such as MAIN.




 When a users query on the FTS table requires a column value other than
 docid, FTS attempts to read the requested value from the corresponding column of
 the row in the content table with a rowid value equal to the current FTS
 docid. Only the subset of content\-table columns duplicated in the FTS/34
 table declaration can be queried for \- to retrieve values from any other
 columns the content table must be queried directly. Or, if such a row cannot
 be found in the content table, a NULL value is used instead. For example:




```
CREATE TABLE t2(id INTEGER PRIMARY KEY, a, b, c);
CREATE VIRTUAL TABLE t3 USING fts4(content="t2", b, c);

INSERT INTO t2 VALUES(2, 'a b', 'c d', 'e f');
INSERT INTO t2 VALUES(3, 'g h', 'i j', 'k l');
INSERT INTO t3(docid, b, c) SELECT id, b, c FROM t2;
-- The following query returns a single row with two columns containing
-- the text values "i j" and "k l".
--
-- The query uses the full-text index to discover that the MATCH
-- term matches the row with docid=3. It then retrieves the values
-- of columns b and c from the row with rowid=3 in the content table
-- to return.
--
SELECT * FROM t3 WHERE t3 MATCH 'k';

-- Following the UPDATE, the query still returns a single row, this
-- time containing the text values "xxx" and "yyy". This is because the
-- full-text index still indicates that the row with docid=3 matches
-- the FTS4 query 'k', even though the documents stored in the content
-- table have been modified.
--
UPDATE t2 SET b = 'xxx', c = 'yyy' WHERE rowid = 3;
SELECT * FROM t3 WHERE t3 MATCH 'k';

-- Following the DELETE below, the query returns one row containing two
-- NULL values. NULL values are returned because FTS is unable to find
-- a row with rowid=3 within the content table.
--
DELETE FROM t2;
SELECT * FROM t3 WHERE t3 MATCH 'k';

```


 When a row is deleted from an external content FTS4 table, FTS4 needs to
 retrieve the column values of the row being deleted from the content table.
 This is so that FTS4 can update the full\-text index entries for each token
 that occurs within the deleted row to indicate that row has been
 deleted. If the content table row cannot be found, or if it contains values
 inconsistent with the contents of the FTS index, the results can be difficult
 to predict. The FTS index may be left containing entries corresponding to the
 deleted row, which can lead to seemingly nonsensical results being returned
 by subsequent SELECT queries. The same applies when a row is updated, as
 internally an UPDATE is the same as a DELETE followed by an INSERT.




 This means that in order to keep an FTS in sync with an external content
 table, any UPDATE or DELETE operations must be applied first to the FTS
 table, and then to the external content table. For example:




```
CREATE TABLE t1_real(id INTEGER PRIMARY KEY, a, b, c, d);
CREATE VIRTUAL TABLE t1_fts USING fts4(content="t1_real", b, c);

-- This works. When the row is removed from the FTS table, FTS retrieves
-- the row with rowid=123 and tokenizes it in order to determine the entries
-- that must be removed from the full-text index.
--
DELETE FROM t1_fts WHERE rowid = 123;
DELETE FROM t1_real WHERE rowid = 123;

-- This does not work. By the time the FTS table is updated, the row
-- has already been deleted from the underlying content table. As a result
-- FTS is unable to determine the entries to remove from the FTS index and
-- so the index and content table are left out of sync.
--
DELETE FROM t1_real WHERE rowid = 123;
DELETE FROM t1_fts WHERE rowid = 123;

```


 Instead of writing separately to the full\-text index and the content table,
 some users may wish to use database triggers to keep the full\-text index
 up to date with respect to the set of documents stored in the content table.
 For example, using the tables from earlier examples:




```
CREATE TRIGGER t2_bu BEFORE UPDATE ON t2 BEGIN
  DELETE FROM t3 WHERE docid=old.rowid;
END;
CREATE TRIGGER t2_bd BEFORE DELETE ON t2 BEGIN
  DELETE FROM t3 WHERE docid=old.rowid;
END;

CREATE TRIGGER t2_au AFTER UPDATE ON t2 BEGIN
  INSERT INTO t3(docid, b, c) VALUES(new.rowid, new.b, new.c);
END;
CREATE TRIGGER t2_ai AFTER INSERT ON t2 BEGIN
  INSERT INTO t3(docid, b, c) VALUES(new.rowid, new.b, new.c);
END;

```


 The DELETE trigger must be fired before the actual delete takes place
 on the content table. This is so that FTS4 can still retrieve the original
 values in order to update the full\-text index. And the INSERT trigger must
 be fired after the new row is inserted, so as to handle the case where the
 rowid is assigned automatically within the system. The UPDATE trigger must
 be split into two parts, one fired before and one after the update of the
 content table, for the same reasons.




 The [FTS4 "rebuild" command](fts3.html#*fts4rebuidcmd)
 deletes the entire full\-text index and rebuilds it based on the current
 set of documents in the content table. Assuming again that "t3" is the
 name of the external content FTS4 table, the rebuild command looks like this:




```
INSERT INTO t3(t3) VALUES('rebuild');

```


 This command may also be used with ordinary FTS4 tables, for example if
 the implementation of the tokenizer changes. It is an
 error to attempt to rebuild the full\-text index maintained by a contentless
 FTS4 table, since no content will be available to do the rebuilding.






