# 5\. Fts4aux \- Direct Access to the Full\-Text Index



 As of [version 3\.7\.6](releaselog/3_7_6.html) (2011\-04\-12\),
 SQLite includes a new virtual table module called
 "fts4aux", which can be used to inspect the full\-text index of an existing
 FTS table directly. Despite its name, fts4aux works just as well with FTS3
 tables as it does with FTS4 tables. Fts4aux tables are read\-only. The only
 way to modify the contents of an fts4aux table is by modifying the
 contents of the associated FTS table. The fts4aux module is automatically
 included in all [builds that include FTS](fts3.html#compiling_and_enabling_fts3_and_fts4).




 An fts4aux virtual table is constructed with one or two arguments. When
 used with a single argument, that argument is the unqualified name of the
 FTS table that it will be used to access. To access a table in a different
 database (for example, to create a TEMP fts4aux table that will access an
 FTS3 table in the MAIN database) use the two\-argument form and give the
 name of the target database (ex: "main") in the first argument and the name
 of the FTS3/4 table as the second argument. (The two\-argument form of
 fts4aux was added for SQLite [version 3\.7\.17](releaselog/3_7_17.html) (2013\-05\-20\)
 and will throw an error in prior releases.)
 For example:




```
-- Create an FTS4 table
CREATE VIRTUAL TABLE ft USING fts4(x, y);

-- Create an fts4aux table to access the full-text index for table "ft"
CREATE VIRTUAL TABLE ft_terms USING fts4aux(ft);

-- Create a TEMP fts4aux table accessing the "ft" table in "main"
CREATE VIRTUAL TABLE temp.ft_terms_2 USING fts4aux(main,ft);

```


 For each term present in the FTS table, there are between 2 and N\+1 rows
 in the fts4aux table, where N is the number of user\-defined columns in
 the associated FTS table. An fts4aux table always has the same four columns,
 as follows, from left to right:





| Column Name | Column Contents |
| --- | --- |
| term | Contains the text of the term for this row. |
| col | This column may contain either the text value '\*' (i.e. a single  character, U\+002a) or an integer between 0 and N\-1, where N is  again the number of user\-defined columns in the corresponding FTS table. |
| documents | This column always contains an integer value greater than zero.    If the "col" column contains the value '\*', then this column  contains the number of rows of the FTS table that contain at least one  instance of the term (in any column). If col contains an integer  value, then this column contains the number of rows of the FTS table that  contain at least one instance of the term in the column identified by  the col value. As usual, the columns of the FTS table are numbered  from left to right, starting with zero. |
| occurrences | This column also always contains an integer value greater than zero.    If the "col" column contains the value '\*', then this column  contains the total number of instances of the term in all rows of the  FTS table (in any column). Otherwise, if col contains an integer  value, then this column contains the total number of instances of the  term that appear in the FTS table column identified by the col  value. |
| languageid *(hidden)* | This column determines which [languageid](fts3.html#*fts4languageid) is used to  extract vocabulary from the FTS3/4 table.    The default value for languageid is 0\. If an alternative language  is specified in WHERE clause constraints, then that alternative is  used instead of 0\. There can only be a single languageid per query.  In other words, the WHERE clause cannot contain a range constraint  or IN operator on the languageid. |



 For example, using the tables created above:




```
INSERT INTO ft(x, y) VALUES('Apple banana', 'Cherry');
INSERT INTO ft(x, y) VALUES('Banana Date Date', 'cherry');
INSERT INTO ft(x, y) VALUES('Cherry Elderberry', 'Elderberry');

-- The following query returns this data:
--
--     apple       |  *  |  1  |  1
--     apple       |  0  |  1  |  1
--     banana      |  *  |  2  |  2
--     banana      |  0  |  2  |  2
--     cherry      |  *  |  3  |  3
--     cherry      |  0  |  1  |  1
--     cherry      |  1  |  2  |  2
--     date        |  *  |  1  |  2
--     date        |  0  |  1  |  2
--     elderberry  |  *  |  1  |  2
--     elderberry  |  0  |  1  |  1
--     elderberry  |  1  |  1  |  1
--
SELECT term, col, documents, occurrences FROM ft_terms;

```


 In the example, the values in the "term" column are all lower case,
 even though they were inserted into table "ft" in mixed case. This is because
 an fts4aux table contains the terms as extracted from the document text
 by the [tokenizer](fts3.html#tokenizer). In this case, since table "ft" uses the
 [simple tokenizer](fts3.html#tokenizer), this means all terms have been folded to
 lower case. Also, there is (for example) no row with column "term"
 set to "apple" and column "col" set to 1\. Since there are no instances
 of the term "apple" in column 1, no row is present in the fts4aux table.




 During a transaction, some of the data written to an FTS table may be
 cached in memory and written to the database only when the transaction is
 committed. However the implementation of the fts4aux module is only able
 to read data from the database. In practice this means that if an fts4aux
 table is queried from within a transaction in which the associated
 FTS table has been modified, the results of the query are likely to reflect
 only a (possibly empty) subset of the changes made.




