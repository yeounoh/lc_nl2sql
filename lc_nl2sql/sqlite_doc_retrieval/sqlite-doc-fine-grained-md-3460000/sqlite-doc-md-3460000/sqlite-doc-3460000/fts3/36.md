## 9\.1\. Shadow Tables



 For each FTS virtual table in a database, three to five real (non\-virtual) tables
 are created to store the underlying data. These real tables are called "shadow tables".
 The real tables are named "%\_content",
 "%\_segdir", "%\_segments", "%\_stat", and "%\_docsize", where "%" is replaced by the name
 of the FTS virtual table.




 The leftmost column of the "%\_content" table is an INTEGER PRIMARY KEY field
 named "docid". Following this is one column for each column of the FTS
 virtual table as declared by the user, named by prepending the column name
 supplied by the user with "c*N*", where *N* is the index of the
 column within the table, numbered from left to right starting with 0\. Data
 types supplied as part of the virtual table declaration are not used as
 part of the %\_content table declaration. For example:




```
-- Virtual table declaration
CREATE VIRTUAL TABLE abc USING fts4(a NUMBER, b TEXT, c);

-- Corresponding %_content table declaration
CREATE TABLE abc_content(docid INTEGER PRIMARY KEY, c0a, c1b, c2c);

```


 The %\_content table contains the unadulterated data inserted by the user
 into the FTS virtual table by the user. If the user does not explicitly
 supply a "docid" value when inserting records, one is selected automatically
 by the system.




 The %\_stat and %\_docsize tables are only created if the FTS table uses the
 FTS4 module, not FTS3\. Furthermore, the %\_docsize table is omitted if the
 FTS4 table is created with the ["matchinfo\=fts3"](fts3.html#fts4matchinfo) directive
 specified as part of the CREATE VIRTUAL TABLE statement. If they are created,
 the schema of the two tables is as follows:



```
CREATE TABLE %_stat(
  id INTEGER PRIMARY KEY,
  value BLOB
);

CREATE TABLE %_docsize(
  docid INTEGER PRIMARY KEY,
  size BLOB
);

```


 For each row in the FTS table, the %\_docsize table contains a corresponding
 row with the same "docid" value. The "size" field contains a blob consisting
 of *N* FTS varints, where *N* is the number of user\-defined columns
 in the table. Each varint in the "size" blob is the number of tokens in the
 corresponding column of the associated row in the FTS table. The %\_stat table
 always contains a single row with the "id" column set to 0\. The "value"
 column contains a blob consisting of *N\+1* FTS varints, where *N*
 is again the number of user\-defined columns in the FTS table. The first
 varint in the blob is set to the total number of rows in the FTS table. The
 second and subsequent varints contain the total number of tokens stored in
 the corresponding column for all rows of the FTS table.




 The two remaining tables, %\_segments and %\_segdir, are used to store the
 full\-text index. Conceptually, this index is a lookup table that maps each
 term (word) to the set of docid values corresponding to records in the
 %\_content table that contain one or more occurrences of the term. To
 retrieve all documents that contain a specified term, the FTS module
 queries this index to determine the set of docid values for records that
 contain the term, then retrieves the required documents from the %\_content
 table. Regardless of the schema of the FTS virtual table, the %\_segments
 and %\_segdir tables are always created as follows:




```
CREATE TABLE %_segments(
  blockid INTEGER PRIMARY KEY,       -- B-tree node id
  block blob                         -- B-tree node data
);

CREATE TABLE %_segdir(
  level INTEGER,
  idx INTEGER,
  start_block INTEGER,               -- Blockid of first node in %_segments
  leaves_end_block INTEGER,          -- Blockid of last leaf node in %_segments
  end_block INTEGER,                 -- Blockid of last node in %_segments
  root BLOB,                         -- B-tree root node
  PRIMARY KEY(level, idx)
);

```


 The schema depicted above is not designed to store the full\-text index
 directly. Instead, it is used to store one or more b\-tree structures. There
 is one b\-tree for each row in the %\_segdir table. The %\_segdir table
 row contains the root node and various meta\-data associated with the
 b\-tree structure, and the %\_segments table contains all other (non\-root)
 b\-tree nodes. Each b\-tree is referred to as a "segment". Once it has
 been created, a segment b\-tree is never updated (although it may be
 deleted altogether).




 The keys used by each segment b\-tree are terms (words). As well as the
 key, each segment b\-tree entry has an associated "doclist" (document list).
 A doclist consists of zero or more entries, where each entry consists of:



* A docid (document id), and
* A list of term offsets, one for each occurrence of the term within
 the document. A term offset indicates the number of tokens (words)
 that occur before the term in question, not the number of characters
 or bytes. For example, the term offset of the term "war" in the
 phrase "Ancestral voices prophesying war!" is 3\.



 Entries within a doclist are sorted by docid. Positions within a doclist
 entry are stored in ascending order.




 The contents of the logical full\-text index is found by merging the
 contents of all segment b\-trees. If a term is present in more than one
 segment b\-tree, then it maps to the union of each individual doclist. If,
 for a single term, the same docid occurs in more than one doclist, then only
 the doclist that is part of the most recently created segment b\-tree is
 considered valid.




 Multiple b\-tree structures are used instead of a single b\-tree to reduce
 the cost of inserting records into FTS tables. When a new record is
 inserted into an FTS table that already contains a lot of data, it is
 likely that many of the terms in the new record are already present in
 a large number of existing records. If a single b\-tree were used, then
 large doclist structures would have to be loaded from the database,
 amended to include the new docid and term\-offset list, then written back
 to the database. Using multiple b\-tree tables allows this to be avoided
 by creating a new b\-tree which can be merged with the existing b\-tree
 (or b\-trees) later on. Merging of b\-tree structures can be performed as
 a background task, or once a certain number of separate b\-tree structures
 have been accumulated. Of course, this scheme makes queries more expensive
 (as the FTS code may have to look up individual terms in more than one
 b\-tree and merge the results), but it has been found that in practice this
 overhead is often negligible.



