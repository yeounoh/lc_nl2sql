# Appendix A: Search Application Tips



 FTS is primarily designed to support Boolean full\-text queries \- queries
 to find the set of documents that match a specified criteria. However, many
 (most?) search applications require that results are somehow ranked in order
 of "relevance", where "relevance" is defined as the likelihood that the user
 who performed the search is interested in a specific element of the returned
 set of documents. When using a search engine to find documents on the world
 wide web, the user expects that the most useful, or "relevant", documents
 will be returned as the first page of results, and that each subsequent page
 contains progressively less relevant results. Exactly how a machine can
 determine document relevance based on a users query is a complicated problem
 and the subject of much ongoing research.




 One very simple scheme might be to count the number of instances of the
 users search terms in each result document. Those documents that contain
 many instances of the terms are considered more relevant than those with
 a small number of instances of each term. In an FTS application, the
 number of term instances in each result could be determined by counting
 the number of integers in the return value of the [offsets](fts3.html#offsets) function.
 The following example shows a query that could be used to obtain the
 ten most relevant results for a query entered by the user:




```
-- This example (and all others in this section) assumes the following schema
CREATE VIRTUAL TABLE documents USING fts3(title, content);

-- Assuming the application has supplied an SQLite user function named "countintegers"
-- that returns the number of space-separated integers contained in its only argument,
-- the following query could be used to return the titles of the 10 documents that contain
-- the greatest number of instances of the users query terms. Hopefully, these 10
-- documents will be those that the users considers more or less the most "relevant".
SELECT title FROM documents
  WHERE documents MATCH <query>
  ORDER BY countintegers(offsets(documents)) DESC
  LIMIT 10 OFFSET 0

```


 The query above could be made to run faster by using the FTS [matchinfo](fts3.html#matchinfo)
 function to determine the number of query term instances that appear in each
 result. The matchinfo function is much more efficient than the offsets
 function. Furthermore, the matchinfo function provides extra information
 regarding the overall number of occurrences of each query term in the entire
 document set (not just the current row) and the number of documents in which
 each query term appears. This may be used (for example) to attach a higher
 weight to less common terms which may increase the overall computed relevancy
 of those results the user considers more interesting.




```
-- If the application supplies an SQLite user function called "rank" that
-- interprets the blob of data returned by matchinfo and returns a numeric
-- relevancy based on it, then the following SQL may be used to return the
-- titles of the 10 most relevant documents in the dataset for a users query.
SELECT title FROM documents
  WHERE documents MATCH <query>
  ORDER BY rank(matchinfo(documents)) DESC
  LIMIT 10 OFFSET 0

```


 The SQL query in the example above uses less CPU than the first example
 in this section, but still has a non\-obvious performance problem. SQLite
 satisfies this query by retrieving the value of the "title" column and
 matchinfo data from the FTS module for every row matched by the users
 query before it sorts and limits the results. Because of the way SQLite's
 virtual table interface works, retrieving the value of the "title" column
 requires loading the entire row from disk (including the "content" field,
 which may be quite large). This means that if the users query matches
 several thousand documents, many megabytes of "title" and "content" data
 may be loaded from disk into memory even though they will never be used
 for any purpose.




 The SQL query in the following example block is one solution to this
 problem. In SQLite, when a [sub\-query
 used in a join contains a LIMIT clause](optoverview.html#flattening), the results of the sub\-query are
 calculated and stored in temporary table before the main query is executed.
 This means that SQLite will load only the docid and matchinfo data for each
 row matching the users query into memory, determine the docid values
 corresponding to the ten most relevant documents, then load only the title
 and content information for those 10 documents only. Because both the matchinfo
 and docid values are gleaned entirely from the full\-text index, this results
 in dramatically less data being loaded from the database into memory.




```
SELECT title FROM documents JOIN (
    SELECT docid, rank(matchinfo(documents)) AS rank
    FROM documents
    WHERE documents MATCH <query>
    ORDER BY rank DESC
    LIMIT 10 OFFSET 0
) AS ranktable USING(docid)
ORDER BY ranktable.rank DESC

```


 The next block of SQL enhances the query with solutions to two other problems
 that may arise in developing search applications using FTS:



1. The [snippet](fts3.html#snippet) function cannot be used with the above query. Because
 the outer query does not include a "WHERE ... MATCH" clause, the snippet
 function may not be used with it. One solution is to duplicate the WHERE
 clause used by the sub\-query in the outer query. The overhead associated
 with this is usually negligible.
2. The relevancy of a document may depend on something other than just
 the data available in the return value of matchinfo. For example
 each document in the database may be assigned a static weight based
 on factors unrelated to its content (origin, author, age, number
 of references etc.). These values can be stored by the application
 in a separate table that can be joined against the documents table
 in the sub\-query so that the rank function may access them.



 This version of the query is very similar to that used by the
 [sqlite.org documentation search](https://www.sqlite.org/search?q=fts3)
 application.




```
-- This table stores the static weight assigned to each document in FTS table
-- "documents". For each row in the documents table there is a corresponding row
-- with the same docid value in this table.
CREATE TABLE documents_data(docid INTEGER PRIMARY KEY, weight);

-- This query is similar to the one in the block above, except that:
--
--   1. It returns a "snippet" of text along with the document title for display. So
--      that the snippet function may be used, the "WHERE ... MATCH ..." clause from
--      the sub-query is duplicated in the outer query.
--
--   2. The sub-query joins the documents table with the document_data table, so that
--      implementation of the rank function has access to the static weight assigned
--      to each document.
SELECT title, snippet(documents) FROM documents JOIN (
    SELECT docid, rank(matchinfo(documents), documents_data.weight) AS rank
    FROM documents JOIN documents_data USING(docid)
    WHERE documents MATCH <query>
    ORDER BY rank DESC
    LIMIT 10 OFFSET 0
) AS ranktable USING(docid)
WHERE documents MATCH <query>
ORDER BY ranktable.rank DESC

```


 All the example queries above return the ten most relevant query results.
 By modifying the values used with the OFFSET and LIMIT clauses, a query
 to return (say) the next ten most relevant results is easy to construct.
 This may be used to obtain the data required for a search applications second
 and subsequent pages of results.




 The next block contains an example rank function that uses matchinfo data
 implemented in C. Instead of a single weight, it allows a weight to be
 externally assigned to each column of each document. It may be registered
 with SQLite like any other user function using [sqlite3\_create\_function](c3ref/create_function.html).



 **Security Warning:** Because it is just an ordinary SQL function,
 rank() may be invoked as part of any SQL query in any context. This means
 that the first argument passed may not be a valid matchinfo blob.
 Implementors should take care to handle this case without causing buffer
 overruns or other potential security problems.




```
/*
** SQLite user defined function to use with matchinfo() to calculate the
** relevancy of an FTS match. The value returned is the relevancy score
** (a real value greater than or equal to zero). A larger value indicates 
** a more relevant document.
**
** The overall relevancy returned is the sum of the relevancies of each 
** column value in the FTS table. The relevancy of a column value is the
** sum of the following for each reportable phrase in the FTS query:
**
**   (<hit count> / <global hit count>) * <column weight>
**
** where <hit count> is the number of instances of the phrase in the
** column value of the current row and <global hit count> is the number
** of instances of the phrase in the same column of all rows in the FTS
** table. The <column weight> is a weighting factor assigned to each
** column by the caller (see below).
**
** The first argument to this function must be the return value of the FTS 
** matchinfo() function. Following this must be one argument for each column 
** of the FTS table containing a numeric weight factor for the corresponding 
** column. Example:
**
**     CREATE VIRTUAL TABLE documents USING fts3(title, content)
**
** The following query returns the docids of documents that match the full-text
** query <query> sorted from most to least relevant. When calculating
** relevance, query term instances in the 'title' column are given twice the
** weighting of those in the 'content' column.
**
**     SELECT docid FROM documents 
**     WHERE documents MATCH <query> 
**     ORDER BY rank(matchinfo(documents), 1.0, 0.5) DESC
*/
static void rankfunc(sqlite3_context *pCtx, int nVal, sqlite3_value **apVal){
  int *aMatchinfo;                /* Return value of matchinfo() */
  int nMatchinfo;                 /* Number of elements in aMatchinfo[] */
  int nCol = 0;                   /* Number of columns in the table */
  int nPhrase = 0;                /* Number of phrases in the query */
  int iPhrase;                    /* Current phrase */
  double score = 0.0;             /* Value to return */

  assert( sizeof(int)==4 );

  /* Check that the number of arguments passed to this function is correct.
  ** If not, jump to wrong_number_args. Set aMatchinfo to point to the array
  ** of unsigned integer values returned by FTS function matchinfo. Set
  ** nPhrase to contain the number of reportable phrases in the users full-text
  ** query, and nCol to the number of columns in the table. Then check that the
  ** size of the matchinfo blob is as expected. Return an error if it is not.
  */
  if( nVal<1 ) goto wrong_number_args;
  aMatchinfo = (unsigned int *)sqlite3_value_blob(apVal[0]);
  nMatchinfo = sqlite3_value_bytes(apVal[0]) / sizeof(int);
  if( nMatchinfo>=2 ){
    nPhrase = aMatchinfo[0];
    nCol = aMatchinfo[1];
  }
  if( nMatchinfo!=(2+3*nCol*nPhrase) ){
    sqlite3_result_error(pCtx,
      "invalid matchinfo blob passed to function rank()", -1);
    return;
  }
  if( nVal!=(1+nCol) ) goto wrong_number_args;

  /* Iterate through each phrase in the users query. */
  for(iPhrase=0; iPhrase<nPhrase; iPhrase++){
    int iCol;                     /* Current column */

    /* Now iterate through each column in the users query. For each column,
    ** increment the relevancy score by:
    **
    **   (<hit count> / <global hit count>) * <column weight>
    **
    ** aPhraseinfo[] points to the start of the data for phrase iPhrase. So
    ** the hit count and global hit counts for each column are found in 
    ** aPhraseinfo[iCol*3] and aPhraseinfo[iCol*3+1], respectively.
    */
    int *aPhraseinfo = &aMatchinfo[2 + iPhrase*nCol*3];
    for(iCol=0; iCol<nCol; iCol++){
      int nHitCount = aPhraseinfo[3*iCol];
      int nGlobalHitCount = aPhraseinfo[3*iCol+1];
      double weight = sqlite3_value_double(apVal[iCol+1]);
      if( nHitCount>0 ){
        score += ((double)nHitCount / (double)nGlobalHitCount) * weight;
      }
    }
  }

  sqlite3_result_double(pCtx, score);
  return;

  /* Jump here if the wrong number of arguments are passed to this function */
wrong_number_args:
  sqlite3_result_error(pCtx, "wrong number of arguments to function rank()", -1);
}

```


