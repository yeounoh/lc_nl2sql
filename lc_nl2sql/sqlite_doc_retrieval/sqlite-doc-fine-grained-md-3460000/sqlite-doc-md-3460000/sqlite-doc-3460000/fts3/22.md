## 6\.3\. The languageid\= option



 When the languageid option is present, it specifies the name of
 another [hidden column](vtab.html#hiddencol) that is added to the FTS4
 table and which is used to specify the language stored in each row
 of the FTS4 table. The name of the languageid hidden column must
 be distinct from all other column names in the FTS4 table. Example:




```
CREATE VIRTUAL TABLE t1 USING fts4(x, y, languageid="lid")

```


 The default value of a languageid column is 0\. Any value inserted
 into a languageid column is converted to a 32\-bit (not 64\) signed
 integer.




 By default, FTS queries (those that use the MATCH operator)
 consider only those rows with the languageid column set to 0\. To
 query for rows with other languageid values, a constraint of the
 form "

 \= " must be added to the queries
 WHERE clause. For example:


```
SELECT * FROM t1 WHERE t1 MATCH 'abc' AND lid=5;

```


 It is not possible for a single FTS query to return rows with
 different languageid values. The results of adding WHERE clauses
 that use other operators (e.g. lid!\=5, or lid\<\=5\) are undefined.




 If the content option is used along with the languageid option,
 then the named languageid column must exist in the content\= table
 (subject to the usual rules \- if a query never needs to read the
 content table then this restriction does not apply).




 When the languageid option is used, SQLite invokes the xLanguageid()
 on the sqlite3\_tokenizer\_module object immediately after the object
 is created in order to pass in the language id that the
 tokenizer should use. The xLanguageid() method will never be called
 more than once for any single tokenizer object. The fact that different
 languages might be tokenized differently is one reason why no single
 FTS query can return rows with different languageid values.







