## 10\.1\.  UTF\-16 byte\-order\-mark problem



For UTF\-16 databases, when using the "simple" tokenizer, it is possible to use
malformed unicode strings to cause the
[integrity\-check special command](#integcheck) to falsely report
corruption, or for [auxiliary functions](#snippet) to return
incorrect results. More specifically, the bug can be triggered by any of the following:

* A UTF\-16 byte\-order\-mark (BOM) is embedded at the beginning of an SQL string
 literal value inserted into an FTS3 table. For example:




```
INSERT INTO fts_table(col) VALUES(char(0xfeff)||'text...');

```
* Malformed UTF\-8 that SQLite converts to a UTF\-16 byte\-order\-mark is
 embedded at the beginning of an SQL string literal value inserted
 into an FTS3 table.
* A text value created by casting a blob that begins with the two
 bytes 0xFF and 0xFE, in either possible order, is inserted into an
 FTS3 table. For example:




```
INSERT INTO fts_table(col) VALUES(CAST(X'FEFF' AS TEXT));

```



Everything works correctly if any of the following are true:
* The [database encoding](pragma.html#pragma_encoding) is UTF\-8\.
* All text strings are insert using one of the
 [sqlite3\_bind\_text()](c3ref/bind_blob.html) family of functions.
* Literal strings contain no byte\-order\-marks.
* A tokenizer is used that recognizes byte\-order\-marks
 as whitespace. (The default "simple" tokenizer for
 FTS3/4 does not think that BOMs are whitespace, but
 the unicode tokenizer does.)


All of the above conditions must be false in order for problems
to occur. And even if all of the conditiona above are false,
most things will still operator correctly. Only the
[integrity\-check](#integcheck) command and the
[auxiliary functions](#snippet) might given
unexpected results.


