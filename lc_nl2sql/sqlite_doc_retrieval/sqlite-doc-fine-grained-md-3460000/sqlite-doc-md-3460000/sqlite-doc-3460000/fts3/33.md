## 8\.1\. Custom (Application Defined) Tokenizers



 In addition to providing built\-in "simple", "porter" and (possibly) "icu" and
 "unicode61" tokenizers,
 FTS provides an interface for applications to implement and register custom
 tokenizers written in C. The interface used to create a new tokenizer is defined
 and described in the fts3\_tokenizer.h source file.




 Registering a new FTS tokenizer is similar to registering a new
 virtual table module with SQLite. The user passes a pointer to a
 structure containing pointers to various callback functions that
 make up the implementation of the new tokenizer type. For tokenizers,
 the structure (defined in fts3\_tokenizer.h) is called
 "sqlite3\_tokenizer\_module".




 FTS does not expose a C\-function that users call to register new
 tokenizer types with a database handle. Instead, the pointer must
 be encoded as an SQL blob value and passed to FTS through the SQL
 engine by evaluating a special scalar function, "fts3\_tokenizer()".
 The fts3\_tokenizer() function may be called with one or two arguments,
 as follows:




```
SELECT fts3_tokenizer(<tokenizer-name>);
SELECT fts3_tokenizer(<tokenizer-name>, <sqlite3_tokenizer_module ptr>);

```


 Where \<tokenizer\-name\> is [parameter](lang_expr.html#varparam) to which a string is bound using
 [sqlite3\_bind\_text()](c3ref/bind_blob.html) where the string identifies the tokenizer and
 \<sqlite3\_tokenizer\_module ptr\> is a [parameter](lang_expr.html#varparam) to which a BLOB is
 bound using [sqlite3\_bind\_blob()](c3ref/bind_blob.html) where the value of the BLOB is a
 pointer to an sqlite3\_tokenizer\_module structure.
 If the second argument is present,
 it is registered as tokenizer \<tokenizer\-name\> and a copy of it
 returned. If only one argument is passed, a pointer to the tokenizer
 implementation currently registered as \<tokenizer\-name\> is returned,
 encoded as a blob. Or, if no such tokenizer exists, an SQL exception
 (error) is raised.




 Prior to SQLite [version 3\.11\.0](releaselog/3_11_0.html) (2016\-02\-15\), the arguments to
 fts3\_tokenizer() could be literal strings or BLOBs. They did not have to
 be [bound parameters](lang_expr.html#varparam). But that could lead to security problems in the
 event of an SQL injection. Hence, the legacy behavior is now disabled
 by default. But the old legacy behavior can be enabled, for backwards
 compatibility in applications that really need it,
 by calling
 [sqlite3\_db\_config](c3ref/db_config.html)(db,[SQLITE\_DBCONFIG\_ENABLE\_FTS3\_TOKENIZER](c3ref/c_dbconfig_defensive.html#sqlitedbconfigenablefts3tokenizer),1,0\).




 The following block contains an example of calling the fts3\_tokenizer()
 function from C code:




```
/*
** Register a tokenizer implementation with FTS3 or FTS4.
*/
int registerTokenizer(
  sqlite3 *db,
  char *zName,
  const sqlite3_tokenizer_module *p
){
  int rc;
  sqlite3_stmt *pStmt;
  const char *zSql = "SELECT fts3_tokenizer(?1, ?2)";

  rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);
  if( rc!=SQLITE_OK ){
    return rc;
  }

  sqlite3_bind_text(pStmt, 1, zName, -1, SQLITE_STATIC);
  sqlite3_bind_blob(pStmt, 2, &p, sizeof(p), SQLITE_STATIC);
  sqlite3_step(pStmt);

  return sqlite3_finalize(pStmt);
}

/*
** Query FTS for the tokenizer implementation named zName.
*/
int queryTokenizer(
  sqlite3 *db,
  char *zName,
  const sqlite3_tokenizer_module **pp
){
  int rc;
  sqlite3_stmt *pStmt;
  const char *zSql = "SELECT fts3_tokenizer(?)";

  *pp = 0;
  rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);
  if( rc!=SQLITE_OK ){
    return rc;
  }

  sqlite3_bind_text(pStmt, 1, zName, -1, SQLITE_STATIC);
  if( SQLITE_ROW==sqlite3_step(pStmt) ){
    if( sqlite3_column_type(pStmt, 0)==SQLITE_BLOB ){
      memcpy(pp, sqlite3_column_blob(pStmt, 0), sizeof(*pp));
    }
  }

  return sqlite3_finalize(pStmt);
}

```


