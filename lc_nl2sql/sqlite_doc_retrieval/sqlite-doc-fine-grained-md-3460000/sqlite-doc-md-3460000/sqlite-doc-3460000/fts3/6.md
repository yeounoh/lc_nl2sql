## 1\.4\. Simple FTS Queries



 As for all other SQLite tables, virtual or otherwise, data is retrieved
 from FTS tables using a [SELECT](lang_select.html) statement.




 FTS tables can be queried efficiently using SELECT statements of two
 different forms:



* **Query by rowid**. If the WHERE clause of the SELECT statement
 contains a sub\-clause of the form "rowid \= ?", where ? is an SQL expression,
 FTS is able to retrieve the requested row directly using the equivalent
 of an SQLite [INTEGER PRIMARY KEY](lang_createtable.html#rowid) index.
* **Full\-text query**. If the WHERE clause of the SELECT statement contains
 a sub\-clause of the form "\<column\> MATCH ?", FTS is able to use
 the built\-in full\-text index to restrict the search to those documents
 that match the full\-text query string specified as the right\-hand operand
 of the MATCH clause.



 If neither of these two query strategies can be used, all
 queries on FTS tables are implemented using a linear scan of the entire
 table. If the table contains large amounts of data, this may be an
 impractical approach (the first example on this page shows that a linear
 scan of 1\.5 GB of data takes around 30 seconds using a modern PC).




```
-- The examples in this block assume the following FTS table:
CREATE VIRTUAL TABLE mail USING fts3(subject, body);

SELECT * FROM mail WHERE rowid = 15;                -- Fast. Rowid lookup.
SELECT * FROM mail WHERE body MATCH 'sqlite';       -- Fast. Full-text query.
SELECT * FROM mail WHERE mail MATCH 'search';       -- Fast. Full-text query.
SELECT * FROM mail WHERE rowid BETWEEN 15 AND 20;   -- Fast. Rowid lookup.
SELECT * FROM mail WHERE subject = 'database';      -- Slow. Linear scan.
SELECT * FROM mail WHERE subject MATCH 'database';  -- Fast. Full-text query.

```


 In all of the full\-text queries above, the right\-hand operand of the MATCH
 operator is a string consisting of a single term. In this case, the MATCH
 expression evaluates to true for all documents that contain one or more
 instances of the specified word ("sqlite", "search" or "database", depending
 on which example you look at). Specifying a single term as the right\-hand
 operand of the MATCH operator results in the simplest and most common type
 of full\-text query possible. However more complicated queries are possible,
 including phrase searches, term\-prefix searches and searches for documents
 containing combinations of terms occurring within a defined proximity of each
 other. The various ways in which the full\-text index may be queried are
 [described below](fts3.html#full_text_index_queries).




 Normally, full\-text queries are case\-insensitive. However, this
 is dependent on the specific [tokenizer](fts3.html#tokenizer) used by the FTS table
 being queried. Refer to the section on [tokenizers](fts3.html#tokenizer) for details.




 The paragraph above notes that a MATCH operator with a simple term as the
 right\-hand operand evaluates to true for all documents that contain the
 specified term. In this context, the "document" may refer to either the
 data stored in a single column of a row of an FTS table, or to the contents
 of all columns in a single row, depending on the identifier used as the
 left\-hand operand to the MATCH operator. If the identifier specified as
 the left\-hand operand of the MATCH operator is an FTS table column name,
 then the document that the search term must be contained in is the value
 stored in the specified column. However, if the identifier is the name
 of the FTS *table* itself, then the MATCH operator evaluates to true
 for each row of the FTS table for which any column contains the search
 term. The following example demonstrates this:




```
-- Example schema
CREATE VIRTUAL TABLE mail USING fts3(subject, body);

-- Example table population
INSERT INTO mail(docid, subject, body) VALUES(1, 'software feedback', 'found it too slow');
INSERT INTO mail(docid, subject, body) VALUES(2, 'software feedback', 'no feedback');
INSERT INTO mail(docid, subject, body) VALUES(3, 'slow lunch order',  'was a software problem');

-- Example queries
SELECT * FROM mail WHERE subject MATCH 'software';    -- Selects rows 1 and 2
SELECT * FROM mail WHERE body    MATCH 'feedback';    -- Selects row 2
SELECT * FROM mail WHERE mail    MATCH 'software';    -- Selects rows 1, 2 and 3
SELECT * FROM mail WHERE mail    MATCH 'slow';        -- Selects rows 1 and 3

```


 At first glance, the final two full\-text queries in the example above seem
 to be syntactically incorrect, as there is a table name ("mail") used as
 an SQL expression. The reason this is acceptable is that each FTS table
 actually has a [HIDDEN](c3ref/declare_vtab.html) column with the same name
 as the table itself (in this case, "mail"). The value stored in this
 column is not meaningful to the application, but can be used as the
 left\-hand operand to a MATCH operator. This special column may also be
 passed as an argument to the [FTS auxiliary functions](fts3.html#snippet).




 The following example illustrates the above. The expressions "docs",
 "docs.docs" and "main.docs.docs" all refer to column "docs". However, the
 expression "main.docs" does not refer to any column. It could be used to
 refer to a table, but a table name is not allowed in the context in which
 it is used below.




```
-- Example schema
CREATE VIRTUAL TABLE docs USING fts4(content);

-- Example queries
SELECT * FROM docs WHERE docs MATCH 'sqlite';              -- OK.
SELECT * FROM docs WHERE docs.docs MATCH 'sqlite';         -- OK.
SELECT * FROM docs WHERE main.docs.docs MATCH 'sqlite';    -- OK.
SELECT * FROM docs WHERE main.docs MATCH 'sqlite';         -- Error.

```

