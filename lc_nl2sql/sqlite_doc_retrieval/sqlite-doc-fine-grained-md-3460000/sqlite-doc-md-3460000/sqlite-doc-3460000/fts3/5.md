## 1\.3\. Populating FTS Tables



 FTS tables are populated using [INSERT](lang_insert.html), [UPDATE](lang_update.html) and [DELETE](lang_delete.html)
 statements in the same way as ordinary SQLite tables are.

 


 As well as the columns named by the user (or the "content" column if no
 module arguments were specified as part of the [CREATE VIRTUAL TABLE](lang_createvtab.html)
 statement), each FTS table has a "rowid" column. The rowid of an FTS
 table behaves in the same way as the rowid column of an ordinary SQLite
 table, except that the values stored in the rowid column of an FTS table
 remain unchanged if the database is rebuilt using the [VACUUM](lang_vacuum.html) command.
 For FTS tables, "docid" is allowed as an alias along with the usual "rowid",
 "oid" and "\_oid\_" identifiers. Attempting to insert or update a row with a
 docid value that already exists in the table is an error, just as it would
 be with an ordinary SQLite table.

 


 There is one other subtle difference between "docid" and the normal SQLite
 aliases for the rowid column. Normally, if an INSERT or UPDATE statement
 assigns discrete values to two or more aliases of the rowid column, SQLite
 writes the rightmost of such values specified in the INSERT or UPDATE
 statement to the database. However, assigning a non\-NULL value to both
 the "docid" and one or more of the SQLite rowid aliases when inserting or
 updating an FTS table is considered an error. See below for an example.




```
-- Create an FTS table
CREATE VIRTUAL TABLE pages USING fts4(title, body);

-- Insert a row with a specific docid value.
INSERT INTO pages(docid, title, body) VALUES(53, 'Home Page', 'SQLite is a software...');

-- Insert a row and allow FTS to assign a docid value using the same algorithm as
-- SQLite uses for ordinary tables. In this case the new docid will be 54,
-- one greater than the largest docid currently present in the table.
INSERT INTO pages(title, body) VALUES('Download', 'All SQLite source code...');

-- Change the title of the row just inserted.
UPDATE pages SET title = 'Download SQLite' WHERE rowid = 54;

-- Delete the entire table contents.
DELETE FROM pages;

-- The following is an error. It is not possible to assign non-NULL values to both
-- the rowid and docid columns of an FTS table.
INSERT INTO pages(rowid, docid, title, body) VALUES(1, 2, 'A title', 'A document body');

```


 To support full\-text queries, FTS maintains an inverted index that maps
 from each unique term or word that appears in the dataset to the locations
 in which it appears within the table contents. For the curious, a
 complete description of the [data structure](fts3.html#data_structures) used to store
 this index within the database file appears below. A feature of
 this data structure is that at any time the database may contain not
 one index b\-tree, but several different b\-trees that are incrementally
 merged as rows are inserted, updated and deleted. This technique improves
 performance when writing to an FTS table, but causes some overhead for
 full\-text queries that use the index. Evaluating the special ["optimize" command](fts3.html#*fts4optcmd),
 an SQL statement of the
 form "INSERT INTO \<fts\-table\>(\<fts\-table\>) VALUES('optimize')",
 causes FTS to merge all existing index b\-trees into a single large
 b\-tree containing the entire index. This can be an expensive operation,
 but may speed up future queries.

 


 For example, to optimize the full\-text index for an FTS table named
 "docs":




```
-- Optimize the internal structure of FTS table "docs".
INSERT INTO docs(docs) VALUES('optimize');

```


 The statement above may appear syntactically incorrect to some. Refer to
 the section describing the [simple fts queries](fts3.html#simple_fts_queries) for an explanation.

 


 There is another, deprecated, method for invoking the optimize
 operation using a SELECT statement. New code should use statements
 similar to the INSERT above to optimize FTS structures.




