# 1\. Overview


**[insert\-stmt:](syntax/insert-stmt.html)**
hide








WITH

RECURSIVE





common\-table\-expression






,








REPLACE

INSERT



OR



ROLLBACK





INTO










ABORT






FAIL






IGNORE






REPLACE






schema\-name



.



table\-name



AS



alias










(



column\-name



)

,














VALUES



(



expr



)



,




,






upsert\-clause






select\-stmt






upsert\-clause






DEFAULT



VALUES





returning\-clause










**[common\-table\-expression:](syntax/common-table-expression.html)**
show








table\-name





(





column\-name



)



AS

NOT

MATERIALIZED


(



select\-stmt



)




,






















**[expr:](syntax/expr.html)**
show








literal\-value




bind\-parameter






schema\-name



.



table\-name



.



column\-name












unary\-operator



expr






expr



binary\-operator



expr






function\-name



(



function\-arguments



)



filter\-clause





over\-clause












(



expr



)






,




CAST



(



expr



AS



type\-name



)






expr



COLLATE



collation\-name






expr



NOT



LIKE

GLOB

REGEXP

MATCH

expr

expr



ESCAPE



expr

































expr



ISNULL






NOTNULL

NOT



NULL












expr



IS



NOT





DISTINCT



FROM



expr








expr



NOT



BETWEEN



expr



AND



expr







expr



NOT



IN



(



select\-stmt



)








expr




,




schema\-name



.



table\-function



(



expr



)




table\-name






,










NOT



EXISTS



(



select\-stmt



)










CASE



expr



WHEN



expr



THEN



expr



ELSE



expr



END











raise\-function







**[filter\-clause:](syntax/filter-clause.html)**
show








FILTER



(



WHERE



expr



)






**[function\-arguments:](syntax/function-arguments.html)**
show










DISTINCT







expr








,





\*











ORDER



BY



ordering\-term

,







**[ordering\-term:](syntax/ordering-term.html)**
show








expr



COLLATE



collation\-name








DESC



ASC









NULLS



FIRST



NULLS



LAST










**[literal\-value:](syntax/literal-value.html)**
show








CURRENT\_TIMESTAMP






numeric\-literal




string\-literal






blob\-literal






NULL






TRUE






FALSE






CURRENT\_TIME






CURRENT\_DATE








**[over\-clause:](syntax/over-clause.html)**
show








OVER



window\-name



(



base\-window\-name

PARTITION



BY



expr

,













ORDER



BY



ordering\-term

,











frame\-spec



)



















**[frame\-spec:](syntax/frame-spec.html)**
show








GROUPS




BETWEEN



UNBOUNDED



PRECEDING



AND



UNBOUNDED



FOLLOWING




RANGE






ROWS






UNBOUNDED



PRECEDING




expr



PRECEDING






CURRENT



ROW






expr



PRECEDING






CURRENT



ROW






expr



FOLLOWING








expr



PRECEDING




CURRENT



ROW






expr



FOLLOWING






EXCLUDE



CURRENT



ROW




EXCLUDE



GROUP




EXCLUDE



TIES




EXCLUDE



NO



OTHERS





















**[ordering\-term:](syntax/ordering-term.html)**
show








expr



COLLATE



collation\-name








DESC



ASC









NULLS



FIRST



NULLS



LAST










**[raise\-function:](syntax/raise-function.html)**
show








RAISE



(



ROLLBACK



,



error\-message



)






IGNORE




ABORT




FAIL










**[type\-name:](syntax/type-name.html)**
show








name



(



signed\-number



,



signed\-number



)






(



signed\-number



)











**[signed\-number:](syntax/signed-number.html)**
show








\+



numeric\-literal






\-









**[returning\-clause:](syntax/returning-clause.html)**
show








RETURNING



expr



AS



column\-alias














\*






,







**[select\-stmt:](syntax/select-stmt.html)**
show









WITH

RECURSIVE





common\-table\-expression






,













SELECT



DISTINCT



result\-column

,







ALL






FROM



table\-or\-subquery

join\-clause

,

















WHERE



expr










GROUP



BY



expr



HAVING



expr

,


















WINDOW



window\-name



AS



window\-defn

,



















VALUES



(



expr



)




,

,









compound\-operator





select\-core

ORDER



BY

LIMIT



expr



ordering\-term

,

















OFFSET



expr



,



expr




















**[compound\-operator:](syntax/compound-operator.html)**
show










UNION

UNION

INTERSECT

EXCEPT



ALL





















**[join\-clause:](syntax/join-clause.html)**
show








table\-or\-subquery



join\-operator



table\-or\-subquery



join\-constraint











**[join\-constraint:](syntax/join-constraint.html)**
show








USING



(



column\-name



)






,






ON



expr









**[join\-operator:](syntax/join-operator.html)**
show








NATURAL





LEFT



OUTER





JOIN




,












RIGHT





FULL




INNER






CROSS







**[ordering\-term:](syntax/ordering-term.html)**
show








expr



COLLATE



collation\-name








DESC



ASC









NULLS



FIRST



NULLS



LAST









**[result\-column:](syntax/result-column.html)**
show








expr



AS



column\-alias














\*






table\-name



.



\*






**[table\-or\-subquery:](syntax/table-or-subquery.html)**
show








schema\-name



.



table\-name



AS



table\-alias






INDEXED



BY



index\-name

NOT



INDEXED









table\-function\-name



(



expr



)



,












AS



table\-alias











(



select\-stmt



)









(



table\-or\-subquery



)






,






join\-clause




**[window\-defn:](syntax/window-defn.html)**
show








(



base\-window\-name

PARTITION



BY



expr

,













ORDER



BY



ordering\-term

,











frame\-spec



)
















**[frame\-spec:](syntax/frame-spec.html)**
show








GROUPS




BETWEEN



UNBOUNDED



PRECEDING



AND



UNBOUNDED



FOLLOWING




RANGE






ROWS






UNBOUNDED



PRECEDING




expr



PRECEDING






CURRENT



ROW






expr



PRECEDING






CURRENT



ROW






expr



FOLLOWING








expr



PRECEDING




CURRENT



ROW






expr



FOLLOWING






EXCLUDE



CURRENT



ROW




EXCLUDE



GROUP




EXCLUDE



TIES




EXCLUDE



NO



OTHERS























**[upsert\-clause:](syntax/upsert-clause.html)**
show









ON



CONFLICT



(



indexed\-column



)



WHERE



expr





DO





,



conflictÂ target





UPDATE



SET



column\-name\-list



\=



expr



WHERE



expr




NOTHING






,








column\-name








**[column\-name\-list:](syntax/column-name-list.html)**
show








(





column\-name



)




,







**[indexed\-column:](syntax/indexed-column.html)**
show








column\-name



COLLATE



collation\-name





DESC








expr









ASC










The INSERT statement comes in three basic forms. 


1. **INSERT INTO** *table* **VALUES(...);**


The first form (with the "VALUES" keyword) creates one or more
new rows in
an existing table. If the column\-name list after
table\-name is omitted then the number
of values inserted into each row
must be the same as the number of columns in the table. In this case
the result of evaluating the left\-most expression from each term of
the VALUES list is inserted into the left\-most column of each new row,
and so forth for each subsequent expression. If a column\-name
list is specified, then the number of values in each term of the
VALUE list must match the number of
specified columns. Each of the named columns of the new row is populated
with the results of evaluating the corresponding VALUES expression. Table
columns that do not appear in the column list are populated with the 
[default column value](lang_createtable.html#dfltval) (specified as part of the [CREATE TABLE](lang_createtable.html) statement), or
with NULL if no [default value](lang_createtable.html#dfltval) is specified.
2. **INSERT INTO** *table* **SELECT ...;**


The second form of the INSERT statement contains a [SELECT](lang_select.html) statement
instead of a VALUES clause. A new entry is inserted into the table for each
row of data returned by executing the SELECT statement. If a column\-list is
specified, the number of columns in the result of the SELECT must be the same
as the number of items in the column\-list. Otherwise, if no column\-list is
specified, the number of columns in the result of the SELECT must be the same
as the number of columns in the table. Any SELECT statement, including
[compound SELECTs](lang_select.html#compound) and SELECT statements with [ORDER BY](lang_select.html#orderby) and/or [LIMIT](lang_select.html#limitoffset) clauses, 
may be used in an INSERT statement of this form.



To avoid a parsing ambiguity, the SELECT statement should always
contain a WHERE clause, even if that clause is simply "WHERE true",
if the [upsert\-clause](syntax/upsert-clause.html) is present. Without the WHERE clause, the
parser does not know if the token "ON" is part of a join constraint
on the SELECT, or the beginning of the [upsert\-clause](syntax/upsert-clause.html).
3. **INSERT INTO** *table* **DEFAULT VALUES;**


The third form of an INSERT statement is with DEFAULT VALUES.
The INSERT ... DEFAULT VALUES statement inserts a single new row into the
named table. Each column of the new row is populated with its 
[default value](lang_createtable.html#dfltval), or with a NULL if no default value is specified 
as part of the column definition in the [CREATE TABLE](lang_createtable.html) statement.
The [upsert\-clause](syntax/upsert-clause.html) is not supported after DEFAULT VALUES.



The initial "INSERT" keyword can be replaced by
"REPLACE" or "INSERT OR *action*" to specify an alternative
constraint [conflict resolution algorithm](lang_conflict.html) to use during 
that one INSERT command.
For compatibility with MySQL, the parser allows the use of the
single keyword [REPLACE](lang_replace.html) as an 
alias for "INSERT OR REPLACE".



The optional "*schema\-name***.**" prefix on the 
table\-name
is supported for top\-level INSERT statements only. The table name must be
unqualified for INSERT statements that occur within [CREATE TRIGGER](lang_createtrigger.html) statements.
Similarly, the "DEFAULT VALUES" form of the INSERT statement is supported for
top\-level INSERT statements only and not for INSERT statements within
triggers.





The optional "AS alias" phrase provides an alternative
name for the table into which content is being inserted. The alias name
can be used within WHERE and SET clauses of the [UPSERT](lang_upsert.html). If there is no
[upsert\-clause](syntax/upsert-clause.html), then the alias is pointless, but also
harmless.



See the separate [UPSERT](lang_upsert.html) documentation for the additional trailing
syntax that can cause an INSERT to behave as an UPDATE if the INSERT would
otherwise violate a uniqueness constraint. The [upsert clause](lang_upsert.html) is not
allowed on an "INSERT ... DEFAULT VALUES".


*This page last modified on [2022\-01\-08 05:02:57](https://sqlite.org/docsrc/honeypot) UTC* 


