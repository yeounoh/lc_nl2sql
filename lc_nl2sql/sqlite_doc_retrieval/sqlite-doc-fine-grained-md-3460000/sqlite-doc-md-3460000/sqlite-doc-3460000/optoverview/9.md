# 6\. The Skip\-Scan Optimization



 The general rule is that indexes are only useful if there are 
 WHERE\-clause constraints on the left\-most columns of the index.
 However, in some cases,
 SQLite is able to use an index even if the first few columns of
 the index are omitted from the WHERE clause but later columns 
 are included.





 Consider a table such as the following:




```
CREATE TABLE people(
  name TEXT PRIMARY KEY,
  role TEXT NOT NULL,
  height INT NOT NULL, -- in cm
  CHECK( role IN ('student','teacher') )
);
CREATE INDEX people_idx1 ON people(role, height);

```


 The people table has one entry for each person in a large
 organization. Each person is either a "student" or a "teacher",
 as determined by the "role" field. The table also records the height in
 centimeters of each person. The role and height are indexed.
 Notice that the left\-most column of the index is not very
 selective \- it only contains two possible values.





 Now consider a query to find the names of everyone in the
 organization that is 180cm tall or taller:





```
SELECT name FROM people WHERE height>=180;

```


 Because the left\-most column of the index does not appear in the
 WHERE clause of the query, one is tempted to conclude that the
 index is not usable here. However, SQLite is able to use the index.
 Conceptually, SQLite uses the index as if the query were more
 like the following:





```
SELECT name FROM people
 WHERE role IN (SELECT DISTINCT role FROM people)
   AND height>=180;

```


 Or this:




```
SELECT name FROM people WHERE role='teacher' AND height>=180
UNION ALL
SELECT name FROM people WHERE role='student' AND height>=180;

```


 The alternative query formulations shown above are conceptual only.
 SQLite does not really transform the query. 
 The actual query plan is like this:
 SQLite locates the first possible value for "role", which it
 can do by rewinding the "people\_idx1" index to the beginning and reading
 the first record. SQLite stores this first "role" value in an
 internal variable that we will here call "$role". Then SQLite
 runs a query like: "SELECT name FROM people WHERE role\=$role AND height\>\=180".
 This query has an equality constraint on the left\-most column of the
 index and so the index can be used to resolve that query. Once
 that query is finished, SQLite then uses the "people\_idx1" index to
 locate the next value of the "role" column, using code that is logically
 similar to "SELECT role FROM people WHERE role\>$role LIMIT 1".
 This new "role" value overwrites the $role variable, and the process
 repeats until all possible values for "role" have been examined.




 We call this kind of index usage a "skip\-scan" because the database
 engine is basically doing a full scan of the index but it optimizes the
 scan (making it less than "full") by occasionally skipping ahead to the
 next candidate value.




 SQLite might use a skip\-scan on an index if it knows that the first
 one or more columns contain many duplication values.
 If there are too few duplicates
 in the left\-most columns of the index, then it would
 be faster to simply step ahead to the next value, and thus do
 a full table scan, than to do a binary search on an index to locate
 the next left\-column value.




 The only way that SQLite can know that there are many duplicates
 in the left\-most columns of an index
 is if the [ANALYZE](lang_analyze.html) command has been run
 on the database.
 Without the results of ANALYZE, SQLite has to guess at the "shape" of
 the data in the table, and the default guess is that there are an average
 of 10 duplicates for every value in the left\-most column of the index.
 Skip\-scan only becomes profitable (it only gets to be faster than
 a full table scan) when the number of duplicates is about 18 or more.
 Hence, a skip\-scan is never used on a database that has not been analyzed.




