# 8\. Choosing Between Multiple Indexes



 Each table in the FROM clause of a query can use at most one index
 (except when the [OR\-clause optimization](#or_opt) comes into
 play)
 and SQLite strives to use at least one index on each table. Sometimes,
 two or more indexes might be candidates for use on a single table.
 For example:




```
CREATE TABLE ex2(x,y,z);
CREATE INDEX ex2i1 ON ex2(x);
CREATE INDEX ex2i2 ON ex2(y);
SELECT z FROM ex2 WHERE x=5 AND y=6;

```


 For the SELECT statement above, the optimizer can use the ex2i1 index
 to lookup rows of ex2 that contain x\=5 and then test each row against
 the y\=6 term. Or it can use the ex2i2 index to lookup rows
 of ex2 that contain y\=6 then test each of those rows against the
 x\=5 term.




 When faced with a choice of two or more indexes, SQLite tries to estimate
 the total amount of work needed to perform the query using each option.
 It then selects the option that gives the least estimated work.




 To help the optimizer get a more accurate estimate of the work involved
 in using various indexes, the user may optionally run the [ANALYZE](lang_analyze.html) command.
 The [ANALYZE](lang_analyze.html) command scans all indexes of database where there might
 be a choice between two or more indexes and gathers statistics on the
 selectiveness of those indexes. The statistics gathered by
 this scan are stored in special database tables names shows names all
 begin with "**sqlite\_stat**".
 The content of these tables is not updated as the database
 changes so after making significant changes it might be prudent to
 rerun [ANALYZE](lang_analyze.html).
 The results of an ANALYZE command are only available to database connections
 that are opened after the ANALYZE command completes.




 The various **sqlite\_stat***N* tables contain information on how
 selective the various indexes are. For example, the [sqlite\_stat1](fileformat2.html#stat1tab)
 table might indicate that an equality constraint on column x reduces the
 search space to 10 rows on average, whereas an equality constraint on
 column y reduces the search space to 3 rows on average. In that case,
 SQLite would prefer to use index ex2i2 since that index is more selective.




