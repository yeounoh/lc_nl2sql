## 12\.1\. Using Co\-routines to Defer Work until after the Sorting



 As of SQLite version 3\.21\.0 (2017\-10\-24\), the query planner will
 always prefer to use a co\-routine to implement FROM\-clause subqueries 
 that contains an ORDER BY clause and that are not part of a join when
 the result set of the outer query is "complex". This feature allows
 applications to shift expensive computations from before the
 sorter until after the sorter, which can result in faster operation.
 For example, consider this query:




```
SELECT expensive_function(a) FROM tab ORDER BY date DESC LIMIT 5;

```


 The goal of this query is to compute some value for the five most
 recent entries in the table. In the query above, the
 "expensive\_function()" is invoked prior to the sort and thus is
 invoked on every row of the table, even
 rows that are ultimately omitted due to the LIMIT clause.
 A co\-routine can be used to work around this:




```
SELECT expensive_function(a) FROM (
  SELECT a FROM tab ORDER BY date DESC LIMIT 5
);

```


 In the revised query, the subquery implemented by a co\-routine computes
 the five most recent values for "a". Those five values are passed from the
 co\-routine up into the outer query where the "expensive\_function()" is
 invoked on only the specific rows that the application cares about.




 The query planner in future versions of SQLite might grow smart enough
 to make transformations such as the above automatically, in both directions.
 That is to say, future versions of SQLite might transform queries of the
 first form into the second, or queries written the second way into the
 first. As of SQLite version 3\.22\.0 (2018\-01\-22\), the query planner
 will flatten the subquery if the outer query does not make use of any
 user\-defined functions or subqueries in its result set. For the examples
 shown above, however, SQLite implements each of the queries as
 written.




