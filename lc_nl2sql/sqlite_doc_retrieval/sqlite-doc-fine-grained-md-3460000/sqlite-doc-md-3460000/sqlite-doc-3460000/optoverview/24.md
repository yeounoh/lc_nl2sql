# 14\. Automatic Query\-Time Indexes



 When no indexes are available to aid the evaluation of a query, SQLite
 might create an automatic index that lasts only for the duration
 of a single SQL statement.
 Automatic indexes are also sometimes called "Query\-time indexes".
 Since the cost of constructing the automatic or query\-time index is
 O(NlogN) (where N is the number of entries in the table) and the cost of
 doing a full table scan is only O(N), an automatic index will
 only be created if SQLite expects that the lookup will be run more than
 logN times during the course of the SQL statement. Consider an example:




```
CREATE TABLE t1(a,b);
CREATE TABLE t2(c,d);
-- Insert many rows into both t1 and t2
SELECT * FROM t1, t2 WHERE a=c;

```


 In the query above, if both t1 and t2 have approximately N rows, then
 without any indexes the query will require O(N\*N) time. On the other
 hand, creating an index on table t2 requires O(NlogN) time and using
 that index to evaluate the query requires an additional O(NlogN) time.
 In the absence of [ANALYZE](lang_analyze.html) information, SQLite guesses that N is one
 million and hence it believes that constructing the automatic index will
 be the cheaper approach.




 An automatic query\-time index might also be used for a subquery:




```
CREATE TABLE t1(a,b);
CREATE TABLE t2(c,d);
-- Insert many rows into both t1 and t2
SELECT a, (SELECT d FROM t2 WHERE c=b) FROM t1;

```


 In this example, the t2 table is used in a subquery to translate values
 of the t1\.b column. If each table contains N rows, SQLite expects that
 the subquery will run N times, and hence it will believe it is faster
 to construct an automatic, transient index on t2 first and then use
 that index to satisfy the N instances of the subquery.




 The automatic indexing capability can be disabled at run\-time using
 the [automatic\_index pragma](pragma.html#pragma_automatic_index). Automatic indexing is turned on by
 default, but this can be changed so that automatic indexing is off
 by default using the [SQLITE\_DEFAULT\_AUTOMATIC\_INDEX](compile.html#default_automatic_index) compile\-time option.
 The ability to create automatic indexes can be completely disabled by
 compiling with the [SQLITE\_OMIT\_AUTOMATIC\_INDEX](compile.html#omit_automatic_index) compile\-time option.




 In SQLite [version 3\.8\.0](releaselog/3_8_0.html) (2013\-08\-26\) and later, 
 an [SQLITE\_WARNING\_AUTOINDEX](rescode.html#warning_autoindex) message is sent
 to the [error log](errlog.html) every time a statement is prepared that uses an
 automatic index. Application developers can and should use these warnings
 to identify the need for new persistent indexes in the schema.




 Do not confuse automatic indexes with the [internal indexes](fileformat2.html#intschema) (having names
 like "sqlite\_autoindex\_*table*\_*N*") that are sometimes
 created to implement a [PRIMARY KEY constraint](lang_createtable.html#primkeyconst) or [UNIQUE constraint](lang_createtable.html#uniqueconst).
 The automatic indexes described here exist only for the duration of a
 single query, are never persisted to disk, and are only visible to a
 single database connection. Internal indexes are part of the implementation
 of PRIMARY KEY and UNIQUE constraints, are long\-lasting and persisted
 to disk, and are visible to all database connections. The term "autoindex"
 appears in the names of [internal indexes](fileformat2.html#intschema) for legacy reasons and does
 not indicate that internal indexes and automatic indexes are related.




