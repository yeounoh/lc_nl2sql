# 11\. Subquery Flattening



 When a subquery occurs in the FROM clause of a SELECT, the simplest
 behavior is to evaluate the subquery into a transient table, then run
 the outer SELECT against the transient table. Such a plan
 can be suboptimal since the transient table will not have any indexes
 and the outer query (which is likely a join) will be forced to either
 do full table scan on the transient table or else construct a
 [query\-time index](optoverview.html#autoindex) on the transient table, neither or which is likely
 to be particularly fast.




 To overcome this problem, SQLite attempts to flatten subqueries in
 the FROM clause of a SELECT.
 This involves inserting the FROM clause of the subquery into the
 FROM clause of the outer query and rewriting expressions in
 the outer query that refer to the result set of the subquery.
 For example:




```
SELECT t1.a, t2.b FROM t2, (SELECT x+y AS a FROM t1 WHERE z<100) WHERE a>5

```


 Would be rewritten using query flattening as:




```
SELECT t1.x+t1.y AS a, t2.b FROM t2, t1 WHERE z<100 AND a>5

```


 There is a long list of conditions that must all be met in order for
 query flattening to occur. Some of the constraints are marked as 
 obsolete by italic text. These extra constraints are retained in the
 documentation to preserve the numbering of the other constraints.




 Casual readers are not expected to understand all of these rules.
 The point here is that flattening rules are subtle and complex.
 There have been multiple bugs over the years caused by
 over\-aggressive query flattening. On the other hand, performance
 of complex queries and/or queries involving views tends to suffer
 if query flattening is more conservative.






1. *(Obsolete)*
2. *(Obsolete)*
3. If the subquery is the right operand of a LEFT JOIN then
	1. the subquery may not be a join, and
	2. the FROM clause of the subquery may
	 not contain a virtual table, and
	3. the outer query may not be DISTINCT.
4. The subquery is not DISTINCT.
5. *(Obsolete \- subsumed into constraint 4\)*
6. *(Obsolete)*
7. The subquery has a FROM clause.
8. The subquery does not use LIMIT or the outer query is
 not a join.
9. The subquery does not use LIMIT or the outer query
 does not use aggregates.
10. *(Obsolete)*
11. The subquery and the outer query do not both have ORDER BY clauses.
12. *(Obsolete \- subsumed into constraint 3\)*
13. The subquery and outer query do not both use LIMIT.
14. The subquery does not use OFFSET.
15. If the outer query is part of a compound select, then the
 subquery may not have a LIMIT clause.
16. If the outer query is an aggregate, then the subquery may
 not contain ORDER BY.
17. If the sub\-query is a compound SELECT, then
	1. all compound operators must be UNION ALL, and
	2. no terms with the subquery compound may be aggregate
	 or DISTINCT, and
	3. every term within the subquery must have a FROM clause, and
	4. the outer query may not be an aggregateor DISTINCT query.
	5. the subquery may not contain window functions.
	6. the subquery must not be the right\-hand side of a LEFT JOIN.
	7. either the subquery is the first element of the outer query
	 or there are not RIGHT or FULL JOINs in any arm of the subquery.
	8. the corresponding result set expressions in all arms of the
	 compound subquery must have the same [affinity](datatype3.html#affinity).

 The parent and sub\-query may contain WHERE clauses. Subject to
 rules (11\), (12\) and (13\), they may also contain ORDER BY,
 LIMIT and OFFSET clauses.
18. If the sub\-query is a compound select, then all terms of the
 ORDER by clause of the parent must be simple references to 
 columns of the sub\-query.
19. If the subquery uses LIMIT then the outer query may not
 have a WHERE clause.
20. If the sub\-query is a compound select, then it must not use
 an ORDER BY clause.
21. If the subquery uses LIMIT, then the outer query may not be
 DISTINCT.
22. The subquery may not be a recursive CTE.
23. If the outer query is a recursive CTE, then the sub\-query
 may not be a compound query.
24. *(Obsolete)*
25. Neither the subquery nor the outer query may contain
 a [window function](windowfunctions.html) in the result set nor the ORDER BY clause.
26. The subquery may not be the right operand of a RIGHT
 or FULL OUTER JOIN.
27. The subquery may not contain a FULL or RIGHT JOIN unless it
 is the first element of the parent query. Two subcases:
	1. the subquery is not a compound query.
	2. the subquery is a compound query and the RIGHT JOIN occurs
	 in any arm of the compound query. (See also (17g)).
28. The subquery is not a MATERIALIZED CTE.



 Query flattening is an important optimization when views are used as
 each use of a view is translated into a subquery.




