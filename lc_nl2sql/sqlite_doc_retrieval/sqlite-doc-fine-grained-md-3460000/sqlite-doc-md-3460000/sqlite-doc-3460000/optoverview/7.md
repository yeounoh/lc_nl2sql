## 4\.2\. Evaluating OR constraints separately and taking the UNION of the result



 If and only if the previously described conversion of OR to an IN operator
 does not work, the second OR\-clause optimization is attempted.
 Suppose the OR clause consists of multiple subterms as follows:


> ```
> 
>   expr1 OR expr2 OR expr3
> 
> ```





 Individual subterms might be a single comparison expression like
 **a\=5** or **x\>y** or they can be 
 LIKE or BETWEEN expressions, or a subterm
 can be a parenthesized list of AND\-connected sub\-subterms.
 Each subterm is analyzed as if it were itself the entire WHERE clause
 in order to see if the subterm is indexable by itself.
 If every subterm of an OR clause is separately indexable
 then the OR clause might be coded such that a separate index is used
 to evaluate each term of the OR clause. One way to think about how
 SQLite uses separate indexes for each OR clause term is to imagine
 that the WHERE clause where rewritten as follows:


> ```
> 
>   rowid IN (SELECT rowid FROM table WHERE expr1
>             UNION SELECT rowid FROM table WHERE expr2
>             UNION SELECT rowid FROM table WHERE expr3)
> 
> ```





 The rewritten expression above is conceptual; WHERE clauses containing
 OR are not really rewritten this way.
 The actual implementation of the OR clause uses a mechanism that is
 more efficient and that works even for [WITHOUT ROWID](withoutrowid.html) tables or 
 tables in which the "rowid" is inaccessible. Nevertheless,
 the essence of the implementation is captured by the statement
 above: Separate indexes are used to find candidate result rows
 from each OR clause term and the final result is the union of
 those rows.




 Note that in most cases, SQLite will only use a single index for each
 table in the FROM clause of a query. The second OR\-clause optimization
 described here is the exception to that rule. With an OR\-clause,
 a different index might be used for each subterm in the OR\-clause.




 For any given query, the fact that the OR\-clause optimization described
 here can be used does not guarantee that it will be used.
 SQLite uses a cost\-based query planner that estimates the CPU and
 disk I/O costs of various competing query plans and chooses the plan
 that it thinks will be the fastest. If there are many OR terms in
 the WHERE clause or if some of the indexes on individual OR\-clause 
 subterms are not very selective, then SQLite might decide that it is
 faster to use a different query algorithm, or even a full\-table scan.
 Application developers can use the
 [EXPLAIN QUERY PLAN](lang_explain.html) prefix on a statement to get a
 high\-level overview of the chosen query strategy.




