# 7\. Joins



 SQLite implements joins as nested loops.
 The default order of the nested loops in a join is for the left\-most
 table in the FROM clause to form the outer loop and the right\-most
 table to form the inner loop.
 However, SQLite will nest the loops in a different order if doing so
 will help it to select better indexes.




 Inner joins can be freely reordered. However outer joins are
 neither commutative nor associative and hence will not be reordered.
 Inner joins to the left and right of an outer join might be reordered
 if the optimizer thinks that is advantageous but outer joins are
 always evaluated in the order in which they occur.




 SQLite [treats the CROSS JOIN operator specially](lang_select.html#crossjoin).
 The CROSS JOIN operator is commutative, in theory. However, SQLite chooses to
 never reorder tables in a CROSS JOIN. This provides a mechanism
 by which the programmer can force SQLite to choose a particular loop nesting
 order. 




 When selecting the order of tables in a join, SQLite uses an efficient
 polynomial\-time algorithm graph algorithm described in
 the [Next Generation Query Planner](queryplanner-ng.html) document. Because of this,
 SQLite is able to plan queries with 50\- or 60\-way joins in a matter of
 microseconds




 Join reordering is automatic and usually works well enough that
 programmers do not have to think about it, especially if [ANALYZE](lang_analyze.html)
 has been used to gather statistics about the available indexes,
 though occasionally some hints from the programmer are needed.
 Consider, for example, the following schema:




```
CREATE TABLE node(
   id INTEGER PRIMARY KEY,
   name TEXT
);
CREATE INDEX node_idx ON node(name);
CREATE TABLE edge(
   orig INTEGER REFERENCES node,
   dest INTEGER REFERENCES node,
   PRIMARY KEY(orig, dest)
);
CREATE INDEX edge_idx ON edge(dest,orig);

```


 The schema above defines a directed graph with the ability to store a
 name at each node. Now consider a query against this schema:




```
SELECT *
  FROM edge AS e,
       node AS n1,
       node AS n2
 WHERE n1.name = 'alice'
   AND n2.name = 'bob'
   AND e.orig = n1.id
   AND e.dest = n2.id;

```


 This query asks for is all information about edges that go from
 nodes labeled "alice" to nodes labeled "bob".
 The query optimizer in SQLite has basically two choices on how to
 implement this query. (There are actually six different choices, but
 we will only consider two of them here.)
 Pseudocode below demonstrating these two choices.




Option 1:



```
foreach n1 where n1.name='alice' do:
  foreach n2 where n2.name='bob' do:
    foreach e where e.orig=n1.id and e.dest=n2.id
      return n1.*, n2.*, e.*
    end
  end
end

```


Option 2:



```
foreach n1 where n1.name='alice' do:
  foreach e where e.orig=n1.id do:
    foreach n2 where n2.id=e.dest and n2.name='bob' do:
      return n1.*, n2.*, e.*
    end
  end
end

```


 The same indexes are used to speed up every loop in both implementation
 options.
 The only difference in these two query plans is the order in which
 the loops are nested.




 So which query plan is better? It turns out that the answer depends on
 what kind of data is found in the node and edge tables.




 Let the number of alice nodes be M and the number of bob nodes be N.
 Consider two scenarios. In the first scenario, M and N are both 2 but
 there are thousands of edges on each node. In this case, option 1 is
 preferred. With option 1, the inner loop checks for the existence of
 an edge between a pair of nodes and outputs the result if found. 
 Because there are only 2 alice and bob nodes each, the inner loop
 only has to run four times and the query is very quick. Option 2 would
 take much longer here. The outer loop of option 2 only executes twice,
 but because there are a large number of edges leaving each alice node,
 the middle loop has to iterate many thousands of times. It will be
 much slower. So in the first scenario, we prefer to use option 1\.




 Now consider the case where M and N are both 3500\. Alice nodes are
 abundant. This time suppose each of these nodes is connected by only one
 or two edges. Now option 2 is preferred. With option 2,
 the outer loop still has to run 3500 times, but the middle loop only
 runs once or twice for each outer loop and the inner loop will only
 run once for each middle loop, if at all. So the total number of
 iterations of the inner loop is around 7000\. Option 1, on the other
 hand, has to run both its outer loop and its middle loop 3500 times
 each, resulting in 12 million iterations of the middle loop.
 Thus in the second scenario, option 2 is nearly 2000 times faster
 than option 1\.




 So you can see that depending on how the data is structured in the table,
 either query plan 1 or query plan 2 might be better. Which plan does
 SQLite choose by default? As of version 3\.6\.18, without running [ANALYZE](lang_analyze.html),
 SQLite will choose option 2\.
 If the [ANALYZE](lang_analyze.html) command is run in order to gather statistics,
 a different choice might be made if the statistics indicate that the
 alternative is likely to run faster.



