### Special sqlite\_stat1 Handling




As of SQLite version 3\.22\.0, the "sqlite\_stat1" table is an exception to 
some of the rules above. In SQLite, the schema of sqlite\_stat1 is:
 
```

 Â      CREATE TABLE sqlite_stat1(tbl,idx,stat)  
 
```



Even though sqlite\_stat1 does not have a PRIMARY KEY, changes are 
recorded for it as if the PRIMARY KEY is (tbl,idx). Additionally, changes 
are recorded for rows for which (idx IS NULL) is true. However, for such
rows a zero\-length blob (SQL value X'') is stored in the changeset or
patchset instead of a NULL value. This allows such changesets to be
manipulated by legacy implementations of sqlite3changeset\_invert(),
concat() and similar.


The sqlite3changeset\_apply() function automatically converts the 
zero\-length blob back to a NULL value when updating the sqlite\_stat1
table. However, if the application calls sqlite3changeset\_new(),
sqlite3changeset\_old() or sqlite3changeset\_conflict on a changeset 
iterator directly (including on a changeset iterator passed to a
conflict\-handler callback) then the X'' value is returned. The application
must translate X'' to NULL itself if required.


Legacy (older than 3\.22\.0\) versions of the sessions module cannot capture
changes made to the sqlite\_stat1 table. Legacy versions of the
sqlite3changeset\_apply() function silently ignore any modifications to the
sqlite\_stat1 table that are part of a changeset or patchset.




---


