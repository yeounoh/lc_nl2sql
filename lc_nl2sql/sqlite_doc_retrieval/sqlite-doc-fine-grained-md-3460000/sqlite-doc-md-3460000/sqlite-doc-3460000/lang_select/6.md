## 2\.4\. Generation of the set of result rows


Once the input data from the FROM clause has been filtered by the
WHERE clause expression (if any), the set of result rows for the simple 
SELECT are calculated. Exactly how this is done depends on whether the simple 
SELECT is an aggregate or non\-aggregate query, and whether or not a GROUP
BY clause was specified.



 The list of expressions between the SELECT and FROM keywords is known as
the result expression list. If a result expression is the special expression
"\*" then all columns in the input data are substituted for that one expression.
If the expression is the alias of a table or subquery in the FROM clause
followed by ".\*" then all columns from the named table or subquery are
substituted for the single expression. It is an error to use a "\*" or
"alias.\*" expression in any context other than a result expression list.
It is also an error to use a "\*" or "alias.\*" expression in a simple SELECT
query that does not have a FROM clause.



 The number of columns in the rows returned by a simple SELECT statement
is equal to the number of expressions in the result expression list after
substitution of \* and alias.\* expressions. Each result row is calculated by
evaluating the expressions in the result expression list with respect to a
single row of input data or, for aggregate queries, with respect to a group
of rows.



* If the SELECT statement is **a non\-aggregate query**, then 
 each expression in the result expression list is evaluated for each row in
 the dataset filtered by the WHERE clause.
* If the SELECT statement is **an aggregate query without a GROUP
 BY** clause, then each aggregate expression in the result\-set is 
 evaluated once across the entire dataset. Each non\-aggregate expression
 in the result\-set is evaluated once for an arbitrarily selected row of
 the dataset. The same arbitrarily selected row is used for each
 non\-aggregate expression. Or, if the dataset contains zero rows, then 
 each non\-aggregate expression is evaluated against a row consisting
 entirely of NULL values.

 

The single row of result\-set data created by evaluating the aggregate
 and non\-aggregate expressions in the result\-set forms the result of an
 aggregate query without a GROUP BY clause. An aggregate query without a
 GROUP BY clause always returns exactly one row of data, even if there are
 zero rows of input data.
* If the SELECT statement is **an aggregate query with a GROUP
 BY** clause, then each of the expressions specified as part of the
 GROUP BY clause is evaluated for each row of the dataset according to
 the processing rules stated below for ORDER BY expressions. Each row
 is then assigned to a "group" based on the results; rows for which
 the results of evaluating the GROUP BY expressions are the same get
 assigned to the same group. For the purposes of grouping rows, NULL 
 values are considered equal. The usual rules for [selecting a
 collation sequence](datatype3.html#collation) with which to compare text values apply when evaluating
 expressions in a GROUP BY clause. The expressions in the GROUP BY clause
 do *not* have to be expressions that appear in the result. The
 expressions in a GROUP BY clause may not be aggregate expressions.

 
 

If a HAVING clause is specified, it is evaluated once for each group 
 of rows as a [boolean expression](lang_expr.html#booleanexpr). If the result of evaluating the
 HAVING clause is false, the group is discarded. If the HAVING clause is
 an aggregate expression, it is evaluated across all rows in the group. If
 a HAVING clause is a non\-aggregate expression, it is evaluated with respect
 to an arbitrarily selected row from the group. The HAVING expression may
 refer to values, even aggregate functions, that are not in the result.


Each expression in the result\-set is then evaluated once for each
 group of rows. If the expression is an aggregate expression, it is 
 evaluated across all rows in the group. Otherwise, it is evaluated against
 a single arbitrarily chosen row from within the group. If there is more
 than one non\-aggregate expression in the result\-set, then all such
 expressions are evaluated for the same row.

 

Each group of input dataset rows contributes a single row to the 
 set of result rows. Subject to filtering associated with the DISTINCT
 keyword, the number of rows returned by an aggregate query with a GROUP
 BY clause is the same as the number of groups of rows produced by applying
 the GROUP BY and HAVING clauses to the filtered input dataset.



