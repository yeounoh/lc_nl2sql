## 2\.1\. Determination of input data (FROM clause processing)


The input data used by a simple SELECT query is a set of *N* rows 
each *M* columns wide.



If the FROM clause is omitted from a simple SELECT statement, then the 
input data is implicitly a single row zero columns wide (i.e. *N*\=1 and
*M*\=0\).



If a FROM clause is specified, the data on which a simple SELECT query
operates comes from the one or more tables or subqueries (SELECT statements
in parentheses) specified following the FROM keyword. A subquery specified
in the table\-or\-subquery following the FROM clause in a 
simple SELECT statement is
handled as if it was a table containing the data returned by executing the
subquery statement. Each column of the subquery has the
[collation sequence](datatype3.html#collation) and [affinity](datatype3.html#affinity) of the corresponding expression
in the subquery statement.



If there is only a single table or subquery in the FROM
clause, then the input data used by the SELECT statement is the contents of the
named table. If there is more than one table or subquery in FROM clause
then the contents of all tables and/or subqueries
are joined into a single dataset for the simple SELECT statement to operate on.
Exactly how the data is combined depends on the specific [join\-operator](syntax/join-operator.html) and
[join\-constraint](syntax/join-constraint.html) used to connect the tables or subqueries together.



All joins in SQLite are based on the cartesian product of the left and
right\-hand datasets. The columns of the cartesian product dataset are, in 
order, all the columns of the left\-hand dataset followed by all the columns
of the right\-hand dataset. There is a row in the cartesian product dataset
formed by combining each unique combination of a row from the left\-hand 
and right\-hand datasets. In other words, if the left\-hand dataset consists of
*Nleft* rows of 
*Mleft* columns, and the right\-hand dataset of
*Nright* rows of
*Mright* columns, then the cartesian product is a
dataset of 
*NleftÃ—Nright*
rows, each containing 
*Mleft\+Mright* columns.



If the join\-operator is "CROSS JOIN", "INNER JOIN", "JOIN" or a comma
(",") and there is no ON or USING clause, then the result of the join is
simply the cartesian product of the left and right\-hand datasets. 
If join\-operator does have ON or USING clauses, those are handled according to
the following bullet points:



* If there is an ON clause then the ON expression is
 evaluated for each row of the cartesian product as a 
 [boolean expression](lang_expr.html#booleanexpr). Only rows for which the expression evaluates to 
 true are included from the dataset.
* If there is a USING clause
 then each of the column names specified must exist in the datasets to 
 both the left and right of the join\-operator. For each pair of named
 columns, the expression "lhs.X \= rhs.X" is evaluated for each row of
 the cartesian product as a [boolean expression](lang_expr.html#booleanexpr). Only rows for which
 all such expressions evaluates to true are included from the
 result set. When comparing values as a result of a USING clause, the
 normal rules for handling affinities, collation sequences and NULL
 values in comparisons apply. The column from the dataset on the
 left\-hand side of the join\-operator is considered to be on the left\-hand
 side of the comparison operator (\=) for the purposes of collation 
 sequence and affinity precedence.

 

For each pair of columns identified by a USING clause, the column
 from the right\-hand dataset is omitted from the joined dataset. This 
 is the only difference between a USING clause and its equivalent ON
 constraint.
* If the NATURAL keyword is in the join\-operator then an
 implicit USING clause is added to the join\-constraints. The implicit
 USING clause contains each of the column names that appear in both
 the left and right\-hand input datasets. If the left and right\-hand
 input datasets feature no common column names, then the NATURAL keyword
 has no effect on the results of the join. A USING or ON clause may
 not be added to a join that specifies the NATURAL keyword.
* If the join\-operator is a "LEFT JOIN" or "LEFT OUTER JOIN", then
 after
 the ON or USING filtering clauses have been applied, an extra row is 
 added to the output for each row in the original left\-hand input 
 dataset that does not match any row in the right\-hand dataset.
 The added rows contain NULL values in the columns
 that would normally contain values copied from the right\-hand input
 dataset.
* If the join\-operator is a "RIGHT JOIN" or "RIGHT OUTER JOIN", then
 after the ON or USING filtering clauses have been applied, an extra row is 
 added to the output for each row in the original right\-hand input 
 dataset that does not match any row in the left\-hand dataset.
 The added rows contain NULL values in the columns
 that would normally contain values copied from the left\-hand input
 dataset.
* A "FULL JOIN" or "FULL OUTER JOIN" is a combination of a
 "LEFT JOIN" and a "RIGHT JOIN". Extra rows of output are
 added for each row in left dataset that matches no rows in the right,
 and for each row in the right dataset that matches no rows in the
 left. Unmatched columns are filled in with NULL.


When more than two tables are joined together as part of a FROM clause,
the join operations are processed in order from left to right. In other 
words, the FROM clause (A join\-op\-1 B join\-op\-2 C) is computed as 
((A join\-op\-1 B) join\-op\-2 C).




