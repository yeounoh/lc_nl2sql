## 2\.5\. Bare columns in an aggregate query


The usual case is that all column names in an aggregate query are either
arguments to [aggregate functions](lang_aggfunc.html) or else appear in the GROUP BY clause.
A result column which contains a column name that is not within an
aggregate function and that does not appear in the GROUP BY clause (if
one exists) is called a "bare" column.
Example:



> ```
> 
> SELECT a, b, sum(c) FROM tab1 GROUP BY a;
> 
> ```


In the query above, the "a" column is part of the GROUP BY clause
and so each row of the output contains one of the distinct values for
"a". The "c" column is contained within the [sum()](lang_aggfunc.html#sumunc) aggregate function
and so that output column is the sum of all "c" values in rows that
have the same value for "a". But what is the result of the bare 
column "b"? The answer is that the "b" result will be the
value for "b" in one of the input rows that form the aggregate.
The problem is that you usually do not know which input row is used
to compute "b", and so in many cases the value for "b" is undefined.




Special processing occurs when the aggregate function is 
either [min()](lang_aggfunc.html#min_agg) or [max()](lang_aggfunc.html#max_agg). Example:



> ```
> 
> SELECT a, b, max(c) FROM tab1 GROUP BY a;
> 
> ```


If there is exactly one [min()](lang_aggfunc.html#max_agg) or [max()](lang_aggfunc.html#min_agg) aggregate
in the query, then all bare columns in the result set take values from an
input row which also contains the minimum or maximum. So in the query
above, the value of the "b" column in the output will be the value of
the "b" column in the input row that has the largest "c" value.
There are limitations on this special behavior of
[min()](lang_aggfunc.html#max_agg) and [max()](lang_aggfunc.html#min_agg):



1. If the same minimum or maximum value occurs on two or more rows,
then bare values might be selected from any of those rows. The choice
is arbitrary. There is no way to predict from which row the bare values
will be choosen. The choice might be different for different bare columns
within the same query.
2. If there are two or more [min()](lang_aggfunc.html#min_agg) or [max()](lang_aggfunc.html#max_agg) aggregates
in the query, then bare column values will be taken from one of the rows
on which one of the aggregates has their minimum or maximum value. The choice
of which [min()](lang_aggfunc.html#min_agg) or [max()](lang_aggfunc.html#max_agg) aggregate determines the 
selection of bare column values is arbitrary. The choice might be different
for different bare columns within the same query.
3. This special processing for [min()](lang_aggfunc.html#min_agg) or [max()](lang_aggfunc.html#max_agg) aggregates
only works for the built\-in implementation of those aggregates. If an
application overrides the built\-in [min()](lang_aggfunc.html#min_agg) or [max()](lang_aggfunc.html#max_agg) aggregates
with application\-defined alternatives, then the values selected for bare
columns will be taken from an arbitrary row.


Most other SQL database engines disallow bare columns. If you include
a bare column in a query, other database engines will usually raise an error.
The ability to include bare columns in a query is an SQLite\-specific extension.
This is considered a feature, not a bug. See the discussion on 
[SQLite Forum thread 7481d2a6df8980ff](https://sqlite.org/forum/forumpost/7481d2a6df8980ff)
for additional information.



