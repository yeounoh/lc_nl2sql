## 3\.0 The Memory Allocation Subsystem


 Beginning with version 3\.5, SQLite obtains all of the heap memory it
 needs using the routines [sqlite3\_malloc()](c3ref/free.html), [sqlite3\_free()](c3ref/free.html), and
 [sqlite3\_realloc()](c3ref/free.html). These routines have existed in prior versions
 of SQLite, but SQLite has previously bypassed these routines and used
 its own memory allocator. This all changes in version 3\.5\.0\.




 The SQLite source tree actually contains multiple versions of the
 memory allocator. The default high\-speed version found in the
 "mem1\.c" source file is used for most builds. But if the SQLITE\_MEMDEBUG
 flag is enabled, a separate memory allocator the "mem2\.c" source file
 is used instead. The mem2\.c allocator implements lots of hooks to
 do error checking and to simulate memory allocation failures for testing
 purposes. Both of these allocators use the malloc()/free() implementation
 in the standard C library.




 Applications are not required to use either of these standard memory
 allocators. If SQLite is compiled with [SQLITE\_OMIT\_MEMORY\_ALLOCATION](compile.html#omitfeatures)
 then no implementation for the [sqlite3\_malloc()](c3ref/free.html), [sqlite3\_realloc()](c3ref/free.html),
 and [sqlite3\_free()](c3ref/free.html) functions is provided. Instead, the application
 that links against SQLite must provide its own implementation of these
 functions. The application provided memory allocator is not required
 to use the malloc()/free() implementation in the standard C library.
 An embedded application might provide an alternative memory allocator
 that uses memory for a fixed memory pool set aside for the exclusive
 use of SQLite, for example.




 Applications that implement their own memory allocator must provide
 implementation for the usual three allocation functions 
 [sqlite3\_malloc()](c3ref/free.html), [sqlite3\_realloc()](c3ref/free.html), and [sqlite3\_free()](c3ref/free.html).
 And they must also implement a fourth function:




> ```
> 
> int sqlite3_memory_alarm(
>   void(*xCallback)(void *pArg, sqlite3_int64 used, int N),
>   void *pArg,
>   sqlite3_int64 iThreshold
> );
> 
> ```


 The [sqlite3\_memory\_alarm](c3ref/aggregate_count.html) routine is used to register
 a callback on memory allocation events.
 This routine registers or clears a callback that fires when
 the amount of memory allocated exceeds iThreshold. Only
 a single callback can be registered at a time. Each call
 to [sqlite3\_memory\_alarm()](c3ref/aggregate_count.html) overwrites the previous callback.
 The callback is disabled by setting xCallback to a NULL
 pointer.




 The parameters to the callback are the pArg value, the 
 amount of memory currently in use, and the size of the
 allocation that provoked the callback. The callback will
 presumably invoke [sqlite3\_free()](c3ref/free.html) to free up memory space.
 The callback may invoke [sqlite3\_malloc()](c3ref/free.html) or [sqlite3\_realloc()](c3ref/free.html)
 but if it does, no additional callbacks will be invoked by
 the recursive calls.




 The [sqlite3\_soft\_heap\_limit()](c3ref/soft_heap_limit.html) interface works by registering
 a memory alarm at the soft heap limit and invoking 
 [sqlite3\_release\_memory()](c3ref/release_memory.html) in the alarm callback. Application
 programs should not attempt to use the [sqlite3\_memory\_alarm()](c3ref/aggregate_count.html)
 interface because doing so will interfere with the
 [sqlite3\_soft\_heap\_limit()](c3ref/soft_heap_limit.html) module. This interface is exposed
 only so that applications can provide their own
 alternative implementation when the SQLite core is
 compiled with [SQLITE\_OMIT\_MEMORY\_ALLOCATION](compile.html#omitfeatures).




 The built\-in memory allocators in SQLite also provide the following
 additional interfaces:




> ```
> 
> sqlite3_int64 sqlite3_memory_used(void);
> sqlite3_int64 sqlite3_memory_highwater(int resetFlag);
> 
> ```


 These interfaces can be used by an application to monitor how
 much memory SQLite is using. The [sqlite3\_memory\_used()](c3ref/memory_highwater.html) routine
 returns the number of bytes of memory currently in use and the
 [sqlite3\_memory\_highwater()](c3ref/memory_highwater.html) returns the maximum instantaneous
 memory usage. Neither routine includes the overhead associated
 with the memory allocator. These routines are provided for use
 by the application. SQLite never invokes them itself. So if
 the application is providing its own memory allocation subsystem,
 it can omit these interfaces if desired.



