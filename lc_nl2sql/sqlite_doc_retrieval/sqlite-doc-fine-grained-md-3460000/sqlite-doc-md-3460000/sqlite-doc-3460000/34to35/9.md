#### 2\.1\.5 The Open File Object


 The result of opening a file is an instance of an [sqlite3\_file](c3ref/file.html) object.
 The [sqlite3\_file](c3ref/file.html) object is an abstract base class defined as follows:




> ```
> 
> typedef struct sqlite3_file sqlite3_file;
> struct sqlite3_file {
>   const struct sqlite3_io_methods *pMethods;
> };
> 
> ```


 Each VFS implementation will subclass the [sqlite3\_file](c3ref/file.html) by adding
 additional fields at the end to hold whatever information the VFS
 needs to know about an open file. It does not matter what information
 is stored as long as the total size of the structure does not exceed
 the szOsFile value recorded in the [sqlite3\_vfs](c3ref/vfs.html) object.




 The [sqlite3\_io\_methods](c3ref/io_methods.html) object is a structure that contains pointers
 to methods for reading, writing, and otherwise dealing with files.
 This object is defined as follows:




> ```
> 
> typedef struct sqlite3_io_methods sqlite3_io_methods;
> struct sqlite3_io_methods {
>   int iVersion;
>   int (*xClose)(sqlite3_file*);
>   int (*xRead)(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);
>   int (*xWrite)(sqlite3_file*, const void*, int iAmt, sqlite3_int64 iOfst);
>   int (*xTruncate)(sqlite3_file*, sqlite3_int64 size);
>   int (*xSync)(sqlite3_file*, int flags);
>   int (*xFileSize)(sqlite3_file*, sqlite3_int64 *pSize);
>   int (*xLock)(sqlite3_file*, int);
>   int (*xUnlock)(sqlite3_file*, int);
>   int (*xCheckReservedLock)(sqlite3_file*);
>   int (*xFileControl)(sqlite3_file*, int op, void *pArg);
>   int (*xSectorSize)(sqlite3_file*);
>   int (*xDeviceCharacteristics)(sqlite3_file*);
>   /* Additional methods may be added in future releases */
> };
> 
> ```


 The iVersion field of [sqlite3\_io\_methods](c3ref/io_methods.html) is provided as insurance
 against future enhancements. The iVersion value should always be
 1 for SQLite version 3\.5\.




 The xClose method closes the file. The space for the [sqlite3\_file](c3ref/file.html)
 structure is deallocated by the caller. But if the [sqlite3\_file](c3ref/file.html)
 contains pointers to other allocated memory or resources, those
 allocations should be released by the xClose method.




 The xRead method reads iAmt bytes from the file beginning at a byte
 offset to iOfst. The data read is stored in the pointer of the
 second parameter. xRead returns the [SQLITE\_OK](rescode.html#ok) on success,
 [SQLITE\_IOERR\_SHORT\_READ](rescode.html#ioerr_short_read) if it was not able to read the full number
 of bytes because it reached end\-of\-file, or [SQLITE\_IOERR\_READ](rescode.html#ioerr_read) for
 any other error.




 The xWrite method writes iAmt bytes of data from the second parameter
 into the file beginning at an offset of iOfst bytes. If the size of
 the file is less than iOfst bytes prior to the write, then xWrite should
 ensure that the file is extended with zeros up to iOfst bytes prior
 to beginning its write. xWrite continues to extends the file as
 necessary so that the size of the file is at least iAmt\+iOfst bytes 
 at the conclusion of the xWrite call. The xWrite method returns
 [SQLITE\_OK](rescode.html#ok) on success. If the write cannot complete because the
 underlying storage medium is full, then [SQLITE\_FULL](rescode.html#full) is returned.
 [SQLITE\_IOERR\_WRITE](rescode.html#ioerr_write) should be returned for any other error.




 The xTruncate method truncates a file to be nByte bytes in length.
 If the file is already nByte bytes or less in length then this
 method is a no\-op. The xTruncate method returns [SQLITE\_OK](rescode.html#ok) on
 success and [SQLITE\_IOERR\_TRUNCATE](rescode.html#ioerr_truncate) if anything goes wrong.




 The xSync method is used to force previously written data out of
 operating system cache and into non\-volatile memory. The second
 parameter is usually [SQLITE\_SYNC\_NORMAL](c3ref/c_sync_dataonly.html). If the second parameter
 is [SQLITE\_SYNC\_FULL](c3ref/c_sync_dataonly.html) then the xSync method should make sure that
 data has also been flushed through the disk controllers cache.
 The [SQLITE\_SYNC\_FULL](c3ref/c_sync_dataonly.html) parameter is the equivalent of the F\_FULLSYNC
 ioctl() on Mac OS X. The xSync method returns
 [SQLITE\_OK](rescode.html#ok) on success and [SQLITE\_IOERR\_FSYNC](rescode.html#ioerr_fsync) if anything goes wrong.




 The xFileSize() method determines the current size of the file
 in bytes and writes that value into \*pSize. It returns [SQLITE\_OK](rescode.html#ok)
 on success and [SQLITE\_IOERR\_FSTAT](rescode.html#ioerr_fstat) if something goes wrong.




 The xLock and xUnlock methods are used to set and clear file locks.
 SQLite supports five levels of file locks, in order:
 * [SQLITE\_LOCK\_NONE](c3ref/c_lock_exclusive.html)* [SQLITE\_LOCK\_SHARED](c3ref/c_lock_exclusive.html)* [SQLITE\_LOCK\_RESERVED](c3ref/c_lock_exclusive.html)* [SQLITE\_LOCK\_PENDING](c3ref/c_lock_exclusive.html)* [SQLITE\_LOCK\_EXCLUSIVE](c3ref/c_lock_exclusive.html)


 The underlying implementation can support some subset of these locking
 levels as long as it meets the other requirements of this paragraph.
 The locking level is specified as the second argument to both xLock
 and xUnlock. The xLock method increases the locking level to the
 specified locking level or higher. The xUnlock method decreases the
 locking level to no lower than the level specified. 
 [SQLITE\_LOCK\_NONE](c3ref/c_lock_exclusive.html) means that the file is unlocked. [SQLITE\_LOCK\_SHARED](c3ref/c_lock_exclusive.html)
 gives permission to read the file. Multiple database connections can
 hold [SQLITE\_LOCK\_SHARED](c3ref/c_lock_exclusive.html) at the same time.
 [SQLITE\_LOCK\_RESERVED](c3ref/c_lock_exclusive.html) is like [SQLITE\_LOCK\_SHARED](c3ref/c_lock_exclusive.html) in that it is permission
 to read the file. But only a single connection can hold a reserved lock
 at any point in time. The [SQLITE\_LOCK\_PENDING](c3ref/c_lock_exclusive.html) is also permission to
 read the file. Other connections can continue to read the file as well,
 but no other connection is allowed to escalate a lock from none to shared.
 [SQLITE\_LOCK\_EXCLUSIVE](c3ref/c_lock_exclusive.html) is permission to write on the file. Only a single
 connection can hold an exclusive lock and no other connection can hold
 any lock (other than "none") while one connection holds an exclusive
 lock. The xLock returns [SQLITE\_OK](rescode.html#ok) on success, [SQLITE\_BUSY](rescode.html#busy) if it
 is unable to obtain the lock, or [SQLITE\_IOERR\_RDLOCK](rescode.html#ioerr_rdlock) if something else
 goes wrong. The xUnlock method returns [SQLITE\_OK](rescode.html#ok) on success and
 [SQLITE\_IOERR\_UNLOCK](rescode.html#ioerr_unlock) for problems.




 The xCheckReservedLock() method checks to see if another connection or
 another process is currently holding a reserved, pending, or exclusive
 lock on the file. It returns true or false.




 The xFileControl() method is a generic interface that allows custom
 VFS implementations to directly control an open file using the
 (new and experimental)
 [sqlite3\_file\_control()](c3ref/file_control.html) interface. The second "op" argument
 is an integer opcode. The third
 argument is a generic pointer which is intended to be a pointer
 to a structure that may contain arguments or space in which to
 write return values. Potential uses for xFileControl() might be
 functions to enable blocking locks with timeouts, to change the
 locking strategy (for example to use dot\-file locks), to inquire
 about the status of a lock, or to break stale locks. The SQLite
 core reserves opcodes less than 100 for its own use. 
 A [list of opcodes](c3ref/c_fcntl_begin_atomic_write.html#sqlitefcntllockstate) less than 100 is available.
 Applications that define a custom xFileControl method should use opcodes 
 greater than 100 to avoid conflicts.




 The xSectorSize returns the "sector size" of the underlying
 non\-volatile media. A "sector" is defined as the smallest unit of
 storage that can be written without disturbing adjacent storage.
 On a disk drive the "sector size" has until recently been 512 bytes,
 though there is a push to increase this value to 4KiB. SQLite needs
 to know the sector size so that it can write a full sector at a
 time, and thus avoid corrupting adjacent storage space if a power
 loss occurs in the middle of a write.




 The xDeviceCharacteristics method returns an integer bit vector that
 defines any special properties that the underlying storage medium might
 have that SQLite can use to increase performance. The allowed return
 is the bit\-wise OR of the following values:
 * [SQLITE\_IOCAP\_ATOMIC](c3ref/c_iocap_atomic.html)* [SQLITE\_IOCAP\_ATOMIC512](c3ref/c_iocap_atomic.html)* [SQLITE\_IOCAP\_ATOMIC1K](c3ref/c_iocap_atomic.html)* [SQLITE\_IOCAP\_ATOMIC2K](c3ref/c_iocap_atomic.html)* [SQLITE\_IOCAP\_ATOMIC4K](c3ref/c_iocap_atomic.html)* [SQLITE\_IOCAP\_ATOMIC8K](c3ref/c_iocap_atomic.html)* [SQLITE\_IOCAP\_ATOMIC16K](c3ref/c_iocap_atomic.html)* [SQLITE\_IOCAP\_ATOMIC32K](c3ref/c_iocap_atomic.html)* [SQLITE\_IOCAP\_ATOMIC64K](c3ref/c_iocap_atomic.html)* [SQLITE\_IOCAP\_SAFE\_APPEND](c3ref/c_iocap_atomic.html)* [SQLITE\_IOCAP\_SEQUENTIAL](c3ref/c_iocap_atomic.html)


 The [SQLITE\_IOCAP\_ATOMIC](c3ref/c_iocap_atomic.html) bit means that all writes to this device are
 atomic in the sense that either the entire write occurs or none of it
 occurs. The other 
 [SQLITE\_IOCAP\_ATOMIC*nnn*](c3ref/c_iocap_atomic.html) values indicate that
 writes of aligned blocks of the indicated size are atomic.
 [SQLITE\_IOCAP\_SAFE\_APPEND](c3ref/c_iocap_atomic.html) means that when extending a file with new
 data, the new data is written first and then the file size is updated.
 So if a power failure occurs, there is no chance that the file might have
 been extended with randomness. The [SQLITE\_IOCAP\_SEQUENTIAL](c3ref/c_iocap_atomic.html) bit means
 that all writes occur in the order that they are issued and are not
 reordered by the underlying file system.



