# 7\. Making Other Kinds Of Table Schema Changes


 The only schema altering commands directly supported by SQLite are the
"[rename table](lang_altertable.html#altertabrename)", "[rename column](lang_altertable.html#altertabmvcol)", "[add column](lang_altertable.html#altertabaddcol)", "[drop column](lang_altertable.html#altertabdropcol)"
commands shown above. However, applications
can make other arbitrary changes to the format of a table using a simple
sequence of operations.
The steps to make arbitrary changes to the schema design of some table X
are as follows:



1. If foreign key constraints are enabled, disable them using [PRAGMA foreign\_keys\=OFF](pragma.html#pragma_foreign_keys).
2. Start a transaction.
3. Remember the format of all indexes, triggers, and views associated with table X.
This information will be needed in step 8 below. One way to do this is
to run a query like the following:
SELECT type, sql FROM sqlite\_schema WHERE tbl\_name\='X'.
4. Use [CREATE TABLE](lang_createtable.html) to construct a new table "new\_X" that is in the desired
revised format of table X. Make sure that the name "new\_X" does not collide
with any existing table name, of course.
5. Transfer content from X into new\_X using a statement
like: INSERT INTO new\_X SELECT ... FROM X.
6. Drop the old table X: [DROP TABLE X](lang_droptable.html).
7. Change the name of new\_X to X using: ALTER TABLE new\_X RENAME TO X.
8. Use [CREATE INDEX](lang_createindex.html), [CREATE TRIGGER](lang_createtrigger.html), and [CREATE VIEW](lang_createview.html)
to reconstruct indexes, triggers, and views
associated with table X. Perhaps use the old format of the triggers,
indexes, and views saved from step 3 above as a guide, making changes
as appropriate for the alteration.
9. If any views refer to table X in a way that is affected by the
schema change, then drop those views using [DROP VIEW](lang_dropview.html) and recreate them
with whatever changes are necessary to accommodate the schema change
using [CREATE VIEW](lang_createview.html).
10. If foreign key constraints were originally enabled
then run [PRAGMA foreign\_key\_check](pragma.html#pragma_foreign_key_check) to verify that the schema
change did not break any foreign key constraints.
11. Commit the transaction started in step 2\.
12. If foreign keys constraints were originally enabled, reenable them now.




**Caution:**
Take care to follow the procedure above precisely. The boxes below
summarize two procedures for modifying a table definition. At first
glance, they both appear to accomplish the same thing. However, the
procedure on the right does not always work, especially with the
enhanced [rename table](lang_altertable.html#altertabrename) capabilities added by versions 3\.25\.0 and
3\.26\.0\. In the procedure on the right, the initial rename of the
table to a temporary name might corrupt references to that table in
triggers, views, and foreign key constraints. The safe procedure on
the left constructs the revised table definition using a new temporary
name, then renames the table into its final name, which does not break
links.






| 1. Create new table 2. Copy data 3. Drop old table 4. Rename new into old | 1. Rename old table 2. Create new table 3. Copy data 4. Drop old table |
| --- | --- |
| ↑Correct | ↑Incorrect |



The 12\-step [generalized ALTER TABLE procedure](lang_altertable.html#otheralter)
above will work even if the
schema change causes the information stored in the table to change.
So the full 12\-step procedure above is appropriate for dropping a column,
changing the order of columns, adding or removing a UNIQUE constraint
or PRIMARY KEY, adding CHECK or FOREIGN KEY or NOT NULL constraints,
or changing the datatype for a column, for example. However, a simpler
and faster procedure can optionally be used for
some changes that do no affect the on\-disk content in any way.
The following simpler procedure is appropriate for removing
CHECK or FOREIGN KEY or NOT NULL constraints,
or adding, removing, or changing default values on
a column.



1. Start a transaction.
2. Run [PRAGMA schema\_version](pragma.html#pragma_schema_version) to determine the current schema
version number. This number will be needed for step 6 below.
3. Activate schema editing using 
[PRAGMA writable\_schema\=ON](pragma.html#pragma_writable_schema).
4. Run an [UPDATE](lang_update.html) statement to change the definition of table X
in the [sqlite\_schema table](schematab.html): 
UPDATE sqlite\_schema SET sql\=... WHERE type\='table' AND name\='X';


*Caution:* Making a change to the sqlite\_schema table like this will
render the database corrupt and unreadable if the change contains
a syntax error. It is suggested that careful testing of the UPDATE
statement be done on a separate blank database prior to using it on
a database containing important data.
5. If the change to table X also affects other tables or indexes or
triggers are views within schema, then run [UPDATE](lang_update.html) statements to modify
those other tables indexes and views too. For example, if the name of
a column changes, all FOREIGN KEY constraints, triggers, indexes, and
views that refer to that column must be modified.


*Caution:* Once again, making changes to the sqlite\_schema 
table like this will render the database corrupt and unreadable if the 
change contains an error. Carefully test this entire procedure
on a separate test database prior to using it on
a database containing important data and/or make backup copies of
important databases prior to running this procedure.
6. Increment the schema version number using
[PRAGMA schema\_version\=X](pragma.html#pragma_schema_version) where X is one
more than the old schema version number found in step 2 above.
7. Disable schema editing using 
[PRAGMA writable\_schema\=OFF](pragma.html#pragma_writable_schema).
8. (Optional) Run [PRAGMA integrity\_check](pragma.html#pragma_integrity_check) to verify that the
schema changes did not damage the database.
9. Commit the transaction started on step 1 above.


If some future version of SQLite adds new ALTER TABLE capabilities, 
those capabilities will very likely use one of the two procedures
outlined above.




