# 1\. Introduction to Foreign Key Constraints



 SQL foreign key constraints are used to enforce "exists" relationships 
 between tables. For example, consider a database schema created using 
 the following SQL commands:




```
CREATE TABLE artist(
  artistid    INTEGER PRIMARY KEY, 
  artistname  TEXT
);
CREATE TABLE track(
  trackid     INTEGER,
  trackname   TEXT, 
  trackartist INTEGER     -- Must map to an artist.artistid!
);

```


 The applications using this database are entitled to assume that for
 each row in the *track* table there exists a corresponding row in the
 *artist* table. After all, the comment in the declaration says so.
 Unfortunately, if a user edits the database using an external tool or 
 if there is a bug in an application, rows might be inserted into the 
 *track* table that do not correspond to any row in the *artist*
 table. Or rows might be deleted from the *artist* table, leaving
 orphaned rows in the *track* table that do not correspond to any of
 the remaining rows in *artist*. This might cause the application
 or applications to malfunction later on, or at least make coding the
 application more difficult.

 


 One solution is to add an SQL foreign key constraint to the database 
 schema to enforce the relationship between the *artist* and 
 *track* table. To do so, a foreign key definition may be added
 by modifying the declaration of the *track* table to the following:




```
CREATE TABLE track(
  trackid     INTEGER, 
  trackname   TEXT, 
  trackartist INTEGER,
  FOREIGN KEY(trackartist) REFERENCES artist(artistid)
);

```


 This way, the constraint is enforced by SQLite. Attempting to insert
 a row into the *track* table that does not correspond to any
 row in the *artist* table will fail, as will attempting to
 delete a row from the *artist* table when there exist dependent 
 rows in the *track* table There is one exception: if the foreign
 key column in the *track* table is NULL, then no corresponding
 entry in the *artist* table is required. Expressed in SQL, this
 means that for every row in the *track* table, the following
 expression evaluates to true:



```
trackartist IS NULL OR EXISTS(SELECT 1 FROM artist WHERE artistid=trackartist)

```

Tip: If the application requires a stricter relationship between 
 *artist* and *track*, where NULL values are not permitted 
 in the *trackartist* column, simply add the appropriate 
 "NOT NULL" constraint to the schema.

 

There are several other ways to add an equivalent foreign key declaration 
 to a [CREATE TABLE](lang_createtable.html) statement. Refer to the 
 [CREATE TABLE documentation](lang_createtable.html) for details.

 

The following SQLite command\-line session illustrates the effect of the
 foreign key constraint added to the *track* table:




```
sqlite> SELECT * FROM artist;
artistid  artistname       
--------  -----------------
1         Dean Martin      
2         Frank Sinatra    

sqlite> SELECT * FROM track;
trackid  trackname          trackartist
-------  -----------------  -----------
11       That's Amore       1  
12       Christmas Blues    1  
13       My Way             2  

sqlite> -- This fails because the value inserted into the trackartist column (3)
sqlite> -- does not correspond to row in the artist table.
sqlite> INSERT INTO track VALUES(14, 'Mr. Bojangles', 3);
SQL error: foreign key constraint failed

sqlite> -- This succeeds because a NULL is inserted into trackartist. A
sqlite> -- corresponding row in the artist table is not required in this case.
sqlite> INSERT INTO track VALUES(14, 'Mr. Bojangles', NULL);

sqlite> -- Trying to modify the trackartist field of the record after it has 
sqlite> -- been inserted does not work either, since the new value of trackartist (3)
sqlite> -- Still does not correspond to any row in the artist table.
sqlite> UPDATE track SET trackartist = 3 WHERE trackname = 'Mr. Bojangles';
SQL error: foreign key constraint failed

sqlite> -- Insert the required row into the artist table. It is then possible to
sqlite> -- update the inserted row to set trackartist to 3 (since a corresponding
sqlite> -- row in the artist table now exists).
sqlite> INSERT INTO artist VALUES(3, 'Sammy Davis Jr.');
sqlite> UPDATE track SET trackartist = 3 WHERE trackname = 'Mr. Bojangles';

sqlite> -- Now that "Sammy Davis Jr." (artistid = 3) has been added to the database,
sqlite> -- it is possible to INSERT new tracks using this artist without violating
sqlite> -- the foreign key constraint:
sqlite> INSERT INTO track VALUES(15, 'Boogie Woogie', 3);

```


 As you would expect, it is not possible to manipulate the database to a state
 that violates the foreign key constraint by deleting or updating rows in the 
 *artist* table either:



```
sqlite> -- Attempting to delete the artist record for "Frank Sinatra" fails, since
sqlite> -- the track table contains a row that refer to it.
sqlite> DELETE FROM artist WHERE artistname = 'Frank Sinatra';
SQL error: foreign key constraint failed

sqlite> -- Delete all the records from the track table that refer to the artist
sqlite> -- "Frank Sinatra". Only then is it possible to delete the artist.
sqlite> DELETE FROM track WHERE trackname = 'My Way';
sqlite> DELETE FROM artist WHERE artistname = 'Frank Sinatra';

sqlite> -- Try to update the artistid of a row in the artist table while there
sqlite> -- exists records in the track table that refer to it. 
sqlite> UPDATE artist SET artistid=4 WHERE artistname = 'Dean Martin';
SQL error: foreign key constraint failed

sqlite> -- Once all the records that refer to a row in the artist table have
sqlite> -- been deleted, it is possible to modify the artistid of the row.
sqlite> DELETE FROM track WHERE trackname IN('That''s Amore', 'Christmas Blues');
sqlite> UPDATE artist SET artistid=4 WHERE artistname = 'Dean Martin';

```


 SQLite uses the following terminology:



* The **parent table** is the table that a foreign key constraint
 refers to. The parent table in the example in this section is the
 *artist* table. Some books and articles refer to this as the
 *referenced table*, which is arguably more correct, but tends
 to lead to confusion.
* The **child table** is the table that a foreign key constraint
 is applied to and the table that contains the REFERENCES clause.
 The example in this section uses the *track* table
 as the child table. Other books and articles refer to this as the
 *referencing table*.
* The **parent key** is the column or set of columns in the parent 
 table that the foreign key constraint refers to. This is normally, but
 not always, the primary key of the parent table. The parent key must
 be a named column or columns in the parent table, not the [rowid](lang_createtable.html#rowid).
* The **child key** is the column or set of columns in the child 
 table that are constrained by the foreign key constraint and which
 hold the REFERENCES clause.



 The foreign key constraint is satisfied if for each row in the child table 
 either one or more of the child key columns are NULL, or there exists a 
 row in the parent table for which each parent key column contains a value
 equal to the value in its associated child key column.

 


 In the above paragraph, the term "equal" means equal when values are 
 compared using the rules [specified 
 here](datatype3.html#comparisons). The following clarifications apply:
 
 

* When comparing text values, the [collating sequence](datatype3.html#collation)
 associated with the parent key column is always used.
* When comparing values, if the parent key column has an [affinity](datatype3.html#affinity),
 then that affinity is applied to the child key value before the
 comparison is performed.



