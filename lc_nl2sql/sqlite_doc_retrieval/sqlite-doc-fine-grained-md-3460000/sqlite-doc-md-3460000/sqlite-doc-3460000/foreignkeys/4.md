# 3\. Required and Suggested Database Indexes



 Usually, the parent key of a foreign key constraint is the primary key of
 the parent table. If they are not the primary key, then the parent key
 columns must be collectively subject to a UNIQUE constraint or have
 a UNIQUE index. 
 If the parent key columns have a UNIQUE index,
 then that index must use the collation sequences that are specified
 in the CREATE TABLE statement for the parent table.
 For example,




```
CREATE TABLE parent(a PRIMARY KEY, b UNIQUE, c, d, e, f);
CREATE UNIQUE INDEX i1 ON parent(c, d);
CREATE INDEX i2 ON parent(e);
CREATE UNIQUE INDEX i3 ON parent(f COLLATE nocase);

CREATE TABLE child1(f, g REFERENCES parent(a));                        -- Ok
CREATE TABLE child2(h, i REFERENCES parent(b));                        -- Ok
CREATE TABLE child3(j, k, FOREIGN KEY(j, k) REFERENCES parent(c, d));  -- Ok
CREATE TABLE child4(l, m REFERENCES parent(e));                        -- Error!
CREATE TABLE child5(n, o REFERENCES parent(f));                        -- Error!
CREATE TABLE child6(p, q, FOREIGN KEY(p, q) REFERENCES parent(b, c));  -- Error!
CREATE TABLE child7(r REFERENCES parent(c));                           -- Error!

```


 The foreign key constraints created as part of tables *child1*, 
 *child2* and *child3* are all fine. The foreign key
 declared as part of table *child4* is an error because even though
 the parent key column is indexed, the index is not UNIQUE.
 The foreign key for table *child5*
 is an error because even though the parent key column has a unique
 index, the index uses a different collating sequence.
 Tables *child6* and *child7* are incorrect because while
 both have UNIQUE indices on their parent keys, the keys are not an
 exact match to the columns of a single UNIQUE index.

 


 If the database schema contains foreign key errors that require looking
 at more than one table definition to identify, then those errors are not
 detected when the tables are created. Instead, such errors prevent
 the application from preparing SQL statements that modify the content
 of the child or parent tables in ways that use the foreign keys.
 Errors reported when content is changed are "DML errors" and errors
 reported when the schema is changed are "DDL errors".
 So, in other words, misconfigured foreign key constraints that require
 looking at both the child and parent are DML errors.
 The English language error message for foreign key DML errors is usually
 "foreign key mismatch" but can also be "no such table" if the parent
 table does not exist.
 Foreign key DML errors are reported if:

 

* The parent table does not exist, or
* The parent key columns named in the foreign key constraint do
 not exist, or
* The parent key columns named in the foreign key constraint are not
 the primary key of the parent table and are not subject to a unique
 constraint using collating sequence specified in the CREATE TABLE, or
* The child table references the primary key of the parent without
 specifying the primary key columns and the number of primary key
 columns in the parent do not match the number of child key columns.



 The last bullet above is illustrated by the following:




```
CREATE TABLE parent2(a, b, PRIMARY KEY(a,b));

CREATE TABLE child8(x, y, FOREIGN KEY(x,y) REFERENCES parent2);        -- Ok
CREATE TABLE child9(x REFERENCES parent2);                             -- Error!
CREATE TABLE child10(x,y,z, FOREIGN KEY(x,y,z) REFERENCES parent2);    -- Error!

```


 By contrast, if foreign key errors can be recognized simply by looking
 at the definition of the child table and without having to consult the
 parent table definition, then the 
 [CREATE TABLE](lang_createtable.html) statement for the child table fails. Because the error
 occurs during a schema change, this is a DDL error.
 Foreign key DDL errors are reported regardless of
 whether or not foreign key constraints are enabled when the
 table is created.

 


 Indices are not required for child key columns but they are almost
 always beneficial. Returning to
 the example in [section 1](#fk_basics), each time an application
 deletes a row from the *artist* table (the parent table), it
 performs the equivalent of the following SELECT statement to search
 for referencing rows in the *track* table (the child table).




```
SELECT rowid FROM track WHERE trackartist = ?

```


 where ? in the above is replaced with the value of the *artistid*
 column of the record being deleted from the *artist* table (recall
 that the *trackartist* column is the child key and the *artistid*
 column is the parent key). Or, more generally:




```
SELECT rowid FROM <child-table> WHERE <child-key> = :parent_key_value

```


 If this SELECT returns any rows at all, then SQLite concludes that
 deleting the row from the parent table would violate the foreign key
 constraint and returns an error.
 Similar queries may be run if the content of the parent key
 is modified or a new row is inserted into the parent table.
 If these queries cannot use an index, they are forced to do a
 linear scan of the entire child table. In a non\-trivial database, this may
 be prohibitively expensive.

 


 So, in most real systems, an index should be created on the child key columns
 of each foreign key constraint. The child key index does not have
 to be (and usually will not be) a UNIQUE index.
 Returning again to the example in section 1, the
 complete database schema for efficient implementation of the foreign key 
 constraint might be:




```
CREATE TABLE artist(
  artistid    INTEGER PRIMARY KEY, 
  artistname  TEXT
);
CREATE TABLE track(
  trackid     INTEGER,
  trackname   TEXT, 
  trackartist INTEGER REFERENCES artist
);
CREATE INDEX trackindex ON track(trackartist);

```


 The block above uses a shorthand form to create the foreign key constraint.
 Attaching a "REFERENCES *\<parent\-table\>*" clause to a column
 definition creates a foreign key constraint that maps the column to the
 primary key of *\<parent\-table\>*. Refer to the [CREATE TABLE](lang_createtable.html) 
 documentation for further details.




