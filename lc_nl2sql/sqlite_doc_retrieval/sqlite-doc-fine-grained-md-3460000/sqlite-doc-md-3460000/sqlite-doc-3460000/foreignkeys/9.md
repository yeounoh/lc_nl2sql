# 5\. CREATE, ALTER and DROP TABLE commands



 This section describes the way the [CREATE TABLE](lang_createtable.html), [ALTER TABLE](lang_altertable.html),
 and [DROP TABLE](lang_droptable.html) commands
 interact with SQLite's foreign keys.

 


 A [CREATE TABLE](lang_createtable.html) command operates the same whether or not
 [foreign key constraints are enabled](foreignkeys.html#fk_enable). The parent key definitions of 
 foreign key constraints are not checked when a table is created. There is
 nothing stopping the user from creating a foreign key definition that
 refers to a parent table that does not exist, or to parent key columns that
 do not exist or are not collectively bound by a PRIMARY KEY or UNIQUE
 constraint.

 


 The [ALTER TABLE](lang_altertable.html) command works differently in two respects when foreign
 key constraints are enabled:

 

* It is not possible to use the "ALTER TABLE ... ADD COLUMN" syntax
 to add a column that includes a REFERENCES clause, unless the default
 value of the new column is NULL. Attempting to do so returns an
 error.
* If an "ALTER TABLE ... RENAME TO" command is used to rename a table
 that is the parent table of one or more foreign key constraints, the
 definitions of the foreign key constraints are modified to refer to
 the parent table by its new name. The text of the child CREATE
 TABLE statement or statements stored in the [sqlite\_schema table](schematab.html) are 
 modified to reflect the new parent table name.



 If foreign key constraints are enabled when it is prepared, the 
 [DROP TABLE](lang_droptable.html) command performs an implicit [DELETE](lang_delete.html) to remove all
 rows from the table before dropping it. The implicit DELETE does not cause
 any SQL triggers to fire, but may invoke foreign key actions or constraint
 violations. If an immediate foreign key constraint is violated, the DROP
 TABLE statement fails and the table is not dropped. If a deferred foreign
 key constraint is violated, then an error is reported when the user attempts
 to commit the transaction if the foreign key constraint violations still
 exist at that point. Any "foreign key mismatch" errors encountered as part 
 of an implicit DELETE are ignored.

 


 The intent of these enhancements to the [ALTER TABLE](lang_altertable.html) and [DROP TABLE](lang_droptable.html)
 commands is to ensure that they cannot be used to create a database that
 contains foreign key violations, at least while foreign key constraints are
 enabled. There is one exception to this rule though. If a parent key is
 not subject to a PRIMARY KEY or UNIQUE constraint created as part of the
 parent table definition, but is subject to a UNIQUE constraint by virtue
 of an index created using the [CREATE INDEX](lang_createindex.html) command, then the child 
 table may be populated without causing a "foreign key mismatch" error. If
 the UNIQUE index is dropped from the database schema, then the parent table
 itself is dropped, no error will be reported. However the database may be
 left in a state where the child table of the foreign key constraint contains
 rows that do not refer to any parent table row. This case can be avoided
 if all parent keys in the database schema are constrained by PRIMARY KEY
 or UNIQUE constraints added as part of the parent table definition, not
 by external UNIQUE indexes.

 


 The properties of the [DROP TABLE](lang_droptable.html) and [ALTER TABLE](lang_altertable.html) commands described
 above only apply if foreign keys are enabled. If the user considers them
 undesirable, then the workaround is to use [PRAGMA foreign\_keys](pragma.html#pragma_foreign_keys) to 
 disable foreign key constraints before executing the DROP or ALTER TABLE 
 command. Of course, while foreign key constraints are disabled, there is nothing
 to stop the user from violating foreign key constraints and thus creating
 an internally inconsistent database.
 
 



