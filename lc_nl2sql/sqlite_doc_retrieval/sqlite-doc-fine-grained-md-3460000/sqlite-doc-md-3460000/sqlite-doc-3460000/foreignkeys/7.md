## 4\.2\. Deferred Foreign Key Constraints



 Each foreign key constraint in SQLite is classified as either immediate
 or deferred. Foreign key constraints are immediate by default.
 All the foreign key examples presented
 so far have been of immediate foreign key constraints.

 


 If a statement modifies the contents of the database so that an immediate 
 foreign key constraint is in violation at the conclusion the statement, 
 an exception is thrown and 
 the effects of the statement are reverted. By contrast, if
 a statement modifies the contents of the database such that a deferred 
 foreign key constraint is violated, the violation is not reported
 immediately. Deferred foreign key constraints are not checked
 until the transaction tries to [COMMIT](lang_transaction.html).
 For as long as the user has 
 an open transaction, the database is allowed to exist in a state that 
 violates any number of deferred foreign key constraints. However, 
 [COMMIT](lang_transaction.html) will fail as long as foreign key constraints remain in
 violation.

 


 If the current statement is not inside an explicit transaction (a 
 [BEGIN](lang_transaction.html)/[COMMIT](lang_transaction.html)/[ROLLBACK](lang_transaction.html) block), then an implicit
 transaction is committed
 as soon as the statement has finished executing. In this case deferred
 constraints behave the same as immediate constraints.

 


 To mark a foreign key constraint as deferred, its declaration must
 include the following clause:




```
DEFERRABLE INITIALLY DEFERRED                -- A deferred foreign key constraint

```


 The full syntax for specifying foreign key constraints is available as part
 of the [CREATE TABLE](lang_createtable.html) documentation. Replacing the phrase above
 with any of the following 
 creates an immediate foreign key constraint.




```
NOT DEFERRABLE INITIALLY DEFERRED            -- An immediate foreign key constraint
NOT DEFERRABLE INITIALLY IMMEDIATE           -- An immediate foreign key constraint
NOT DEFERRABLE                               -- An immediate foreign key constraint
DEFERRABLE INITIALLY IMMEDIATE               -- An immediate foreign key constraint
DEFERRABLE                                   -- An immediate foreign key constraint

```

The [defer\_foreign\_keys pragma](pragma.html#pragma_defer_foreign_keys) can be used to temporarily change all foreign
 key constraints to deferred regardless of how they are declared.

 


 The following example illustrates the effect of using a deferred foreign
 key constraint.




```
-- Database schema. Both tables are initially empty. 
CREATE TABLE artist(
  artistid    INTEGER PRIMARY KEY, 
  artistname  TEXT
);
CREATE TABLE track(
  trackid     INTEGER,
  trackname   TEXT, 
  trackartist INTEGER REFERENCES artist(artistid) DEFERRABLE INITIALLY DEFERRED
);

sqlite3> -- If the foreign key constraint were immediate, this INSERT would
sqlite3> -- cause an error (since as there is no row in table artist with
sqlite3> -- artistid=5). But as the constraint is deferred and there is an
sqlite3> -- open transaction, no error occurs.
sqlite3> BEGIN;
sqlite3>   INSERT INTO track VALUES(1, 'White Christmas', 5);

sqlite3> -- The following COMMIT fails, as the database is in a state that
sqlite3> -- does not satisfy the deferred foreign key constraint. The
sqlite3> -- transaction remains open.
sqlite3> COMMIT;
SQL error: foreign key constraint failed

sqlite3> -- After inserting a row into the artist table with artistid=5, the
sqlite3> -- deferred foreign key constraint is satisfied. It is then possible
sqlite3> -- to commit the transaction without error.
sqlite3>   INSERT INTO artist VALUES(5, 'Bing Crosby');
sqlite3> COMMIT;

```


 A [nested savepoint](lang_savepoint.html) transaction may be RELEASEd while the
 database is in a state that does not satisfy a deferred foreign key 
 constraint. A transaction savepoint (a non\-nested savepoint that was
 opened while there was not currently an open transaction), on the 
 other hand, is subject to the same restrictions as a COMMIT \- attempting 
 to RELEASE it while the database is in such a state will fail.

 


 If a COMMIT statement (or the RELEASE of a transaction SAVEPOINT) fails
 because the database is currently in a state that violates a deferred
 foreign key constraint and there are currently
 [nested savepoints](lang_savepoint.html), the nested savepoints remain open.





