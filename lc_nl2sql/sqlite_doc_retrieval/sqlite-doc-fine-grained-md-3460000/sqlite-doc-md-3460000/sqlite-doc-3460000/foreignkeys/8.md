## 4\.3\. 
 ON DELETE and ON UPDATE Actions



 Foreign key ON DELETE and ON UPDATE clauses are used to configure actions
 that take place when deleting rows from the parent table (ON DELETE), or 
 modifying the parent key values of existing rows (ON UPDATE). A single
 foreign key constraint may have different actions configured for ON DELETE
 and ON UPDATE. Foreign key actions are similar to triggers in many ways.

 


 The ON DELETE and ON UPDATE action associated with each foreign key in an
 SQLite database is one of "NO ACTION", "RESTRICT", "SET NULL",
 "SET DEFAULT" or "CASCADE". If an action is not explicitly specified, it 
 defaults to "NO ACTION".

 

* **NO ACTION**: Configuring "NO ACTION" means just that: when a
 parent key is modified or deleted from the database, no special action is
 taken.
* **RESTRICT**: The "RESTRICT" action means that the application
 is prohibited from deleting (for ON DELETE RESTRICT) or modifying
 (for ON UPDATE RESTRICT) a parent key when there exists one or more child
 keys mapped to it. The difference between the effect of a RESTRICT
 action and normal foreign key constraint enforcement is that the
 RESTRICT action processing happens as soon as the field is updated \-
 not at the end of the current statement as it would with an immediate
 constraint, or at the end of the current transaction as it would with
 a deferred constraint.
 Even if the foreign key constraint it is 
 attached to is deferred, configuring a RESTRICT action causes SQLite to 
 return an error immediately if a parent key with dependent child keys is 
 deleted or modified.
* **SET NULL**: If the configured action is "SET NULL", then when
 a parent key is deleted (for ON DELETE SET NULL) or modified (for ON 
 UPDATE SET NULL), the child key columns of all rows in the child table
 that mapped to the parent key are set to contain SQL NULL values.
* **SET DEFAULT**: The "SET DEFAULT" actions are similar to
 "SET NULL",
 except that each of the child key columns is set to contain the column's 
 default value instead of NULL. Refer to the [CREATE TABLE](lang_createtable.html) 
 documentation for details on how default values are assigned to table
 columns.
* **CASCADE**: A "CASCADE" action propagates the delete or update
 operation on the parent key to each dependent child key. For an "ON 
 DELETE CASCADE" action, this means that each row in the child table that
 was associated with the deleted parent row is also deleted. For an "ON
 UPDATE CASCADE" action, it means that the values stored in each dependent
 child key are modified to match the new parent key values.



 For example, adding an "ON UPDATE CASCADE" clause to the foreign key as
 shown below enhances the example schema from section 1 to allow the user
 to update the artistid (the parent key of the foreign key constraint) 
 column without breaking referential integrity:



```
-- Database schema
CREATE TABLE artist(
  artistid    INTEGER PRIMARY KEY, 
  artistname  TEXT
);
CREATE TABLE track(
  trackid     INTEGER,
  trackname   TEXT, 
  trackartist INTEGER REFERENCES artist(artistid) ON UPDATE CASCADE
);

sqlite> SELECT * FROM artist;
artistid  artistname       
--------  -----------------
1         Dean Martin      
2         Frank Sinatra    

sqlite> SELECT * FROM track;
trackid  trackname          trackartist
-------  -----------------  -----------
11       That's Amore       1
12       Christmas Blues    1
13       My Way             2  

sqlite> -- Update the artistid column of the artist record for "Dean Martin".
sqlite> -- Normally, this would raise a constraint, as it would orphan the two
sqlite> -- dependent records in the track table. However, the ON UPDATE CASCADE clause
sqlite> -- attached to the foreign key definition causes the update to "cascade"
sqlite> -- to the child table, preventing the foreign key constraint violation.
sqlite> UPDATE artist SET artistid = 100 WHERE artistname = 'Dean Martin';

sqlite> SELECT * FROM artist;
artistid  artistname       
--------  -----------------
2         Frank Sinatra    
100       Dean Martin      

sqlite> SELECT * FROM track;
trackid  trackname          trackartist
-------  -----------------  -----------
11       That's Amore       100
12       Christmas Blues    100  
13       My Way             2  

```


 Configuring an ON UPDATE or ON DELETE action does not mean that the foreign
 key constraint does not need to be satisfied. For example, if an
 "ON DELETE SET DEFAULT" action is configured,
 but there is no row in the parent table 
 that corresponds to the default values of the child key columns, deleting
 a parent key while dependent child keys exist still causes a foreign key
 violation. For example:




```
-- Database schema
CREATE TABLE artist(
  artistid    INTEGER PRIMARY KEY, 
  artistname  TEXT
);
CREATE TABLE track(
  trackid     INTEGER,
  trackname   TEXT, 
  trackartist INTEGER DEFAULT 0 REFERENCES artist(artistid) ON DELETE SET DEFAULT
);

sqlite> SELECT * FROM artist;
artistid  artistname       
--------  -----------------
3         Sammy Davis Jr.

sqlite> SELECT * FROM track;
trackid  trackname          trackartist
-------  -----------------  -----------
14       Mr. Bojangles      3

sqlite> -- Deleting the row from the parent table causes the child key
sqlite> -- value of the dependent row to be set to integer value 0. However, this
sqlite> -- value does not correspond to any row in the parent table. Therefore
sqlite> -- the foreign key constraint is violated and an is exception thrown.
sqlite> DELETE FROM artist WHERE artistname = 'Sammy Davis Jr.';
SQL error: foreign key constraint failed

sqlite> -- This time, the value 0 does correspond to a parent table row. And
sqlite> -- so the DELETE statement does not violate the foreign key constraint
sqlite> -- and no exception is thrown.
sqlite> INSERT INTO artist VALUES(0, 'Unknown Artist');
sqlite> DELETE FROM artist WHERE artistname = 'Sammy Davis Jr.';

sqlite> SELECT * FROM artist;
artistid  artistname       
--------  -----------------
0         Unknown Artist

sqlite> SELECT * FROM track;
trackid  trackname          trackartist
-------  -----------------  -----------
14       Mr. Bojangles      0

```


 Those familiar with [SQLite triggers](lang_createtrigger.html)
 will have noticed that the 
 "ON DELETE SET DEFAULT" action demonstrated in the example above is
 similar in effect to the following AFTER DELETE trigger:



```
CREATE TRIGGER on_delete_set_default AFTER DELETE ON artist BEGIN
  UPDATE child SET trackartist = 0 WHERE trackartist = old.artistid;
END;

```


 Whenever a row in the parent table of a foreign key constraint is deleted,
 or when the values stored in the parent key column or columns are modified, 
 the logical sequence of events is:

 

1. Execute applicable BEFORE trigger programs,
2. Check local (non foreign key) constraints,
3. Update or delete the row in the parent table,
4. Perform any required foreign key actions,
5. Execute applicable AFTER trigger programs.



 There is one important difference between ON UPDATE foreign key actions and
 SQL triggers. An ON UPDATE action is only taken if the values of the
 parent key are modified so that the new parent key values are 
 not equal to the old. For example:




```
-- Database schema
CREATE TABLE parent(x PRIMARY KEY);
CREATE TABLE child(y REFERENCES parent ON UPDATE SET NULL);

sqlite> SELECT * FROM parent;
x
----
key

sqlite> SELECT * FROM child;
y
----
key

sqlite> -- Since the following UPDATE statement does not actually modify
sqlite> -- the parent key value, the ON UPDATE action is not performed and
sqlite> -- the child key value is not set to NULL.
sqlite> UPDATE parent SET x = 'key';
sqlite> SELECT IFNULL(y, 'null') FROM child;
y
----
key

sqlite> -- This time, since the UPDATE statement does modify the parent key
sqlite> -- value, the ON UPDATE action is performed and the child key is set
sqlite> -- to NULL.
sqlite> UPDATE parent SET x = 'key2';
sqlite> SELECT IFNULL(y, 'null') FROM child;
y
----
null

```

