## 6\.2\. The New xQueryFunc Callback


The newer xQueryFunc callback receives more information from the r\-tree
query engine on each call, and it sends more information back to the query engine
before it returns.
To help keep the interface manageable, the xQueryFunc callback sends and receives
information from the query engine as fields in the
sqlite3\_rtree\_query\_info structure:




```
struct sqlite3_rtree_query_info {
  void *pContext;                   /* pContext from when function registered */
  int nParam;                       /* Number of function parameters */
  sqlite3_rtree_dbl *aParam;        /* value of function parameters */
  void *pUser;                      /* callback can use this, if desired */
  void (*xDelUser)(void*);          /* function to free pUser */
  sqlite3_rtree_dbl *aCoord;        /* Coordinates of node or entry to check */
  unsigned int *anQueue;            /* Number of pending entries in the queue */
  int nCoord;                       /* Number of coordinates */
  int iLevel;                       /* Level of current node or entry */
  int mxLevel;                      /* The largest iLevel value in the tree */
  sqlite3_int64 iRowid;             /* Rowid for current entry */
  sqlite3_rtree_dbl rParentScore;   /* Score of parent node */
  int eParentWithin;                /* Visibility of parent node */
  int eWithin;                      /* OUT: Visiblity */
  sqlite3_rtree_dbl rScore;         /* OUT: Write the score here */
  /* The following fields are only available in 3.8.11 and later */
  sqlite3_value **apSqlParam;       /* Original SQL values of parameters */
};

```

The first five fields of the sqlite3\_rtree\_query\_info structure are identical
to the sqlite3\_rtree\_geometry structure, and have exactly the same meaning.
The sqlite3\_rtree\_query\_info structure also contains nCoord and aCoord fields
which have the same meaning as the parameter of the same name in the xGeom callback.



The xQueryFunc must set the eWithin field of sqlite3\_rtree\_query\_info to
one of the values NOT\_WITHIN, PARTLY\_WITHIN, or FULLY\_WITHIN depending on whether
or not the bounding box defined by aCoord\[] is completely outside the region,
overlaps the region, or is completely inside the region, respectively. In
addition, the xQueryFunc must set the rScore field to a non\-negative value that
indicates the order in which subtrees and entries of the query should be analyzed
and returned. Smaller scores are processed first.



As its name implies, an R\*Tree is organized as a tree. Each node of the
tree is a bounding box. The root of the tree is a bounding box that encapsulates
all elements of the tree. Beneath the root are a number of subtrees (typically
20 or more) each with their own smaller bounding boxes and each containing some
subset of the R\*Tree entries. The subtrees may have sub\-subtrees, and so forth
until finally one reaches the leaves of the tree which are the actual R\*Tree
entries.



An R\*Tree query is initialized by making the root node the only entry
in a priority queue sorted by rScore.
The query proceeds by extracting the entry from the priority queue that has
the lowest score. If that entry is a leaf (meaning that it is an actual
R\*Tree entry and not a subtree) then that entry
is returned as one row of the query result.
If the extracted priority queue entry is a node (a subtree),
then the next child of that node is passed to the xQueryFunc callback.
If the node has more children then it is returned to the priority queue.
Otherwise it is discarded. Those subelements for which the xQueryFunc
callback sets eWithin to PARTLY\_WITHIN or FULLY\_WITHIN are added to the
priority queue using the score supplied by the callback. Subelements that
return NOT\_WITHIN are discarded. The query runs until the priority queue is
empty.



Every leaf entry and node (subtree) within the R\*Tree has an integer "level".
The leaves have a level of 0\. The first containing subtree of the leaves has
a level of 1\. The root of the R\*Tree has the largest level value. The
mxLevel entry in the sqlite3\_rtree\_query\_info structure is the level value for
the root of the R\*Tree. The iLevel entry in sqlite3\_rtree\_query\_info gives the
level for the object being interrogated.



Most R\*Tree queries use a depth\-first search. This is accomplished by setting
the rScore equal to iLevel. A depth\-first search is usually preferred since it
minimizes the number of elements in the priority queue, which reduces memory
requirements and speeds processing. However, some application may prefer a
breadth\-first search, which can be accomplished by setting rScore to mxLevel\-iLevel.
By creating more complex formulas for rScore, applications can exercise
detailed control over the order in which subtree are searched and leaf
R\*Tree entries are returned. For example, in an application with many
millions of R\*Tree entries, the rScore might be arranged so that the
largest or most significant entries are returned first, allowing the
application to display the most important information quickly, and
filling in smaller and less important details as they become available.



Other information fields of the sqlite3\_rtree\_query\_info structure are
available for use by the xQueryFunc callback, if desired. The iRowid field
is the rowid (the first of the 3 to 11 columns in the R\*Tree) for the element
being considered. iRowid is only valid for leaves. The eParentWithin and
rParentScore values are copies of the eWithin and rScore values from the
containing subtree of the current row. The anQueue field is an array
of mxLevel\+1 unsigned integers that tell the current number of elements in
the priority queue at each level.



