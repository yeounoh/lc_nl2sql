# 4\. Using R\*Trees Effectively



For SQLite versions prior to 3\.24\.0 (2018\-06\-04\),
the only information that an R\*Tree index stores about an object is
its integer ID and its bounding box. Additional information needs to
be stored in separate tables and related to the R\*Tree index using
the primary key. For the example above, one might create an auxiliary
table as follows:




```
CREATE TABLE demo_data(
  id INTEGER PRIMARY KEY,  -- primary key
  objname TEXT,            -- name of the object
  objtype TEXT,            -- object type
  boundary BLOB            -- detailed boundary of object
);

```


In this example, the demo\_data.boundary field is intended to hold some
kind of binary representation of the precise boundaries of the object.
The R\*Tree index only holds an axis\-aligned rectangular boundary for the
object. The R\*Tree boundary is just an approximation of the true object
boundary. So what typically happens is that the R\*Tree index is used to
narrow a search down to a list of candidate objects and then more detailed
and expensive computations are done on each candidate to find if the
candidate truly meets the search criteria.




> **Key Point:**
> An R\*Tree index does not normally provide the exact answer but merely
> reduces the set of potential answers from millions to dozens.



Suppose the demo\_data.boundary field holds some proprietary data description
of a complex two\-dimensional boundary for a zipcode and suppose that the
application has used the [sqlite3\_create\_function()](c3ref/create_function.html) interface to
created an application\-defined function "contained\_in(boundary,lat,long)"
that accepts the demo\_data.boundary object and a latitute and longitude
and returns return true or false if the lat/long is contained within
the boundary.
One may assume that "contained\_in()" is a relatively slow
functions that we do not want to invoke too frequently.
Then an efficient way to find the specific ZIP code for the main
SQLite office would be to run a query like this:





```
SELECT objname FROM demo_data, demo_index
 WHERE demo_data.id=demo_index.id
   AND contained_in(demo_data.boundary, 35.37785, -80.77470)
   AND minX<=-80.77470 AND maxX>=-80.77470
   AND minY<=35.37785  AND maxY>=35.37785;

```

Notice how the query above works: The R\*Tree index runs in the outer
loop to find entries that contain the SQLite main office in their
boundary box.
For each row found, SQLite looks up
the corresponding entry in the demo\_data table. It then uses the boundary
field from the demo\_data table as a parameter to the contained\_in()
function and if that function returns true, then we know the sought after
coordinate is in that ZIP code boundary.


One would get the same answer without the use of the R\*Tree index
using the following simpler query:



```
SELECT objname FROM demo_data
 WHERE contained_in(demo_data.boundary, 35.37785, -80.77470);

```

The problem with this latter query is that it must apply the
contained\_in() function to all entries in the demo\_data table.
The use of the R\*Tree in the penultimate query reduces the number of
calls to contained\_in() function to a small subset of the entire table.
The R\*Tree index did not find the exact answer itself, it merely
limited the search space.



