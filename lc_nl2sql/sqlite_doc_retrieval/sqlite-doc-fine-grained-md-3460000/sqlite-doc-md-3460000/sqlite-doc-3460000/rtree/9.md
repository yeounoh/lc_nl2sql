## 3\.5\. Reading And Writing At The Same Time



It is the nature of the Guttman R\-Tree algorithm that any write might
radically restructure the tree, and in the process change the scan order
of the nodes. For this reason, it is not generally possible to modify
the R\-Tree in the middle of a query of the R\-Tree. Attempts to do so
will fail with a [SQLITE\_LOCKED](rescode.html#locked) "database table is locked" error.




So, for example, suppose an application runs one query against an R\-Tree like
this:




```
SELECT id FROM demo_index
 WHERE maxY>=35.0  AND minY<=35.0;

```


Then for each "id" value returned, suppose the application creates an
UPDATE statement like the following and binds the "id" value returned against
the "?1" parameter:




```
UPDATE demo_index SET maxY=maxY+0.5 WHERE id=?1;

```


Then the UPDATE might fail with an SQLITE\_LOCKED error. The reason is that
the initial query has not run to completion. It is remembering its place
in the middle of a scan of the R\-Tree. So an update to the R\-Tree cannot
be tolerated as this would disrupt the scan.




This is a limitation of the R\-Tree extension only. Ordinary tables in
SQLite are able to read and write at the same time. Other virtual tables
might (or might not) also that capability. And R\-Tree can appear to read
and write at the same time in some circumstances, if it can figure out how
to reliably run the query to completion before starting the update. But
you shouldn't count on that for every query. Generally speaking, it is
best to avoid running queries and updates to the same R\-Tree at the same
time.




If you really need to update an R\-Tree based on complex queries against
the same R\-Tree, it is best to run the complex queries first and store
the results in a temporary table, then update the R\-Tree based on the values
stored in the temporary table.



