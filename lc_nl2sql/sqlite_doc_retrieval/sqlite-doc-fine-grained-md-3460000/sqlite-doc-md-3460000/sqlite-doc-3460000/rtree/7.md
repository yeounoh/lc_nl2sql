## 3\.3\. Querying An R\*Tree Index



Any valid query will work against an R\*Tree index. The R\*Tree
implementation just makes some kinds of queries especially
efficient. Queries against the primary key are efficient:




```
SELECT * FROM demo_index WHERE id=28269;

```


Of course, an ordinary SQLite table will also do a query against its
integer primary key efficiently, so the previous is not important.
The big reason for using an R\*Tree is so that
you can efficiently do range queries against the coordinate
ranges. For example, the main office of the SQLite project is
located at 35\.37785, \-80\.77470\.
To find which zipcodes might service that office, one could right:




```
SELECT id FROM demo_index
 WHERE minX<=-80.77470 AND maxX>=-80.77470
   AND minY<=35.37785  AND maxY>=35.37785;

```


The query above will quickly locate all zipcodes that contain
the SQLite main office in their bounding box, even if the
R\*Tree contains many entries. The previous is an example
of a "contained\-within" query. The R\*Tree also supports "overlapping"
queries. For example, to find all zipcode bounding boxes that overlap
with the 28269 zipcode:




```
SELECT A.id FROM demo_index AS A, demo_index AS B
 WHERE A.maxX>=B.minX AND A.minX<=B.maxX
   AND A.maxY>=B.minY AND A.minY<=B.maxY
   AND B.id=28269;

```


This second query will find both 28269 entry (since every bounding box
overlaps with itself) and also other zipcode that is close enough to
28269 that their bounding boxes overlap.




Note that it is not necessary for all coordinates in an R\*Tree index
to be constrained in order for the index search to be efficient.
One might, for example, want to query all objects that overlap with
the 35th parallel:




```
SELECT id FROM demo_index
 WHERE maxY>=35.0  AND minY<=35.0;

```


But, generally speaking, the more constraints that the R\*Tree module
has to work with, and the smaller the bounding box, the faster the
results will come back.



