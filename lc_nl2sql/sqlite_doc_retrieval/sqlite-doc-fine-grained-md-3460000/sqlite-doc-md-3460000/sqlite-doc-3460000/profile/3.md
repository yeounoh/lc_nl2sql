# 3\. Complex Cases \- Rows, Loops and Cycles


Using the same schema as in the previous section, consider this more
complicated example:




```
sqlite3> WITH cnt(i) AS (
  SELECT 1 UNION SELECT i+1 FROM cnt WHERE i<100
)
SELECT
  *, (SELECT d FROM t2 WHERE c=ft.rowid)
FROM
  (SELECT count(*), a FROM t1 GROUP BY a) AS v1 CROSS JOIN
  ft('sqlite'),
  cnt
WHERE cnt.i=ft.rowid AND v1.a=ft.rowid;
<...query results...>
QUERY PLAN (cycles=177665334 [100%])
|--CO-ROUTINE v1                                        (cycles=4500444 [3%])
|  |--SCAN t1                                           (cycles=397052 [0%] loops=1 rows=500)
|  `--USE TEMP B-TREE FOR GROUP BY
|--MATERIALIZE cnt                                      (cycles=1275068 [1%])
|  |--SETUP
|  |  `--SCAN CONSTANT ROW
|  `--RECURSIVE STEP
|     `--SCAN cnt                                       (cycles=129166 [0%] loops=100 rows=100)
|--SCAN v1                                              (loops=1 rows=500)
|--SCAN ft VIRTUAL TABLE INDEX 0:M1=                    (cycles=161874340 [91%] loops=500 rows=271)
|--SCAN cnt                                             (cycles=7336350 [4%] loops=95 rows=9500)
`--CORRELATED SCALAR SUBQUERY 3                         (cycles=168538 [0%] loops=37)
   `--SEARCH t2 USING INTEGER PRIMARY KEY (rowid=?)     (cycles=94724 [0%] loops=37 rows=21)

```

The most complicated part of the example above is understanding the query 
plan \- the portion of the report that would also be generated by an
[EXPLAIN QUERY PLAN](eqp.html) command. Other points of interest are:



* Sub\-query "v1" is implemented as a [co\-routine](optoverview.html#coroutines).
 In this case the sub\-query is reported on separately, and a "cycles"
 count is available for the entire sub\-query. There is also a "SCAN v1"
 line \- this represents the invocation of the sub\-query co\-routine
 from the main query. This entry has no cycles associated with it, as
 the entire cost of the sub\-query is attributed to the co\-routine.
 It does have "loops" and "rows" values \- the sub\-query is scanned
 once and returns 500 rows.
* Recursive sub\-query "cnt" is materialized (cached in a temp
 table) before the main query is run. The entire cost of the materialization
 is attributed to the "MATERIALIZE cnt" element. There is also a 
 "SCAN cnt" item representing the scans of the materialized sub\-query.
 The cycles value associated with this item represents the time taken
 to scan the temp\-table containing the materialized sub\-query, which is 
 separate from the cycles used to populate it.
* There are cycles and loops measurements for the scalar sub\-query
 as well. These represent the total cycles consumed while executing the
 sub\-query and the number of times it was executed, respectively.
* Where one item is a parent of another, as in "CORRELATED SCALAR
 SUBQUERY 3" and "SEARCH t2 USING...", then the cycles value associated
 with the parent includes those cycles associated with all child elements.
 In all cases, the percentage values relate to the total cycles used by
 the query, not the cycles used by the parent.


The following query uses an [automatic index](optoverview.html#autoindex) and
an external sort:




```
sqlite> SELECT * FROM
  t2,
  (SELECT count(*) AS cnt, d FROM t2 GROUP BY d) AS v2
WHERE v2.d=t2.d AND t2.d>100
ORDER BY v2.cnt;
<...query results...>
QUERY PLAN (cycles=6234376 [100%])
|--MATERIALIZE v2                                     (cycles=2351916 [38%])
|  |--SCAN t2                                         (cycles=188428 [3%] loops=1 rows=250)
|  `--USE TEMP B-TREE FOR GROUP BY
|--SCAN t2                                            (cycles=455736 [7%] loops=1 rows=250)
|--CREATE AUTOMATIC INDEX ON v2(d, cnt)               (cycles=1668380 [27%] loops=1 rows=250)
|--SEARCH v2 USING AUTOMATIC COVERING INDEX (d=?)     (cycles=932824 [15%] loops=200 rows=200)
`--USE TEMP B-TREE FOR ORDER BY                       (cycles=662456 [11%] loops=1 rows=200)

```

Points of interest are:



* This query materializes the sub\-query into a temp table, then creates
 an automatic (i.e. transient) index on it, then uses that index to optimize
 the join. All three of these steps \- "MATERIALIZE v2", "CREATE AUTOMATIC
 INDEX" and "SEARCH ... USING AUTOMATIC INDEX" have separate cycle counts.
 The "rows" associated with the "CREATE AUTOMATIC INDEX" line represents the
 total number of rows included in the index. The "loops" and "rows" associated
 with the "SEARCH ... USING AUTOMATIC INDEX" line represent the number of
 lookups the index was used for and the total number of rows found by those
 lookups.
* The external sort "USE TEMP B\-TREE FOR ORDER BY" is also accounted
 for separately. The cycles count represents the extra cycles consumed by
 sorting the returned rows, above those that would have been used if the rows
 were returned in arbitrary order. The rows count represents the number of
 rows sorted.


