# 2\. Simple Cases \- Rows, Loops and Cycles


Consider a database with the following schema:




```
CREATE VIRTUAL TABLE ft USING fts5(text);
CREATE TABLE t1(a, b);
CREATE TABLE t2(c INTEGER PRIMARY KEY, d);

```

Then, after first executing ".scanstats on":




```
sqlite3> SELECT * FROM t1, t2 WHERE t2.c=t1.a;
<...query results...>
QUERY PLAN (cycles=1140768 [100%])
|--SCAN t1                                           (cycles=455974 [40%] loops=1 rows=500)
`--SEARCH t2 USING INTEGER PRIMARY KEY (rowid=?)     (cycles=619820 [54%] loops=500 rows=250)

```

The text in the example above following the snipped 
"\<...query results...\>" is the profile report for the join query just
executed. The parts of the profile report that are similar to the 
[EXPLAIN QUERY PLAN](eqp.html) output indicate that the query is implemented by doing a
full table\-scan of table "t1", with a lookup by INTEGER PRIMARY KEY on table
"t2" for each row visited.



The "loops\=1" notation on the "SCAN t1" line indicates that this loop \- the
full\-table scan of table "t1" \- ran exactly once. "rows\=500" indicates that
that single scan visited 500 rows.



The "SEARCH t2 USING ..." line contains the annotation "loops\=500" to indicate
that this "loop" (really a lookup by INTEGER PRIMARY KEY) ran 500 times.
Which makes sense \- it ran once for each row visited by the full\-table scan
of "t1". "rows\=250" means that, altogether, those 500 loops visited 250 rows.
In other words, only half of the INTEGER PRIMARY KEY lookups on table t2 were
successful, for the other half of the lookups there was no row to find.



The loop\-count for a SEARCH or SCAN entry is not necessarily the same as the
number of rows output by the outer loop. For example, if the query above
were modified as follows:




```
sqlite3> SELECT * FROM t1, t2 WHERE t1.b<=100 AND t2.c=t1.a;
<...query results...>
QUERY PLAN (cycles=561002 [100%])
|--SCAN t1                                           (cycles=345950 [62%] loops=1 rows=500)
`--SEARCH t2 USING INTEGER PRIMARY KEY (rowid=?)     (cycles=128690 [23%] loops=100 rows=50)

```

This time, even though the "SCAN t1" loop still visits 500 rows, the 
"SEARCH t2" lookup is only performed 100 times. This is because SQLite
was able to discard rows from t1 that did not match the "t1\.b\<\=100" 
constraint.



The "cycles" measurements are based on the 
[CPU time\-stamp counter](https://en.wikipedia.org/wiki/Time_Stamp_Counter), and so are a good proxy for wall\-clock time. For the query above, the
total number of cycles was 561002\. For each of the two loops ("SCAN t1\..." and
"SEARCH t2\..."), the cycles count represents the time spent in operations that
can be directly attributed to that loop only. Specifically, this is the time
spent navigating and extracting data from the database b\-trees for that loop.
These values never quite add up to the total cycles for the query, as there are
other internal operations performed by SQLite that are not directly
attributable to either loop.



The cycles count for the "SCAN t1" loop was 345950 \- 62% of the total for the
query. The 100 lookups peformed by the "SEARCH t1" loop took 128690 cycles, 23%
of the total.



When a virtual table is used, the "rows" and "loops" metrics have the same 
meaning as for loops on regular SQLite tables. The "cycles" meaurement is the
total cycles consumed within virtual table methods associated with the loop.
For example:




```
sqlite3> SELECT * FROM ft('sqlite'), t2 WHERE t2.c=ft.rowid;
<...query results...>
QUERY PLAN (cycles=836434 [100%]
|--SCAN ft VIRTUAL TABLE INDEX 0:M1                  (cycles=739602 [88%] loops=1 rows=48)
`--SEARCH t2 USING INTEGER PRIMARY KEY (rowid=?)     (cycles=62866 [8%] loops=48 rows=25)

```

In this case the single query (loops\=1\) on fts5 table "ft" returned 48 rows
(rows\=48\) and consumed 739602 cycles (cycles\=739602\), which was roughly 88% of
the total query time.



