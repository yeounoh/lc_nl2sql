### 1\.0 Â  Typelessness



SQLite is "typeless". This means that you can store any
kind of data you want in any column of any table, regardless of the
declared datatype of that column. 
(See the one exception to this rule in section 2\.0 below.)
This behavior is a feature, not
a bug. A database is supposed to store and retrieve data and it 
should not matter to the database what format that data is in.
The strong typing system found in most other SQL engines and
codified in the SQL language spec is a misfeature \-
it is an example of the implementation showing through into the
interface. SQLite seeks to overcome this misfeature by allowing
you to store any kind of data into any kind of column and by
allowing flexibility in the specification of datatypes.




A datatype to SQLite is any sequence of zero or more names
optionally followed by a parenthesized lists of one or two
signed integers. Notice in particular that a datatype may
be *zero* or more names. That means that an empty
string is a valid datatype as far as SQLite is concerned.
So you can declare tables where the datatype of each column
is left unspecified, like this:




> ```
> 
> CREATE TABLE ex1(a,b,c);
> 
> ```



Even though SQLite allows the datatype to be omitted, it is
still a good idea to include it in your CREATE TABLE statements,
since the data type often serves as a good hint to other
programmers about what you intend to put in the column. And
if you ever port your code to another database engine, that
other engine will probably require a datatype of some kind.
SQLite accepts all the usual datatypes. For example:




> ```
> 
> CREATE TABLE ex2(
>   a VARCHAR(10),
>   b NVARCHAR(15),
>   c TEXT,
>   d INTEGER,
>   e FLOAT,
>   f BOOLEAN,
>   g CLOB,
>   h BLOB,
>   i TIMESTAMP,
>   j NUMERIC(10,5)
>   k VARYING CHARACTER (24),
>   l NATIONAL VARYING CHARACTER(16)
> );
> 
> ```



And so forth. Basically any sequence of names optionally followed by 
one or two signed integers in parentheses will do.



