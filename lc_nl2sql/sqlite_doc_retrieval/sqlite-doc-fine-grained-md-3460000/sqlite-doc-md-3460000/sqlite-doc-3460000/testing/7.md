## 3\.3\. Crash Testing


Crash testing seeks to demonstrate that an SQLite database will not
go corrupt if the application or operating system crashes or if there
is a power failure in the middle of a database update. A separate
white\-paper titled
[Atomic Commit in SQLite](atomiccommit.html) describes the
defensive measure SQLite takes to prevent database corruption following
a crash. Crash tests strive to verify that those defensive measures
are working correctly.


It is impractical to do crash testing using real power failures, of
course, and so crash testing is done in simulation. An alternative
[Virtual File System](c3ref/vfs.html) is inserted that allows the test
harness to simulate the state of the database file following a crash.


In the TCL test harness, the crash simulation is done in a separate
process. The main testing process spawns a child process which runs
some SQLite operation and randomly crashes somewhere in the middle of
a write operation. A special [VFS](vfs.html) randomly reorders and corrupts
the unsynchronized
write operations to simulate the effect of buffered filesystems. After
the child dies, the original test process opens and reads the test
database and verifies that the changes attempted by the child either
completed successfully or else were completely rolled back. The
[integrity\_check](pragma.html#pragma_integrity_check) [PRAGMA](pragma.html#syntax) is used to make sure no database corruption
occurs.


The TH3 test harness needs to run on embedded systems that do not
necessarily have the ability to spawn child processes, so it uses
an in\-memory [VFS](vfs.html) to simulate crashes. The in\-memory [VFS](vfs.html) can be rigged
to make a snapshot of the entire filesystem after a set number of I/O
operations. Crash tests run in a loop. On each iteration of the loop,
the point at which a snapshot is made is advanced until the SQLite
operations being tested run to completion without ever hitting a
snapshot. Within the loop, after the SQLite operation under test has
completed, the filesystem is reverted to the snapshot and random file
damage is introduced that is characteristic of the kinds of damage
one expects to see following a power loss. Then the database is opened
and checks are made to ensure that it is well\-formed and that the
transaction either ran to completion or was completely rolled back.
The interior of the loop is repeated multiple times for each
snapshot with different random damage each time.



