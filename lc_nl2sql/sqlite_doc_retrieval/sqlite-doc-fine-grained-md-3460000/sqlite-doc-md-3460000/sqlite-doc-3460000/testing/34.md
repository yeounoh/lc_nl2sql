## 7\.6\. Mutation testing


Using gcov (or similar) to show that every branch instruction is taken
at least once in both directions is good measure of test suite quality.
But even better is showing that every branch instruction makes
a difference in the output. In other words, we want to show
not only that every branch instruction both jumps and falls through but also
that every branch is doing useful work and that the test suite is able
to detect and verify that work. When a branch is found that does not
make a difference in the output, that suggests that code associated with
the branch can be removed (reducing the size of the library and perhaps
making it run faster) or that the test suite is inadequately testing the
feature that the branch implements.



SQLite strives to verify that every branch instruction makes a difference
using [mutation testing](https://en.wikipedia.org/wiki/Mutation_testing).
[A script](th3.html#muttest)
first compiles the SQLite source code into assembly language
(using, for example, the \-S option to gcc). Then the script steps through
the generated assembly language and, one by one, changes each branch
instruction into either an unconditional jump or a no\-op, compiles the
result, and verifies that the test suite catches the mutation.




Unfortunately, SQLite contains many branch instructions that
help the code run faster without changing the output.
Such branches generate false\-positives during mutation testing.
As an example, consider the following
[hash function](https://www.sqlite.org/src/artifact/55b5fb474?ln=55-62)
used to accelerate table\-name lookup:




```
55  static unsigned int strHash(const char *z){
56    unsigned int h = 0;
57    unsigned char c;
58    while( (c = (unsigned char)*z++)!=0 ){     /*OPTIMIZATION-IF-TRUE*/
59      h = (h<<3) ^ h ^ sqlite3UpperToLower[c];
60    }
61    return h;
62  }

```


If the branch instruction that implements the "c!\=0" test on line 58
is changed into a no\-op, then the while\-loop will loop forever and the
test suite will fail with a time\-out. But if that branch is changed
into an unconditional jump, then the hash function will always return 0\.
The problem is that 0 is a valid hash. A hash function that always
returns 0 still works in the sense that SQLite still always gets the correct
answer. The table\-name hash table degenerates into a linked\-list
and so the table\-name lookups that occur while parsing SQL statements
might be a little slower, but the end result will be the same.




To work around this problem, comments of the form
"`/*OPTIMIZATION-IF-TRUE*/`" and
"`/*OPTIMIZATION-IF-FALSE*/`" are inserted into the SQLite
source code to tell the mutation testing script to ignore some branch
instructions.




