## 7\.1\.  Cache Retained Between Transactions


[Step 3\.12](#section_3_12) of the commit process shows
that once the shared lock has been released, all user\-space cache
images of database content must be discarded. This is done because
without a shared lock, other processes are free to modify the database
file content and so any user\-space image of that content might become
obsolete. Consequently, each new transaction would begin by rereading
data which had previously been read. This is not as bad as it sounds
at first since the data being read is still likely in the operating
systems file cache. So the "read" is really just a copy of data
from kernel space into user space. But even so, it still takes time.


Beginning with SQLite version 3\.3\.14 a mechanism has been added
to try to reduce the needless rereading of data. In newer versions
of SQLite, the data in the user\-space pager cache is retained when
the lock on the database file is released. Later, after the
shared lock is acquired at the beginning of the next transaction,
SQLite checks to see if any other process has modified the database
file. If the database has been changed in any way since the lock
was last released, the user\-space cache is erased at that point.
But commonly the database file is unchanged and the user\-space cache
can be retained, and some unnecessary read operations can be avoided.


In order to determine whether or not the database file has changed,
SQLite uses a counter in the database header (in bytes 24 through 27\)
which is incremented during every change operation. SQLite saves a copy
of this counter prior to releasing its database lock. Then after
acquiring the next database lock it compares the saved counter value
against the current counter value and erases the cache if the values
are different, or reuses the cache if they are the same.



