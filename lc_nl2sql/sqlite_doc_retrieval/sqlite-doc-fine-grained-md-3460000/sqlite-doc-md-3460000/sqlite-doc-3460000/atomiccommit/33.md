## 6\.3\.  Cache Spill Prior To Commit


The commit process shown in [section 3\.0](#section_3_0)
assumes that all database changes fit in memory until it is time to
commit. This is the common case. But sometimes a larger change will
overflow the user\-space cache prior to transaction commit. In those
cases, the cache must spill to the database before the transaction
is complete.


At the beginning of a cache spill, the status of the database
connection is as shown in [step 3\.6](#section_3_6).
Original page content has been saved in the rollback journal and
modifications of the pages exist in user memory. To spill the cache,
SQLite executes steps [3\.7](#section_3_7) through
[3\.9](#section_3_9). In other words, the rollback journal
is flushed to disk, an exclusive lock is acquired, and changes are
written into the database. But the remaining steps are deferred
until the transaction really commits. A new journal header is
appended to the end of the rollback journal (in its own sector)
and the exclusive database lock is retained, but otherwise processing
returns to [step 3\.6](#section_3_6). When the transaction
commits, or if another cache spill occurs, steps
[3\.7](#section_3_7) and [3\.9](#section_3_9) are
repeated. (Step [3\.8](#section_3_8) is omitted on second
and subsequent passes since an exclusive database lock is already held
due to the first pass.)


A cache spill causes the lock on the database file to
escalate from reserved to exclusive. This reduces concurrency.
A cache spill also causes extra disk flush or fsync operations to
occur and these operations are slow, hence a cache spill can
seriously reduce performance.
For these reasons a cache spill is avoided whenever possible.



