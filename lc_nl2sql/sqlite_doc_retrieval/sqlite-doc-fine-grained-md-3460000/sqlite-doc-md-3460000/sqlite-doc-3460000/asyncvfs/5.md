### 1\.3 Locking and Concurrency


Multiple connections from within a single process that use this
implementation of asynchronous IO may access a single database
file concurrently. From the point of view of the user, if all
connections are from within a single process, there is no difference
between the concurrency offered by "normal" SQLite and SQLite
using the asynchronous backend.

If file\-locking is enabled (it is enabled by default), then connections
from multiple processes may also read and write the database file.
However concurrency is reduced as follows:

* When a connection using asynchronous IO begins a database
 transaction, the database is locked immediately. However the
 lock is not released until after all relevant operations
 in the write\-queue have been flushed to disk. This means
 (for example) that the database may remain locked for some 
 time after a "[COMMIT](lang_transaction.html)" or "[ROLLBACK](lang_transaction.html)" is issued.

* If an application using asynchronous IO executes transactions
 in quick succession, other database users may be effectively
 locked out of the database. This is because when a [BEGIN](lang_transaction.html)
 is executed, a database lock is established immediately. But
 when the corresponding COMMIT or ROLLBACK occurs, the lock
 is not released until the relevant part of the write\-queue 
 has been flushed through. As a result, if a COMMIT is followed
 by a BEGIN before the write\-queue is flushed through, the database 
 is never unlocked,preventing other processes from accessing 
 the database.


File\-locking may be disabled at runtime using the sqlite3async\_control()
API (see below). This may improve performance when an NFS or other 
network file\-system, as the synchronous round\-trips to the server be 
required to establish file locks are avoided. However, if multiple 
connections attempt to access the same database file when file\-locking
is disabled, application crashes and database corruption is a likely
outcome.


