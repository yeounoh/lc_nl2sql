## 2\.0 Configuring Or Replacing The Mutex Subsystem


In a multithreaded environment, SQLite uses mutexes to serialize
access to shared resources.
The mutex subsystem is only required for applications that access
SQLite from multiple threads. For single\-threaded applications, or
applications which only call SQLite from a single thread, the mutex
subsystem can be completely disabled by recompiling with the following
option:



> ```
> 
> -DSQLITE_THREADSAFE=0
> 
> ```


Mutexes are cheap but they are not free, so performance will be better
when mutexes are completely disabled. The resulting library footprint
will also be a little smaller. Disabling the mutexes at compile\-time
is a recommended optimization for applications where it makes sense.


When using SQLite as a shared library, an application can test to see
whether or not mutexes have been disabled using the
[sqlite3\_threadsafe()](c3ref/threadsafe.html) API. Applications that link against SQLite at
run\-time and use SQLite from multiple threads should probably check this
API to make sure they did not accidentally get linked against a version of
the SQLite library that has its mutexes disabled. Single\-threaded
applications will, of course, work correctly regardless of whether or
not SQLite is configured to be threadsafe, though they will be a little
bit faster when using versions of SQLite with mutexes disabled.


SQLite mutexes can also be disabled at run\-time using the
[sqlite3\_config()](c3ref/config.html) interface. To completely disable all mutexing,
the application can invoke:



> ```
> 
> sqlite3_config(SQLITE_CONFIG_SINGLETHREAD);
> 
> ```


Disabling mutexes at run\-time is not as effective as disabling them
at compile\-time since SQLite still must do a test of a boolean variable
to see if mutexes are enabled or disabled at each point where a mutex
might be required. But there is still a performance advantage for
disabling mutexes at run\-time.


For multi\-threaded applications that are careful about how they
manage threads, SQLite supports an alternative run\-time configuration
that is half way between not using any mutexes and the default situation
of mutexing everything in sight. This in\-the\-middle mutex alignment can
be established as follows:



> ```
> 
> sqlite3_config(SQLITE_CONFIG_MULTITHREAD);
> sqlite3_config(SQLITE_CONFIG_MEMSTATUS, 0);
> 
> ```


There are two separate configuration changes here which can
be used either together or separately. The
[SQLITE\_CONFIG\_MULTITHREAD](c3ref/c_config_covering_index_scan.html#sqliteconfigmultithread) setting disables the mutexes that
serialize access to [database connection](c3ref/sqlite3.html) objects and 
[prepared statement](c3ref/stmt.html) objects. With this setting, the application
is free to use SQLite from multiple threads, but it must make sure
than no two threads try to access the same [database connection](c3ref/sqlite3.html)
or any [prepared statements](c3ref/stmt.html) associated with the same 
[database connection](c3ref/sqlite3.html) at the same time. Two threads can use SQLite
at the same time, but they must use separate [database connections](c3ref/sqlite3.html).
The second [SQLITE\_CONFIG\_MEMSTATUS](c3ref/c_config_covering_index_scan.html#sqliteconfigmemstatus) setting disables the mechanism
in SQLite that tracks the total size of all outstanding memory
allocation requests. This omits the need to mutex each call
to [sqlite3\_malloc()](c3ref/free.html) and [sqlite3\_free()](c3ref/free.html), which saves a huge
number of mutex operations. But a consequence of disabling the
memory statistics mechanism is that the 
[sqlite3\_memory\_used()](c3ref/memory_highwater.html), [sqlite3\_memory\_highwater()](c3ref/memory_highwater.html), and
[sqlite3\_soft\_heap\_limit64()](c3ref/hard_heap_limit64.html) interfaces cease to work.



SQLite uses pthreads for its mutex implementation on Unix and
SQLite requires a recursive mutex. Most modern pthread implementations
support recursive mutexes, but not all do. For systems that do not
support recursive mutexes, it is recommended that applications operate
in single\-threaded mode only. If this is not possible, SQLite provides
an alternative recursive mutex implementation built on top of the
standard "fast" mutexes of pthreads. This alternative
implementation should work correctly as long as pthread\_equal() is
atomic and the processor has a coherent data cache. The alternative
recursive mutex implementation is enabled by the following
compiler command\-line switch:



> ```
> 
> -DSQLITE_HOMEGROWN_RECURSIVE_MUTEX=1
> 
> ```


When porting SQLite to a new operating system, it is usually necessary
to completely replace the built\-in mutex subsystem with an alternative
built around the mutex primitives of the new operating system. This
is accomplished by compiling SQLite with the following option:



> ```
> 
> -DSQLITE_MUTEX_APPDEF=1
> 
> ```


When SQLite is compiled with the SQLITE\_MUTEX\_APPDEF\=1 option, it
completely omits the implementation of its 
[mutex primitive functions](c3ref/mutex_alloc.html). But the SQLite
library still attempts to call these functions where necessary, so the
application must itself implement the
[mutex primitive functions](c3ref/mutex_alloc.html) and link them together
with SQLite.


