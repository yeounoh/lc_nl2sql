# 1\. Overview



SQLite supports seven [scalar](lang_corefunc.html) date and time functions as follows:






1. **date(***time\-value, modifier, modifier, ...***)**
2. **time(***time\-value, modifier, modifier, ...***)**
3. **datetime(***time\-value, modifier, modifier, ...***)**
4. **julianday(***time\-value, modifier, modifier, ...***)**
5. **unixepoch(***time\-value, modifier, modifier, ...***)**
6. **strftime(***format, time\-value, modifier, modifier, ...***)**
7. **timediff(***time\-value, time\-value***)**



The first six date and time functions take an optional [time\-value](lang_datefunc.html#tmval) as an argument, followed
by zero or more [modifiers](lang_datefunc.html#dtmods).
The strftime() function also takes a format string as its first argument.
The timediff() function takes exactly two arguments which are both [time\-values](lang_datefunc.html#tmval).




SQLite does not have a dedicated date/time datatype. Instead,
date and time values can stored as any of the following:




> | [ISO\-8601](http://en.wikipedia.org/wiki/ISO_8601) | A text string that is an ISO 8601 date/time value. Example: '2025\-05\-29 14:16:00' |
> | --- | --- |
> | [Julian day number](http://en.wikipedia.org/wiki/Julian_day) | The number of days including fractional days since \-4713\-11\-24 12:00:00 Example: 2460825\.09444444 |
> | [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time) | The number of seconds including fractional seconds since 1970\-01\-01 00:00:00 Example: 1748528160 |



These three formats are collectively known as [time\-values](lang_datefunc.html#tmval).
All of the date time functions accept time\-values as either ISO\-8601 text or
as Julian day numbers. They can also be made to accept unix timestamps by
adding optional modifiers arguments ['auto'](lang_datefunc.html#automod) or
['unixepoch'](lang_datefunc.html#jdmod).
Since the timediff() function does not accept modifiers,
it can only use ISO\-8601 and julian day number time\-values.





The **date()** function returns the date as text in this format: YYYY\-MM\-DD.





The **time()** function returns the time as text in formatted as HH:MM:SS or as HH:MM:SS.SSS if
the [subsec modifier](lang_datefunc.html#subsec) is used.





The **datetime()** function returns the date and time formatted as YYYY\-MM\-DD HH:MM:SS or
as YYYY\-MM\-DD HH:MM:SS.SSS if the [subsec modifier](lang_datefunc.html#subsec) is used.





The **julianday()** function returns the 
[Julian day](http://en.wikipedia.org/wiki/Julian_day) \- the
fractional number of days since noon in Greenwich on November 24, 4714 B.C. 
([Proleptic Gregorian calendar](http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar)).





The **unixepoch()** function returns a unix timestamp \- the number of seconds
since 1970\-01\-01 00:00:00 UTC. The unixepoch() function normally returns
an integer number of seconds, but with the optional [subsec modifier](lang_datefunc.html#subsec) it
will return a floating point number which is the fractional number of seconds.





The **strftime()** function returns the date formatted according to 
the format string specified as the first argument.
The format string supports the most common substitutions found in the 
[strftime() function](http://opengroup.org/onlinepubs/007908799/xsh/strftime.html)
from the standard C library plus two new substitutions, %f and %J.
The following is a complete list of valid strftime() substitutions
as of version 3\.46\.0 (2024\-05\-23\). Earlier versions of SQLite
might not support all substitutions. If an undefined or unsupported
substitution is seen, the result is NULL.




> |  |  |  |
> | --- | --- | --- |
> | %d |  | day of month: 01\-31 |
> | %e |  | day of month without leading zero: 1\-31 |
> | %f |  | fractional seconds: SS.SSS |
> | %F |  | ISO 8601 date: YYYY\-MM\-DD |
> | %G |  | ISO 8601 year corresponding to %V |
> | %g |  | 2\-digit ISO 8601 year corresponding to %V |
> | %H |  | hour: 00\-24 |
> | %I |  | hour for 12\-hour clock: 01\-12 |
> | %j |  | day of year: 001\-366 |
> | %J |  | Julian day number (fractional) |
> | %k |  | hour without leading zero: 0\-24 |
> | %l |  | %I without leading zero: 1\-12 |
> | %m |  | month: 01\-12 |
> | %M |  | minute: 00\-59 |
> | %p |  | "AM" or "PM" depending on the hour |
> | %P |  | "am" or "pm" depending on the hour |
> | %R |  | ISO 8601 time: HH:MM |
> | %s |  | seconds since 1970\-01\-01 |
> | %S |  | seconds: 00\-59 |
> | %T |  | ISO 8601 time: HH:MM:SS |
> | %U |  | week of year (00\-53\) \- week 01 starts on the first Sunday |
> | %u |  | day of week 1\-7 with Monday\=\=1 |
> | %V |  | ISO 8601 week of year |
> | %w |  | day of week 0\-6 with Sunday\=\=0 |
> | %W |  | week of year (00\-53\) \- week 01 starts on the first Monday |
> | %Y |  | year: 0000\-9999 |
> | %% |  | % |



Other date and time functions can be expressed
in terms of strftime():




> | **Function** |  | **Equivalent strftime()** |
> | --- | --- | --- |
> | date(...) |  | strftime('%F', ...) |
> | time(...) |  | strftime('%T', ...) |
> | datetime(...) |  | strftime('%F %T', ...) |
> | julianday(...) |  | CAST(strftime('%J', ...) as REAL) |
> | unixepoch(...) |  | CAST(strftime('%s', ...) as INT) |



The date(), time(), and datetime() functions all return text, and so their
strftime() equivalents are exact. However, the julianday()
and unixepoch() functions return numeric values. Their strftime() equivalents
return a string that is the text representation of the corresponding number.




The main reasons for providing functions other than strftime() are
for convenience and for efficiency. The julianday() and unixepoch()
functions return real and integer values respectively, and do not
incur the format conversion costs or inexactitude resulting from use
of the '%J' or '%s' format specifiers with the strftime() function.





The **timediff(A,B)** function returns a string that describes the amount
of time that must be added to B in order to reach time A. The format of
the timediff() result is designed to be human\-readable. The format is:



> (\+\|\-)YYYY\-MM\-DD HH:MM:SS.SSS



This time difference string is also an allowed modifier for the other
date/time functions. The following invariant holds for time\-values A
and B:



> datetime(A) \= datetime(B, timediff(A,B))



The length of months and years vary. February is shorter than March.
Leap years are longer than non\-leap years. The output from timediff()
takes this all into account. The timediff() function is intended to provide
a human\-friendly description of the time span. If you want to know the
number of days or seconds between two dates, A and B, then you can always do
one of these:



> SELECT julianday(B) \- julianday(A);  
> 
> SELECT unixepoch(B) \- unixepoch(A);



The timediff(A,B) might return the same result even for values A and B
that span a different number of days \- depending on the starting date.
For example, both of the following two timediff() calls return the
same result ("\-0000\-01\-00 00:00:00\.000") even though the first timespan
is 28 days and the seconds is 31 days:



> SELECT timediff('2023\-02\-15','2023\-03\-15');  
> 
> SELECT timediff('2023\-03\-15','2023\-04\-15');



Summary: If you want a human\-friendly time span, use timediff(). If you
what a precise time difference (in days or seconds) use the difference
between two julianday() or unixepoch() calls.




