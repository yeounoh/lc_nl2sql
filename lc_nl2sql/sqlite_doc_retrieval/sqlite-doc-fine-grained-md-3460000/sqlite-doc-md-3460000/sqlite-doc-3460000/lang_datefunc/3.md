# 3\. Modifiers


For all date/time functions other than timediff(),
the time\-value argument can be followed by zero or more modifiers that 
alter date and/or time. Each modifier
is a transformation that is applied to the time\-value to its left.
Modifiers are applied from left to right; order is important.
The available modifiers are as follows.


1. NNN days
2. NNN hours
3. NNN minutes
4. NNN seconds
5. NNN months
6. NNN years
7. ±HH:MM
8. ±HH:MM:SS
9. ±HH:MM:SS.SSS
10. ±YYYY\-MM\-DD
11. ±YYYY\-MM\-DD HH:MM
12. ±YYYY\-MM\-DD HH:MM:SS
13. ±YYYY\-MM\-DD HH:MM:SS.SSS
14. ceiling
15. floor
16. start of month
17. start of year
18. start of day
19. weekday N
20. unixepoch
21. julianday
22. auto
23. localtime
24. utc
25. subsec
26. subsecond


The first thirteen modifiers (1 through 13\) 
add the specified amount of time to the date and time 
specified by the arguments to its left.
The 's' character at the end of the modifier names in 1 through 6 is optional.
The NNN value can be any floating point number, with an optional '\+' or '\-' prefix.




The **time shift modifiers** (7 through 13\) move the time\-value by the
number of years, months, days, hours, minutes, and/or seconds specified.
An initial "\+" or "\-" is required for formats 10 through 13 but is optional
for formats 7, 8, and 9\. The changes are applies from left to right.
First the year is shifted by YYYY, then the month by MM, and then day
by DD, and so forth. The
timediff(A,B) function returns a time shift in format 13 that shifts
the time\-value B into A.



Because the length of a month or year changes from one month or year
to the next, ambiguities can arise when shifting a date by months and/or years.
For example, what is the date one year after 2024\-02\-29? Is it 2025\-02\-28 
or 2025\-03\-01? Or what is the date that is two months after 2023\-12\-31?
Is it 2024\-02\-29 or 2024\-03\-02? There is no consensus on how to resolve
this ambiguity, so the "**ceiling**" and "**floor**" modifiers
(14 and 15\) are available to
let the programmer decide. If the next modifier after a time shift is
"ceiling", then any ambiguity in the date is resolved by choosing the
later date. The "floor" modifier resolves ambiguities
by resolving to the last day of the previous month. The default
behavior is "ceiling".



The "**start of**" modifiers (16 through 18\) shift the date backwards 
to the beginning of the subject month, year or day.


The "**weekday**" modifier advances the date forward, if necessary,
to the next date where the weekday number is N. Sunday is 0, Monday is 1,
and so forth.
If the date is already on the desired weekday, the "weekday" modifier
leaves the date unchanged. 



The "**unixepoch**" modifier (20\) only works if it immediately follows 
a time\-value in the DDDDDDDDDD format. 
This modifier causes the DDDDDDDDDD to be interpreted not 
as a Julian day number as it normally would be, but as
[Unix Time](http://en.wikipedia.org/wiki/Unix_time) \- the 
number of seconds since 1970\. If the "unixepoch" modifier does not
follow a time\-value of the form DDDDDDDDDD which expresses the number
of seconds since 1970 or if other modifiers
separate the "unixepoch" modifier from prior DDDDDDDDDD then the
behavior is undefined.




The "**julianday**" modifier must immediately follow the initial
time\-value which must be of the form DDDDDDDDD. Any other use of
the 'julianday' modifier is an error and causes the function to return NULL.
The 'julianday' modifier forces the time\-value number to be interpreted
as a julian\-day number. As this is the default behavior, the 'julianday'
modifier is scarcely more than a no\-op. The only difference is that
adding 'julianday' forces the DDDDDDDDD time\-value format, and causes
a NULL to be returned if any other time\-value format is used.




The "**auto**" modifier must immediately follow the initial time\-value.
If the time\-value is numeric (the DDDDDDDDDD format) then the 'auto'
modifier causes the time\-value to interpreted as either a julian day
number or a unix timestamp, depending on its magnitude. If the value
is between 0\.0 and 5373484\.499999, then it is interpreted as a julian
day number (corresponding to dates between
\-4713\-11\-24 12:00:00 and 9999\-12\-31 23:59:59, inclusive). For numeric
values outside of the range of valid julian day numbers, but within 
the range of \-210866760000 to 253402300799, the 'auto' modifier causes
the value to be interpreted as a unix timestamp. Other numeric values
are out of range and cause a NULL return. The 'auto' modifier is a no\-op 
for ISO 8601 text time\-values.
The "auto" modifier is designed to work with time\-values even in
cases where it is not known which time\-value format
is stored in the database file, or in cases where the same column
stores time\-values in different formats on different rows.
The 'auto' modifier will automatically select the
appropriate format. However, there is some ambiguity. Unix
timestamps for the first 63 days of 1970 will be interpreted as julian
day numbers. The 'auto' modifier is very useful when the dataset is
guaranteed to contain no dates within that range, but should be
avoided for applications that might make use of dates in the opening
months of 1970\.




The "**localtime**" modifier assumes the time\-value to its left is in
Universal Coordinated Time (UTC) and adjusts that time
value so that it is in localtime. If "localtime"
follows a time that is not UTC, then the behavior is undefined.
The "**utc**" modifier is the opposite of "localtime". 
"utc" assumes that the time\-value
to its left is in the local timezone and adjusts that time\-value to be in UTC.
If the time to the left is not in localtime, then the result of "utc" is
undefined.




The "**subsecond**" modifier (which may be abbreviated as just
"**subsec**") increases the resolution of the output for
[datetime()](lang_datefunc.html#dttm), [time()](lang_datefunc.html#dttm), and [unixepoch()](lang_datefunc.html#uepch), and for the "%s"
format string in [strftime()](lang_datefunc.html#strftm). The "subsecond"
modifier has no effect on other date/time functions.
The current implemention increases the resolution from seconds
to milliseconds, but this might increase to a higher resolution
in future releases of SQLite. When "subsec" is used with
[datetime()](lang_datefunc.html#dttm) or [time()](lang_datefunc.html#dttm), the seconds field at the end is
followed by a decimal point and one or more digits to show
fractional seconds. When "subsec" is used with [unixepoch()](lang_datefunc.html#uepch),
the result is a floating point value which is the number of
seconds and fractional seconds since 1970\-01\-01\.
The "subsecond" and "subsec" modifiers have the special property
that they can occur as the first argument to date/time functions
(or as the first argument after the format string for strftime()).
When this happens, the time\-value that is normally in the first
argument is understood to be "now". For example, a short cut to
get the current time in seconds since 1970 with millisecond
precision is to say:




> SELECT unixepoch('subsec');


