### The "eval" method



The most useful *dbcmd* method is "eval". The eval method is used
to execute SQL on the database. The syntax of the eval method looks
like this:



> *dbcmd*  **eval**  ?**\-withoutnulls**?  *sql*
>   ?*array\-name*?  ?*script*?



The job of the eval method is to execute the SQL statement or statements
given in the second argument. For example, to create a new table in
a database, you can do this:



> **sqlite3 db1 ./testdb  
> 
> db1 eval {CREATE TABLE t1(a int, b text)}**


The above code creates a new table named **t1** with columns
**a** and **b**. What could be simpler?


Query results are returned as a list of column values. If a
query requests 2 columns and there are 3 rows matching the query,
then the returned list will contain 6 elements. For example:



> **db1 eval {INSERT INTO t1 VALUES(1,'hello')}  
> 
> db1 eval {INSERT INTO t1 VALUES(2,'goodbye')}  
> 
> db1 eval {INSERT INTO t1 VALUES(3,'howdy!')}  
> 
> set x \[db1 eval {SELECT \* FROM t1 ORDER BY a}]**


The variable **$x** is set by the above code to



> **1 hello 2 goodbye 3 howdy!**


You can also process the results of a query one row at a time
by specifying the name of an array variable and a script following
the SQL code. For each row of the query result, the values of all
columns will be inserted into the array variable and the script will
be executed. For instance:



> **db1 eval {SELECT \* FROM t1 ORDER BY a} values {  
> 
>     parray values  
> 
>     puts ""  
> 
> }**


This last code will give the following output:



> **values(\*) \= a b  
> 
> values(a) \= 1  
> 
> values(b) \= hello
> 
> values(\*) \= a b  
> 
> values(a) \= 2  
> 
> values(b) \= goodbye
> 
> values(\*) \= a b  
> 
> values(a) \= 3  
> 
> values(b) \= howdy!**



For each column in a row of the result, the name of that column
is used as an index in to array and the value of the column is stored
in the corresponding array entry. (Caution: If two or more columns
in the result set of a query have the same name, then the last column
with that name will overwrite prior values and earlier columns with the
same name will be inaccessible.) The special array index \* is
used to store a list of column names in the order that they appear.




Normally, NULL SQL results are stored in the array using the
[nullvalue](#nullvalue) setting. However, if
the **\-withoutnulls** option is used, then NULL SQL values
cause the corresponding array element to be unset instead.




If the array variable name is omitted or is the empty string, then the value of
each column is stored in a variable with the same name as the column
itself. For example:




> **db1 eval {SELECT \* FROM t1 ORDER BY a} {  
> 
>     puts "a\=$a b\=$b"  
> 
> }**



From this we get the following output




> **a\=1 b\=hello  
> 
> a\=2 b\=goodbye  
> 
> a\=3 b\=howdy!**




Tcl variable names can appear in the SQL statement of the second argument
in any position where it is legal to put a string or number literal. The
value of the variable is substituted for the variable name. If the
variable does not exist a NULL values is used. For example:




> **db1 eval {INSERT INTO t1 VALUES(5,$bigstring)}**



Note that it is not necessary to quote the $bigstring value. That happens
automatically. If $bigstring is a large string or binary object, this
technique is not only easier to write, it is also much more efficient
since it avoids making a copy of the content of $bigstring.




If the $bigstring variable has both a string and a "bytearray" representation,
then TCL inserts the value as a string. If it has only a "bytearray"
representation, then the value is inserted as a BLOB. To force a
value to be inserted as a BLOB even if it also has a text representation,
use a "@" character to in place of the "$". Like this:




> **db1 eval {INSERT INTO t1 VALUES(5,@bigstring)}**



If the variable does not have a bytearray representation, then "@" works
just like "$". Note that ":" works like "$" in all cases so the following
is another way to express the same statement:




> **db1 eval {INSERT INTO t1 VALUES(5,:bigstring)}**


The use of ":" instead of "$" before the name of a variable can
sometimes be useful if the SQL text is enclosed in double\-quotes "..."
instead of curly\-braces {...}.
When the SQL is contained within double\-quotes "..." then TCL will do
the substitution of $\-variables, which can lead to SQL injection if
extreme care is not used. But TCL will never substitute a :\-variable
regardless of whether double\-quotes "..." or curly\-braces {...} are
used to enclose the SQL, so the use of :\-variables adds an extra
measure of defense against SQL
injection.




