## 3\.2\. RBU Vacuum C/C\+\+ Programming


 This section provides an overview of and example code demonstrating the
 integration of RBU Vacuum into an application program. For full details,
 refer to the comments in 
 [header file
 sqlite3rbu.h](http://sqlite.org/src/doc/trunk/ext/rbu/sqlite3rbu.h).



 RBU Vacuum applications all implement some variation of the following
procedure:



1. An RBU handle is created by calling sqlite3rbu\_vacuum(T, S).

 

 Argument T is the name of the database file to vacuum. Argument S is
 the name of a database in which the RBU module will save its state if the
 vacuum operation is suspended.

 

 If state database S does not exist when sqlite3rbu\_vacuum() is
 invoked, it is automatically created and populated with the single table
 used to store the state of an RBU vacuum \- "rbu\_state". If an ongoing RBU
 vacuum is suspended, this table is populated with state data. The next
 time sqlite3rbu\_vacuum() is called with the same S parameter, it detects
 this data and attempts to resume the suspended vacuum operation. When
 an RBU vacuum operation is completed or encounters an error, RBU 
 automatically deletes the contents of the rbu\_state table. In this case,
 the next call to sqlite3rbu\_vacuum() starts an entirely new vacuum
 operation from scratch.

 

 It is a good idea to establish a convention for determining the RBU
 vacuum state database name based on the target database name. The
 example code below uses "\<target\>\-vacuum", where \<target\> is
 the name of the database being vacuumed.
2. Any custom collation sequences used by indexes within the database
 being vacuumed are registered with both of the database handles returned
 by the sqlite3rbu\_db() function.
3. Function sqlite3rbu\_step() is called on the RBU handle until either
 the RBU vacuum is finished, an error occurs or the application wishes to
 suspend the RBU vacuum.

 

 Each call to sqlite3rbu\_step() does a small amount of work towards
 completing the vacuum operation. Depending on the size of the database, a
 single vacuum may require thousands of calls to sqlite3rbu\_step().
 sqlite3rbu\_step() returns SQLITE\_DONE if the vacuum operation has
 finished, SQLITE\_OK if the vacuum operation has not finished but no error
 has occurred, and an SQLite error code if an error is encountered. If
 an error does occur, all subsequent calls to sqlite3rbu\_step() immediately
 return the same error code.
4. Finally, sqlite3rbu\_close() is called to close the RBU handle. If the
 application stopped calling sqlite3rbu\_step() before either the vacuum
 finished or an error occurred, the state of the vacuum is saved in the
 state database so that it may be resumed later on.

 

 Like sqlite3rbu\_step(), if the vacuum operation has finished,
 sqlite3rbu\_close() returns SQLITE\_DONE. If the vacuum has not finished
 but no error has occurred, SQLITE\_OK is returned. Or, if an error has
 occurred, an SQLite error code is returned. If an error occurred as part
 of a prior call to sqlite3rbu\_step(), sqlite3rbu\_close() returns the
 same error code.


The following example code illustrates the techniques described above. 




```
/*
** Either start a new RBU vacuum or resume a suspended RBU vacuum on 
** database zTarget. Return when either an error occurs, the RBU 
** vacuum is finished or when the application signals an interrupt
** (code not shown).
**
** If the RBU vacuum is completed successfully, return SQLITE_DONE.
** If an error occurs, return SQLite error code. Or, if the application
** signals an interrupt, suspend the RBU vacuum operation so that it
** may be resumed by a subsequent call to this function and return
** SQLITE_OK.
**
** This function uses the database named "<zTarget>-vacuum" for
** the state database, where <zTarget> is the name of the database 
** being vacuumed.
*/
int do_rbu_vacuum(const char *zTarget){
  int rc;
  char *zState;                   /* Name of state database */
  sqlite3rbu *pRbu;               /* RBU vacuum handle */

  zState = sqlite3_mprintf("%s-vacuum", zTarget);
  if( zState==0 ) return SQLITE_NOMEM;
  pRbu = sqlite3rbu_vacuum(zTarget, zState);
  sqlite3_free(zState);

  if( pRbu ){
    sqlite3 *dbTarget = sqlite3rbu_db(pRbu, 0);
    sqlite3 *dbState = sqlite3rbu_db(pRbu, 1);

    /* Any custom collation sequences used by the target database must
    ** be registered with both database handles here.  */

    while( sqlite3rbu_step(pRbu)==SQLITE_OK ){
      if( <application has signaled interrupt> ) break;
    }
  }
  rc = sqlite3rbu_close(pRbu);
  return rc;
}

```

*This page last modified on [2022\-01\-08 05:02:57](https://sqlite.org/docsrc/honeypot) UTC* 


