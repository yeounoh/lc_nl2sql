### 2\.2\.2\. RBU Database Contents


For each row to INSERT into the target database as part of the RBU 
update, the corresponding data\_% table should contain a single record
with the "rbu\_control" column set to contain integer value 0\. The
other columns should be set to the values that make up the new record 
to insert. 



The "rbu\_control" column may also be set to integer value 2 for 
an INSERT. In this case, the new row silently replaces any existing row that
has the same primary key values. This is equivalent to a DELETE followed by an
INSERT with the same primary key values. It is not the same as an SQL REPLACE
command, as in that case the new row may replace any conflicting rows (i.e.
those that conflict due to UNIQUE constraints or indexes), not just those with
conflicting primary keys.



If the target database table has an INTEGER PRIMARY KEY, it is not 
possible to insert a NULL value into the IPK column. Attempting to 
do so results in an SQLITE\_MISMATCH error.



For each row to DELETE from the target database as part of the RBU 
update, the corresponding data\_% table should contain a single record
with the "rbu\_control" column set to contain integer value 1\. The
real primary key values of the row to delete should be stored in the
corresponding columns of the data\_% table. The values stored in the
other columns are not used.



For each row to UPDATE from the target database as part of the RBU 
update, the corresponding data\_% table should contain a single record
with the "rbu\_control" column set to contain a value of type text.
The real primary key values identifying the row to update should be 
stored in the corresponding columns of the data\_% table row, as should
the new values of all columns being update. The text value in the 
"rbu\_control" column must contain the same number of characters as
there are columns in the target database table, and must consist entirely
of 'x' and '.' characters (or in some special cases 'd' \- see below). For 
each column that is being updated, the corresponding character is set to
'x'. For those that remain as they are, the corresponding character of the
rbu\_control value should be set to '.'. For example, given the tables 
above, the update statement:




```
UPDATE t1 SET c = 'usa' WHERE a = 4;

```

is represented by the data\_t1 row created by:




```
INSERT INTO data_t1(a, b, c, rbu_control) VALUES(4, NULL, 'usa', '..x');

```

If RBU is used to update a large BLOB value within a target database, it
may be more efficient to store a patch or delta that can be used to modify
the existing BLOB instead of an entirely new value within the RBU database. 
RBU allows deltas to be specified in two ways:



* In the "fossil delta" format \- the format used for blob deltas by the 
 [Fossil source\-code management system](http://fossil-scm.org), or
* In a custom format defined by the RBU application.


 The fossil delta format may only be used to update BLOB values. Instead
of storing the new BLOB within the data\_% table, the fossil delta is stored
instead. And instead of specifying an 'x' as part of the rbu\_control string
for the column to be updated, an 'f' character is stored. When processing
an 'f' update, RBU loads the original BLOB data from disk, applies the fossil
delta to it and stores the results back into the database file. The RBU
databases generated by [sqldiff \-\-rbu](rbu.html#sqldiff) make use of fossil deltas wherever
doing so would save space in the RBU database.



 To use a custom delta format, the RBU application must register a
user\-defined SQL function named "rbu\_delta" before beginning to process the
update. rbu\_delta() will be invoked with two arguments \- the original value
stored in the target table column and the delta value provided as part of
the RBU update. It should return the result of applying the delta to the
original value. To use the custom delta function, the character of the
rbu\_control value corresponding to the target column to update must be
set to 'd' instead of 'x'. Then, instead of updating the target table with the
value stored in the corresponding data\_% column, RBU invokes the user\-defined
SQL function "rbu\_delta()" and the store in the target table column.



For example, this row:




```
INSERT INTO data_t1(a, b, c, rbu_control) VALUES(4, NULL, 'usa', '..d');

```

causes RBU to update the target database table in a way similar to:




```
UPDATE t1 SET c = rbu_delta(c, 'usa') WHERE a = 4;

```

If the target database table is a virtual table or a table with no PRIMARY
KEY, the rbu\_control value should not include a character corresponding 
to the rbu\_rowid value. For example, this:




```
INSERT INTO data_ft1(a, b, rbu_rowid, rbu_control) 
  VALUES(NULL, 'usa', 12, '.x');

```

causes a result similar to:




```
UPDATE ft1 SET b = 'usa' WHERE rowid = 12;

```

The data\_% tables themselves should have no PRIMARY KEY declarations.
However, RBU is more efficient if reading the rows in from each data\_%
table in "rowid" order is roughly the same as reading them sorted by
the PRIMARY KEY of the corresponding target database table. In other 
words, rows should be sorted using the destination table PRIMARY KEY 
fields before they are inserted into the data\_% tables.




