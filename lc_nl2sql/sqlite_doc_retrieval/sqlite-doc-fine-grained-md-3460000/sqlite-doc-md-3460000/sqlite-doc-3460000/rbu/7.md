### 2\.2\.3\. Using RBU with FTS3/4 Tables


Usually, an [FTS3 or FTS4](fts3.html) table is an example of a virtual table 
with a rowid that works like a PRIMARY KEY. So, for the following FTS4 tables:




```
CREATE VIRTUAL TABLE ft1 USING fts4(addr, text);
CREATE VIRTUAL TABLE ft2 USING fts4;             -- implicit "content" column

```

The data\_% tables may be created as follows:




```
CREATE TABLE data_ft1 USING fts4(addr, text, rbu_rowid, rbu_control);
CREATE TABLE data_ft2 USING fts4(content, rbu_rowid, rbu_control);

```

And populated as if the target table were an ordinary SQLite table with no
explicit PRIMARY KEY columns.



[Contentless FTS4 tables](fts3.html#_contentless_fts4_tables_) are handled similarly,
except that any attempt to update or delete rows will cause an error when
applying the update.



[External content FTS4 tables](fts3.html#_external_content_fts4_tables_) may also be 
updated using RBU. In this case the user is required to configure the RBU
database so that the same set of UPDATE, DELETE and INSERT operations are
applied to the FTS4 index as to the underlying content table. As for all
updates of external content FTS4 tables, the user is also required to ensure
that any UPDATE or DELETE operations are applied to the FTS4 index before
they are applied to the underlying content table (refer to FTS4 documentation
for a detailed explanation). In RBU, this is done by ensuring that the name
of the data\_% table used to write to the FTS4 table sorts before the name
of the data\_% table used to update the underlying content table using the
[BINARY](datatype3.html#collation) collation sequence. In order to avoid duplicating data within the
RBU database, an SQL view may be used in place of one of the data\_% tables.
For example, for the target database schema:




```
CREATE TABLE ccc(addr, text);
CREATE VIRTUAL TABLE ccc_fts USING fts4(addr, text, content=ccc);

```


 The following RBU database schema may be used: 




```
CREATE TABLE data_ccc(addr, text, rbu_rowid, rbu_control);
CREATE VIEW data0_ccc_fts AS SELECT * FROM data_ccc;

```


 The data\_ccc table may then be populated as normal with the updates intended
 for target database table ccc. The same updates will be read by RBU from
 the data0\_ccc\_fts view and applied to FTS table ccc\_fts. Because
 "data0\_ccc\_fts" is smaller than "data\_ccc", the FTS table will be updated
 first, as required.




 Cases in which the underlying content table has an explicit INTEGER PRIMARY
 KEY column are slightly more difficult, as the text values stored in the
 rbu\_control column are slightly different for the FTS index and its
 underlying content table. For the underlying content table, a character
 must be included in any rbu\_control text values for the explicit IPK, but
 for the FTS table itself, which has an implicit rowid, it should not. This
 is inconvenient, but can be solved using a more complicated view, as follows:




```
-- Target database schema
CREATE TABLE ddd(i INTEGER PRIMARY KEY, k TEXT);
CREATE VIRTUAL TABLE ddd_fts USING fts4(k, content=ddd);

-- RBU database schema
CREATE TABLE data_ccc(i, k, rbu_control);
CREATE VIEW data0_ccc_fts AS SELECT i AS rbu_rowid, k, CASE 
  WHEN rbu_control IN (0,1) THEN rbu_control ELSE substr(rbu_control, 2) END
FROM data_ccc;

```


 The substr() function in the SQL view above returns the text of the
 rbu\_control argument with the first character (the one corresponding to
 column "i", which is not required by the FTS table) removed.




