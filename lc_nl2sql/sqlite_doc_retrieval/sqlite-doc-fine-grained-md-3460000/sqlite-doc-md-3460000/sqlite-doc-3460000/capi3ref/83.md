## Evaluate An SQL Statement




> ```
> 
> int sqlite3_step(sqlite3_stmt*);
> 
> ```



After a [prepared statement](#sqlite3_stmt) has been prepared using any of
[sqlite3\_prepare\_v2()](#sqlite3_prepare), [sqlite3\_prepare\_v3()](#sqlite3_prepare), [sqlite3\_prepare16\_v2()](#sqlite3_prepare),
or [sqlite3\_prepare16\_v3()](#sqlite3_prepare) or one of the legacy
interfaces [sqlite3\_prepare()](#sqlite3_prepare) or [sqlite3\_prepare16()](#sqlite3_prepare), this function
must be called one or more times to evaluate the statement.


The details of the behavior of the sqlite3\_step() interface depend
on whether the statement was prepared using the newer "vX" interfaces
[sqlite3\_prepare\_v3()](#sqlite3_prepare), [sqlite3\_prepare\_v2()](#sqlite3_prepare), [sqlite3\_prepare16\_v3()](#sqlite3_prepare),
[sqlite3\_prepare16\_v2()](#sqlite3_prepare) or the older legacy
interfaces [sqlite3\_prepare()](#sqlite3_prepare) and [sqlite3\_prepare16()](#sqlite3_prepare). The use of the
new "vX" interface is recommended for new applications but the legacy
interface will continue to be supported.


In the legacy interface, the return value will be either [SQLITE\_BUSY](#SQLITE_ABORT),
[SQLITE\_DONE](#SQLITE_ABORT), [SQLITE\_ROW](#SQLITE_ABORT), [SQLITE\_ERROR](#SQLITE_ABORT), or [SQLITE\_MISUSE](#SQLITE_ABORT).
With the "v2" interface, any of the other [result codes](rescode.html) or
[extended result codes](rescode.html#extrc) might be returned as well.


[SQLITE\_BUSY](#SQLITE_ABORT) means that the database engine was unable to acquire the
database locks it needs to do its job. If the statement is a [COMMIT](lang_transaction.html)
or occurs outside of an explicit transaction, then you can retry the
statement. If the statement is not a [COMMIT](lang_transaction.html) and occurs within an
explicit transaction then you should rollback the transaction before
continuing.


[SQLITE\_DONE](#SQLITE_ABORT) means that the statement has finished executing
successfully. sqlite3\_step() should not be called again on this virtual
machine without first calling [sqlite3\_reset()](#sqlite3_reset) to reset the virtual
machine back to its initial state.


If the SQL statement being executed returns any data, then [SQLITE\_ROW](#SQLITE_ABORT)
is returned each time a new row of data is ready for processing by the
caller. The values may be accessed using the [column access functions](#sqlite3_column_blob).
sqlite3\_step() is called again to retrieve the next row of data.


[SQLITE\_ERROR](#SQLITE_ABORT) means that a run\-time error (such as a constraint
violation) has occurred. sqlite3\_step() should not be called again on
the VM. More information may be found by calling [sqlite3\_errmsg()](#sqlite3_errcode).
With the legacy interface, a more specific error code (for example,
[SQLITE\_INTERRUPT](#SQLITE_ABORT), [SQLITE\_SCHEMA](#SQLITE_ABORT), [SQLITE\_CORRUPT](#SQLITE_ABORT), and so forth)
can be obtained by calling [sqlite3\_reset()](#sqlite3_reset) on the
[prepared statement](#sqlite3_stmt). In the "v2" interface,
the more specific error code is returned directly by sqlite3\_step().


[SQLITE\_MISUSE](#SQLITE_ABORT) means that the this routine was called inappropriately.
Perhaps it was called on a [prepared statement](#sqlite3_stmt) that has
already been [finalized](#sqlite3_finalize) or on one that had
previously returned [SQLITE\_ERROR](#SQLITE_ABORT) or [SQLITE\_DONE](#SQLITE_ABORT). Or it could
be the case that the same database connection is being used by two or
more threads at the same moment in time.


For all versions of SQLite up to and including 3\.6\.23\.1, a call to
[sqlite3\_reset()](#sqlite3_reset) was required after sqlite3\_step() returned anything
other than [SQLITE\_ROW](#SQLITE_ABORT) before any subsequent invocation of
sqlite3\_step(). Failure to reset the prepared statement using
[sqlite3\_reset()](#sqlite3_reset) would result in an [SQLITE\_MISUSE](#SQLITE_ABORT) return from
sqlite3\_step(). But after [version 3\.6\.23\.1](releaselog/3_6_23_1.html) (2010\-03\-26,
sqlite3\_step() began
calling [sqlite3\_reset()](#sqlite3_reset) automatically in this circumstance rather
than returning [SQLITE\_MISUSE](#SQLITE_ABORT). This is not considered a compatibility
break because any application that ever receives an SQLITE\_MISUSE error
is broken by definition. The [SQLITE\_OMIT\_AUTORESET](compile.html#omit_autoreset) compile\-time option
can be used to restore the legacy behavior.


**Goofy Interface Alert:** In the legacy interface, the sqlite3\_step()
API always returns a generic error code, [SQLITE\_ERROR](#SQLITE_ABORT), following any
error other than [SQLITE\_BUSY](#SQLITE_ABORT) and [SQLITE\_MISUSE](#SQLITE_ABORT). You must call
[sqlite3\_reset()](#sqlite3_reset) or [sqlite3\_finalize()](#sqlite3_finalize) in order to find one of the
specific [error codes](rescode.html) that better describes the error.
We admit that this is a goofy design. The problem has been fixed
with the "v2" interface. If you prepare all of your SQL statements
using [sqlite3\_prepare\_v3()](#sqlite3_prepare) or [sqlite3\_prepare\_v2()](#sqlite3_prepare)
or [sqlite3\_prepare16\_v2()](#sqlite3_prepare) or [sqlite3\_prepare16\_v3()](#sqlite3_prepare) instead
of the legacy [sqlite3\_prepare()](#sqlite3_prepare) and [sqlite3\_prepare16()](#sqlite3_prepare) interfaces,
then the more specific [error codes](rescode.html) are returned directly
by sqlite3\_step(). The use of the "vX" interfaces is recommended.




---


