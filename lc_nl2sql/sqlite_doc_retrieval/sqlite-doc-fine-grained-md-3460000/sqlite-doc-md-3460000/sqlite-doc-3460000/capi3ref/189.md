## Mutexes




> ```
> 
> sqlite3_mutex *sqlite3_mutex_alloc(int);
> void sqlite3_mutex_free(sqlite3_mutex*);
> void sqlite3_mutex_enter(sqlite3_mutex*);
> int sqlite3_mutex_try(sqlite3_mutex*);
> void sqlite3_mutex_leave(sqlite3_mutex*);
> 
> ```



The SQLite core uses these routines for thread
synchronization. Though they are intended for internal
use by SQLite, code that links against SQLite is
permitted to use any of these routines.


The SQLite source code contains multiple implementations
of these mutex routines. An appropriate implementation
is selected automatically at compile\-time. The following
implementations are available in the SQLite core:


* SQLITE\_MUTEX\_PTHREADS
* SQLITE\_MUTEX\_W32
* SQLITE\_MUTEX\_NOOP



The SQLITE\_MUTEX\_NOOP implementation is a set of routines
that does no real locking and is appropriate for use in
a single\-threaded application. The SQLITE\_MUTEX\_PTHREADS and
SQLITE\_MUTEX\_W32 implementations are appropriate for use on Unix
and Windows.


If SQLite is compiled with the SQLITE\_MUTEX\_APPDEF preprocessor
macro defined (with "\-DSQLITE\_MUTEX\_APPDEF\=1"), then no mutex
implementation is included with the library. In this case the
application must supply a custom mutex implementation using the
[SQLITE\_CONFIG\_MUTEX](#sqliteconfigmutex) option of the sqlite3\_config() function
before calling sqlite3\_initialize() or any other public sqlite3\_
function that calls sqlite3\_initialize().


The sqlite3\_mutex\_alloc() routine allocates a new
mutex and returns a pointer to it. The sqlite3\_mutex\_alloc()
routine returns NULL if it is unable to allocate the requested
mutex. The argument to sqlite3\_mutex\_alloc() must one of these
integer constants:


* SQLITE\_MUTEX\_FAST
* SQLITE\_MUTEX\_RECURSIVE
* SQLITE\_MUTEX\_STATIC\_MAIN
* SQLITE\_MUTEX\_STATIC\_MEM
* SQLITE\_MUTEX\_STATIC\_OPEN
* SQLITE\_MUTEX\_STATIC\_PRNG
* SQLITE\_MUTEX\_STATIC\_LRU
* SQLITE\_MUTEX\_STATIC\_PMEM
* SQLITE\_MUTEX\_STATIC\_APP1
* SQLITE\_MUTEX\_STATIC\_APP2
* SQLITE\_MUTEX\_STATIC\_APP3
* SQLITE\_MUTEX\_STATIC\_VFS1
* SQLITE\_MUTEX\_STATIC\_VFS2
* SQLITE\_MUTEX\_STATIC\_VFS3



The first two constants (SQLITE\_MUTEX\_FAST and SQLITE\_MUTEX\_RECURSIVE)
cause sqlite3\_mutex\_alloc() to create
a new mutex. The new mutex is recursive when SQLITE\_MUTEX\_RECURSIVE
is used but not necessarily so when SQLITE\_MUTEX\_FAST is used.
The mutex implementation does not need to make a distinction
between SQLITE\_MUTEX\_RECURSIVE and SQLITE\_MUTEX\_FAST if it does
not want to. SQLite will only request a recursive mutex in
cases where it really needs one. If a faster non\-recursive mutex
implementation is available on the host platform, the mutex subsystem
might return such a mutex in response to SQLITE\_MUTEX\_FAST.


The other allowed parameters to sqlite3\_mutex\_alloc() (anything other
than SQLITE\_MUTEX\_FAST and SQLITE\_MUTEX\_RECURSIVE) each return
a pointer to a static preexisting mutex. Nine static mutexes are
used by the current version of SQLite. Future versions of SQLite
may add additional static mutexes. Static mutexes are for internal
use by SQLite only. Applications that use SQLite mutexes should
use only the dynamic mutexes returned by SQLITE\_MUTEX\_FAST or
SQLITE\_MUTEX\_RECURSIVE.


Note that if one of the dynamic mutex parameters (SQLITE\_MUTEX\_FAST
or SQLITE\_MUTEX\_RECURSIVE) is used then sqlite3\_mutex\_alloc()
returns a different mutex on every call. For the static
mutex types, the same mutex is returned on every call that has
the same type number.


The sqlite3\_mutex\_free() routine deallocates a previously
allocated dynamic mutex. Attempting to deallocate a static
mutex results in undefined behavior.


The sqlite3\_mutex\_enter() and sqlite3\_mutex\_try() routines attempt
to enter a mutex. If another thread is already within the mutex,
sqlite3\_mutex\_enter() will block and sqlite3\_mutex\_try() will return
SQLITE\_BUSY. The sqlite3\_mutex\_try() interface returns [SQLITE\_OK](#SQLITE_ABORT)
upon successful entry. Mutexes created using
SQLITE\_MUTEX\_RECURSIVE can be entered multiple times by the same thread.
In such cases, the
mutex must be exited an equal number of times before another thread
can enter. If the same thread tries to enter any mutex other
than an SQLITE\_MUTEX\_RECURSIVE more than once, the behavior is undefined.


Some systems (for example, Windows 95\) do not support the operation
implemented by sqlite3\_mutex\_try(). On those systems, sqlite3\_mutex\_try()
will always return SQLITE\_BUSY. In most cases the SQLite core only uses
sqlite3\_mutex\_try() as an optimization, so this is acceptable
behavior. The exceptions are unix builds that set the
SQLITE\_ENABLE\_SETLK\_TIMEOUT build option. In that case a working
sqlite3\_mutex\_try() is required.


The sqlite3\_mutex\_leave() routine exits a mutex that was
previously entered by the same thread. The behavior
is undefined if the mutex is not currently entered by the
calling thread or is not currently allocated.


If the argument to sqlite3\_mutex\_enter(), sqlite3\_mutex\_try(),
sqlite3\_mutex\_leave(), or sqlite3\_mutex\_free() is a NULL pointer,
then any of the four routines behaves as a no\-op.


See also: [sqlite3\_mutex\_held()](#sqlite3_mutex_held) and [sqlite3\_mutex\_notheld()](#sqlite3_mutex_held).




---


