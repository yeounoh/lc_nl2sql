## Open A BLOB For Incremental I/O




> ```
> 
> int sqlite3_blob_open(
>   sqlite3*,
>   const char *zDb,
>   const char *zTable,
>   const char *zColumn,
>   sqlite3_int64 iRow,
>   int flags,
>   sqlite3_blob **ppBlob
> );
> 
> ```



This interfaces opens a [handle](#sqlite3_blob) to the BLOB located
in row iRow, column zColumn, table zTable in database zDb;
in other words, the same BLOB that would be selected by:



```

SELECT zColumn FROM zDb.zTable WHERE [rowid](lang_createtable.html#rowid) = iRow;

```



Parameter zDb is not the filename that contains the database, but
rather the symbolic name of the database. For attached databases, this is
the name that appears after the AS keyword in the [ATTACH](lang_attach.html) statement.
For the main database file, the database name is "main". For TEMP
tables, the database name is "temp".


If the flags parameter is non\-zero, then the BLOB is opened for read
and write access. If the flags parameter is zero, the BLOB is opened for
read\-only access.


On success, [SQLITE\_OK](#SQLITE_ABORT) is returned and the new [BLOB handle](#sqlite3_blob) is stored
in \*ppBlob. Otherwise an [error code](rescode.html) is returned and, unless the error
code is SQLITE\_MISUSE, \*ppBlob is set to NULL. This means that, provided
the API is not misused, it is always safe to call [sqlite3\_blob\_close()](#sqlite3_blob_close)
on \*ppBlob after this function it returns.


This function fails with SQLITE\_ERROR if any of the following are true:
* Database zDb does not exist,
* Table zTable does not exist within database zDb,
* Table zTable is a WITHOUT ROWID table,
* Column zColumn does not exist,
* Row iRow is not present in the table,
* The specified column of row iRow contains a value that is not
a TEXT or BLOB value,
* Column zColumn is part of an index, PRIMARY KEY or UNIQUE
constraint and the blob is being opened for read/write access,
* [Foreign key constraints](foreignkeys.html) are enabled,
column zColumn is part of a [child key](foreignkeys.html#parentchild) definition and the blob is
being opened for read/write access.



Unless it returns SQLITE\_MISUSE, this function sets the
[database connection](#sqlite3) error code and message accessible via
[sqlite3\_errcode()](#sqlite3_errcode) and [sqlite3\_errmsg()](#sqlite3_errcode) and related functions.


A BLOB referenced by sqlite3\_blob\_open() may be read using the
[sqlite3\_blob\_read()](#sqlite3_blob_read) interface and modified by using
[sqlite3\_blob\_write()](#sqlite3_blob_write). The [BLOB handle](#sqlite3_blob) can be moved to a
different row of the same table using the [sqlite3\_blob\_reopen()](#sqlite3_blob_reopen)
interface. However, the column, table, or database of a [BLOB handle](#sqlite3_blob)
cannot be changed after the [BLOB handle](#sqlite3_blob) is opened.


If the row that a BLOB handle points to is modified by an
[UPDATE](lang_update.html), [DELETE](lang_delete.html), or by [ON CONFLICT](lang_conflict.html) side\-effects
then the BLOB handle is marked as "expired".
This is true if any column of the row is changed, even a column
other than the one the BLOB handle is open on.
Calls to [sqlite3\_blob\_read()](#sqlite3_blob_read) and [sqlite3\_blob\_write()](#sqlite3_blob_write) for
an expired BLOB handle fail with a return code of [SQLITE\_ABORT](#SQLITE_ABORT).
Changes written into a BLOB prior to the BLOB expiring are not
rolled back by the expiration of the BLOB. Such changes will eventually
commit if the transaction continues to completion.


Use the [sqlite3\_blob\_bytes()](#sqlite3_blob_bytes) interface to determine the size of
the opened blob. The size of a blob may not be changed by this
interface. Use the [UPDATE](lang_update.html) SQL command to change the size of a
blob.


The [sqlite3\_bind\_zeroblob()](#sqlite3_bind_blob) and [sqlite3\_result\_zeroblob()](#sqlite3_result_blob) interfaces
and the built\-in [zeroblob](lang_corefunc.html#zeroblob) SQL function may be used to create a
zero\-filled blob to read or write using the incremental\-blob interface.


To avoid a resource leak, every open [BLOB handle](#sqlite3_blob) should eventually
be released by a call to [sqlite3\_blob\_close()](#sqlite3_blob_close).


See also: [sqlite3\_blob\_close()](#sqlite3_blob_close),
[sqlite3\_blob\_reopen()](#sqlite3_blob_reopen), [sqlite3\_blob\_read()](#sqlite3_blob_read),
[sqlite3\_blob\_bytes()](#sqlite3_blob_bytes), [sqlite3\_blob\_write()](#sqlite3_blob_write).




---


