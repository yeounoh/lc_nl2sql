## SQLite Assumptions About Powersafe Overwrite


All versions of SQLite up to and including [version 3\.7\.9](releaselog/3_7_9.html)
(2011\-11\-01\) assume that
the filesystem does not provide powersafe overwrite. SQLite 
has traditionally assumed that when any one byte of a file changes, all
other bytes within the same sector of that byte have the potential of
being corrupted on a power loss. When writing, SQLite has made sure
to journal all bytes in the same sector of any modifications
and it pads journal files out to the next sector boundary so that
subsequent appends to that journal cannot damage prior records.
SQLite understands the sector size to be the value returned by the
xSectorSize method in the [VFS](vfs.html). The SQLite team has often referred
to the value returned by xSectorSize as the "blast radius" of a write,
since it expresses the range of bytes that might be damaged if a power
loss occurs during the write.
The default [VFSes](vfs.html) for unix and windows have always returned 512 as 
the sector size (or blast radius) for all versions of SQLite up to
and including version 3\.7\.9\.

Newer disk drives have begun using 4096 byte sectors however. Beginning
with SQLite [version 3\.7\.10](releaselog/3_7_10.html) (2012\-01\-16\), 
the SQLite development team experimented with 
changes xSectorSize to report 4096 bytes as the blast radius.
This had the effect of increasing write overhead on
many databases. For a database with a [PRAGMA page\_size](pragma.html#pragma_page_size) of 1024
(a very common choice) making a change to a single page in the database
now requires SQLite to backup three other adjacent pages to the rollback
journal, whereas formerly it only had to backup the one page that was
changing. In [WAL mode](wal.html), each transaction had to be padded out to the
next 4096\-byte boundary in the WAL file, rather than the next 512\-byte
boundary, resulting in thousands of extra bytes being written
per transaction.

The extra write overhead prompted a reexamination of assumptions about
powersafe overwrite. With modern disk drives, the capacity has become
so large and the data density so great that a single sector is very
small and writing a single sector takes very little time. We know that
disk drives can detect an impending power loss and continue
to operate for some small amount of time on residual energy because those
drives are able to park their heads before spinning down. And
so if an impending power loss is detectable by the disk controller, it
seems reasonable that the controller will finish writing
whatever sector it is current working on when the imminent power loss 
is first detected, prior to parking the heads, as long as doing so
does not take too long, which it should not with
small and dense sectors. Hence it seems reasonable
to assume powersafe overwrite for modern disks. Indeed, BerkeleyDB has
made this assumption for decades, we are told. Caution is advised
though. As Roger Binns noted on the SQLite developers mailing list:
"'poorly written' should be the main assumption about drive firmware."


