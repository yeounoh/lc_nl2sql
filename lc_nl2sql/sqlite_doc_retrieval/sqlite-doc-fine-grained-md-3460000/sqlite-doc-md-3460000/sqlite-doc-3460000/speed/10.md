### Test 7: 5000 SELECTs with an index



> SELECT count(\*), avg(b) FROM t2 WHERE b\>\=0 AND b\<100;  
> 
> SELECT count(\*), avg(b) FROM t2 WHERE b\>\=100 AND b\<200;  
> 
> SELECT count(\*), avg(b) FROM t2 WHERE b\>\=200 AND b\<300;  
> 
> *... 4994 lines omitted*  
> 
> SELECT count(\*), avg(b) FROM t2 WHERE b\>\=499700 AND b\<499800;  
> 
> SELECT count(\*), avg(b) FROM t2 WHERE b\>\=499800 AND b\<499900;  
> 
> SELECT count(\*), avg(b) FROM t2 WHERE b\>\=499900 AND b\<500000;



| PostgreSQL: | 4\.614 |
| --- | --- |
| MySQL: | 1\.270 |
| SQLite 2\.7\.6: | 1\.121 |
| SQLite 2\.7\.6 (nosync): | 1\.162 |



All three database engines run faster when they have indices to work with.
But SQLite is still the fastest.



