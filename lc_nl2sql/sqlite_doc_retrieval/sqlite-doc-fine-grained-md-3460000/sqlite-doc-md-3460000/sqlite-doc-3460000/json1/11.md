## 3\.6\. JSON5 Extensions



Beginning in version 3\.42\.0 (2023\-05\-16\), these routines will
read and interpret input JSON text that includes
[JSON5](https://spec.json5.org/) extensions. However, JSON text generated
by these routines will always be strictly conforming to the 
[canonical definition of JSON](https://json.org).




Here is a synopsis of JSON5 extensions (adapted from the
[JSON5 specification](https://spec.json5.org/#introduction)):



* Object keys may be unquoted identifiers.
* Objects may have a single trailing comma.
* Arrays may have a single trailing comma.
* Strings may be single quoted.
* Strings may span multiple lines by escaping new line characters.
* Strings may include new character escapes.
* Numbers may be hexadecimal.
* Numbers may have a leading or trailing decimal point.
* Numbers may be "Infinity", "\-Infinity", and "NaN".
* Numbers may begin with an explicit plus sign.
* Single (//...) and multi\-line (/\*...\*/) comments are allowed.
* Additional white space characters are allowed.



To convert string X from JSON5 into canonical JSON, invoke
"[json(X)](json1.html#jmini)". The output of the "[json()](json1.html#jmini)" function will be canonical
JSON regardless of any JSON5 extensions that are present in the input.
For backwards compatibility, the [json\_valid(X)](json1.html#jvalid) function without a
"flags" argument continues
to report false for inputs that are not canonical JSON, even if the
input is JSON5 that the function is able to understand. To determine
whether or not an input string is valid JSON5, include the 0x02 bit
in the "flags" argument to json\_valid: "json\_valid(X,2\)".




These routines understand all of JSON5, plus a little more.
SQLite extends the JSON5 syntax in these two ways:



1. Strict JSON5 requires that
unquoted object keys must be ECMAScript 5\.1 IdentifierNames. But large
unicode tables and lots of code is required in order to determine whether or
not a key is an ECMAScript 5\.1 IdentifierName. For this reason,
SQLite allows object keys to include any unicode characters
greater than U\+007f that are not whitespace characters. This relaxed
definition of "identifier" greatly simplifies the implementation and allows
the JSON parser to be smaller and run faster.
2. JSON5 allows floating\-point infinities to be expressed as
"Infinity", "\-Infinity", or "\+Infinity"
in exactly that case \- the initial "I" is capitalized and all other
characters are lower case. SQLite also allows the abbreviation "Inf"
to be used in place of "Infinity" and it allows both keywords
to appear in any combination of upper and lower case letters.
Similarly,
JSON5 allows "NaN" for not\-a\-number. SQLite extends this to also allow
"QNaN" and "SNaN" in any combination of upper and lower case letters.
Note that SQLite interprets NaN, QNaN, and SNaN as just an alternative
spellings for "null".
This extension has been added because (we are told) there exists a lot
of JSON in the wild that includes these non\-standard representations
for infinity and not\-a\-number.


