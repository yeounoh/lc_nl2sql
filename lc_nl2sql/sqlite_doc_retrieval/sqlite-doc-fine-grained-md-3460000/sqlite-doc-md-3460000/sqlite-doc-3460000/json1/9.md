## 3\.4\. VALUE arguments



For functions that accept "*value*" arguments (also shown as
"*value1*" and "*value2*"),
those arguments are usually understood
to be literal strings that are quoted and become JSON string values
in the result. Even if the input *value* strings look like 
well\-formed JSON, they are still interpreted as literal strings in the
result.




However, if a *value* argument comes directly from the result of another
JSON function or from [the \-\> operator](json1.html#jptr) (but not [the \-\>\> operator](json1.html#jptr)),
then the argument is understood to be actual JSON and
the complete JSON is inserted rather than a quoted string.




For example, in the following call to json\_object(), the *value*
argument looks like a well\-formed JSON array. However, because it is just
ordinary SQL text, it is interpreted as a literal string and added to the
result as a quoted string:

* json\_object('ex','\[52,3\.14159]')
→ '{"ex":"\[52,3\.14159]"}'
* json\_object('ex',('\[52,3\.14159]'\-\>\>'$'))
→ '{"ex":"\[52,3\.14159]"}'





But if the *value* argument in the outer json\_object() call is the
result of another JSON function like [json()](json1.html#jmini) or [json\_array()](json1.html#jarray), then
the value is understood to be actual JSON and is inserted as such:

* json\_object('ex',json('\[52,3\.14159]'))
→ '{"ex":\[52,3\.14159]}'
* json\_object('ex',json\_array(52,3\.14159\))
→ '{"ex":\[52,3\.14159]}'
* json\_object('ex','\[52,3\.14159]'\-\>'$')
→ '{"ex":\[52,3\.14159]}'





To be clear: "*json*" arguments are always interpreted as JSON
regardless of where the value for that argument comes from. But
"*value*" arguments are only interpreted as JSON if those arguments
come directly from another JSON function or [the \-\> operator](json1.html#jptr).




Within JSON value arguments interpreted as JSON strings, Unicode escape
sequences are not treated as equivalent to the characters or escaped
control characters represented by the expressed Unicode code point.
Such escape sequences are not translated or specially treated; they
are treated as plain text by SQLite's JSON functions.



