# 4\. When To Use WITHOUT ROWID


The WITHOUT ROWID optimization is likely to be helpful for tables
that have non\-integer or composite (multi\-column) PRIMARY KEYs and that do
not store large strings or BLOBs.


WITHOUT ROWID tables will work correctly (that is to say, they
provide the correct answer) for tables with a single INTEGER PRIMARY KEY.
However, ordinary rowid tables will run faster in that case.
Hence, it is good design
to avoid creating WITHOUT ROWID tables with single\-column PRIMARY KEYs
of type INTEGER.



WITHOUT ROWID tables work best when individual rows are not too large.
A good rule\-of\-thumb is that the average size of a single row in a
WITHOUT ROWID table should be less than about 1/20th the size of
a database page. That means that rows should not contain more than about
50 bytes each for a 1KiB page size or about 200 bytes each for 4KiB
page size. WITHOUT ROWID tables will work (in the sense that
they get the correct answer) for arbitrarily large rows \- up to 2GB in size \-
but traditional rowid tables tend to work faster for large row sizes.
This is because rowid tables are implemented as [B\*\-Trees](fileformat2.html#btree) where
all content is stored in the leaves of the tree, whereas WITHOUT ROWID
tables are implemented using ordinary B\-Trees with content stored on both
leaves and intermediate nodes. Storing content in
intermediate nodes causes each intermediate node entry to take up more
space on the page and thus reduces the fan\-out, increasing the search cost.



The "sqlite3\_analyzer.exe" utility program, available as source code
in the SQLite source tree or as a precompiled binary on the
[SQLite Download page](https://www.sqlite.org/download.html), can be
used to measure the average sizes of table rows in an existing SQLite
database.


Note that except for a few corner\-case differences detailed above,
WITHOUT ROWID tables and rowid tables work the same. They both generate
the same answers given the same SQL statements. So it is a simple matter
to run experiments on an application, late in the development cycle,
to test whether or not the use of WITHOUT ROWID tables will be helpful.
A good strategy is to simply not worry about WITHOUT ROWID until near
the end of product development, then go back and run tests to see
if adding WITHOUT ROWID to tables with non\-integer PRIMARY KEYs helps
or hurts performance, and retaining the WITHOUT ROWID only in those cases
where it helps.



