# 3\. Benefits Of WITHOUT ROWID Tables


A WITHOUT ROWID table is an optimization that can reduce storage and
processing requirements.



In an ordinary SQLite table, the PRIMARY KEY is really just a
[UNIQUE](lang_createtable.html#uniqueconst) index. The key used to look up records on disk
is the [rowid](lang_createtable.html#rowid).
The special "[INTEGER PRIMARY KEY](lang_createtable.html#rowid)" column type in ordinary SQLite tables
causes the column to be an alias for the rowid, and so an INTEGER PRIMARY
KEY is a true PRIMARY KEY. But any other kind of PRIMARY KEYs, including
"INT PRIMARY KEY" are just unique indexes in an ordinary rowid table.


Consider a table (shown below) intended to store a
vocabulary of words together with a count of the number of occurrences of
each word in some text corpus:




> ```
> 
> CREATE TABLE IF NOT EXISTS wordcount(
>   word TEXT PRIMARY KEY,
>   cnt INTEGER
> );
> 
> ```


As an ordinary SQLite table, "wordcount" is implemented as two
separate B\-Trees. The main table uses the hidden rowid value as the key
and stores the "word" and "cnt" columns as data. The "TEXT PRIMARY KEY"
phrase of the CREATE TABLE statement
causes the creation of an [unique index](lang_createindex.html#uniqueidx) on the "word" column. This index is a
separate B\-Tree that uses "word" and the "rowid" as the key and stores no
data at all. Note that the complete text of every "word" is stored twice:
once in the main table and again in the index.



Consider querying this table to find the number of occurrences of the
word "xsync".:




> ```
> 
> SELECT cnt FROM wordcount WHERE word='xsync';
> 
> ```


This query first has to search the index B\-Tree looking for any entry
that contains the matching value for "word". When an entry is found in
the index, the rowid is extracted and used to search the main table.
Then the "cnt" value is read out of the main table and returned. Hence, two
separate binary searches are required to fulfill the request.



A WITHOUT ROWID table uses a different data design for the equivalent
table.




> ```
> 
> CREATE TABLE IF NOT EXISTS wordcount(
>   word TEXT PRIMARY KEY,
>   cnt INTEGER
> ) WITHOUT ROWID;
> 
> ```


In this latter table, there is only a single B\-Tree which uses the "word"
column as its key and the "cnt" column as its data. (Technicality: the
low\-level implementation actually stores both "word" and "cnt" in the "key"
area of the B\-Tree. But unless you are looking at the low\-level byte encoding
of the database file, that fact is unimportant.) Because there is only
a single B\-Tree, the text of the "word" column is only stored once in the
database. Furthermore, querying the "cnt" value for a specific "word"
only involves a single binary search into the main B\-Tree, since the "cnt"
value can be retrieved directly from the record found by that first search
and without the need to do a second binary search on the rowid.



Thus, in some cases, a WITHOUT ROWID table can use about half the amount
of disk space and can operate nearly twice as fast. Of course, in a
real\-world schema, there will typically be secondary indices and/or
UNIQUE constraints, and the situation is more complicated. But even then,
there can often be space and performance advantages to using WITHOUT ROWID
on tables that have non\-integer or composite PRIMARY KEYs.




