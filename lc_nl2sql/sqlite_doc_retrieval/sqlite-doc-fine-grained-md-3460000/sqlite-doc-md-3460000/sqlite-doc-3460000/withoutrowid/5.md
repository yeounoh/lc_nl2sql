# 2\. Differences From Ordinary Rowid Tables


The WITHOUT ROWID syntax is an optimization. It provides no new
capabilities. Anything that can be done using a WITHOUT ROWID table
can also be done in exactly the same way, and exactly the same syntax,
using an ordinary rowid table. The only advantage of a WITHOUT ROWID
table is that it can sometimes use less disk space and/or perform a little
faster than an ordinary rowid table.


For the most part, ordinary rowid tables and WITHOUT ROWID tables
are interchangeable. But there are some additional restrictions on
WITHOUT ROWID tables that do not apply to ordinary rowid tables:


1. **Every WITHOUT ROWID table must have a PRIMARY KEY.**
An attempt to create a WITHOUT ROWID table without a PRIMARY KEY results
in an error.
2. **The special behaviors associated "[INTEGER PRIMARY KEY](lang_createtable.html#rowid)" do not apply
on WITHOUT ROWID tables.**
In an ordinary table, "INTEGER PRIMARY KEY" means that the column is an
alias for the rowid. But since there is no rowid in a WITHOUT ROWID
table, that special meaning no longer applies. An "INTEGER PRIMARY KEY"
column in a WITHOUT ROWID table works
like an "INT PRIMARY KEY" column in an ordinary table: It is a PRIMARY KEY
that has integer [affinity](datatype3.html#affinity).
3. **[AUTOINCREMENT](autoinc.html) does not work on WITHOUT ROWID tables.**
The [AUTOINCREMENT](autoinc.html) mechanism assumes the presence of a rowid and so it
does not work on a WITHOUT ROWID table. An error is raised if the
 "AUTOINCREMENT" keyword is used in the CREATE TABLE statement for
a WITHOUT ROWID table.
4. **NOT NULL is enforced on every column of the PRIMARY KEY in a WITHOUT
ROWID table.**
This is in accordance with the SQL standard. Each column of a PRIMARY KEY
is supposed to be individually NOT NULL. However, NOT NULL was not enforced
on PRIMARY KEY columns by early versions of SQLite due to a bug. By the
time that this bug was discovered, so many SQLite databases were already
in circulation that the decision was made not to fix this bug for fear of
breaking compatibility. So, ordinary rowid tables in SQLite violate the
SQL standard and allow NULL values in PRIMARY KEY fields. But WITHOUT ROWID
tables do follow the standard and will throw an error on any attempt to
insert a NULL into a PRIMARY KEY column.
5. **The [sqlite3\_last\_insert\_rowid()](c3ref/last_insert_rowid.html) function
does not work for WITHOUT ROWID tables.**
Inserts into a WITHOUT ROWID do not change the value returned by the
[sqlite3\_last\_insert\_rowid()](c3ref/last_insert_rowid.html) function. The [last\_insert\_rowid()](lang_corefunc.html#last_insert_rowid) SQL
function is also unaffected since it is just a wrapper around
[sqlite3\_last\_insert\_rowid()](c3ref/last_insert_rowid.html).
6. **The [incremental blob I/O](c3ref/blob_open.html) mechanism does not work
for WITHOUT ROWID tables.**
Incremental BLOB I/O uses the rowid to create an [sqlite3\_blob](c3ref/blob.html) object for
doing the direct I/O. However, WITHOUT ROWID tables do not have a rowid,
and so there is no way to create an [sqlite3\_blob](c3ref/blob.html) object for a WITHOUT
ROWID table.
7. **The [sqlite3\_update\_hook()](c3ref/update_hook.html) interface does not fire callbacks for changes
to a WITHOUT ROWID table.**
Part of the callback from [sqlite3\_update\_hook()](c3ref/update_hook.html) is the rowid of the table
row that has changed. However, WITHOUT ROWID tables do not have a rowid.
Hence, the update hook is not invoked when a WITHOUT ROWID table changes.



