# 5\. User\-Defined Aggregate Window Functions


 User\-defined aggregate window functions may be created using the
[sqlite3\_create\_window\_function](c3ref/create_function.html)() API. Implementing an aggregate window
function is very similar to an ordinary aggregate function. Any user\-defined
aggregate window function may also be used as an ordinary aggregate. To
implement a user\-defined aggregate window function the application must
supply four callback functions:





| Callback | Description |
| --- | --- |
| xStep | This method is required by both window aggregate and legacy aggregate  function implementations. It is invoked to add a row to the current  window. The function arguments, if any, corresponding to the row being  added are passed to the implementation of xStep. |
| xFinal | This method is required by both window aggregate and legacy aggregate  function implementations. It is invoked to return the current value  of the aggregate (determined by the contents of the current window),  and to free any resources allocated by earlier calls to xStep. |
| xValue | This method is only required for window aggregate functions. The presence  of this method is what distinguishes a window aggregate function from a  legacy aggregate function. This method is invoked to return the current  value of the aggregate. Unlike xFinal, the implementation should not  delete any context. |
| xInverse | This method is only required for window aggregate functions, not legacy  aggregate function implementations. It is invoked to remove the oldest  presently aggregated result of xStep from the current window.  The function arguments, if any, are those  passed to xStep for the row being removed. |


 The C code below implements a simple window aggregate function named
sumint(). This works in the same way as the built\-in sum() function, except
that it throws an exception if passed an argument that is not an integer
value.




```

```

/*
** xStep for sumint().
**
** Add the value of the argument to the aggregate context (an integer).
*/
static void sumintStep(
  [sqlite3_context](c3ref/context.html) *ctx,
  int nArg,
  [sqlite3_value](c3ref/value.html) *apArg[]
){
  [sqlite3_int64](c3ref/int64.html) *pInt;

  assert( nArg==1 );
  if( [sqlite3_value_type](c3ref/value_blob.html)(apArg[0])!=SQLITE_INTEGER ){
    [sqlite3_result_error](c3ref/result_blob.html)(ctx, "invalid argument", -1);
    return;
  }
  pInt = (sqlite3_int64*)sqlite3_aggregate_context(ctx, sizeof([sqlite3_int64](c3ref/int64.html)));
  if( pInt ){
    *pInt += [sqlite3_value_int64](c3ref/value_blob.html)(apArg[0]);
  }
}

/*
** xInverse for sumint().
**
** This does the opposite of xStep() - subtracts the value of the argument
** from the current context value. The error checking can be omitted from
** this function, as it is only ever called after xStep() (so the aggregate
** context has already been allocated) and with a value that has already
** been passed to xStep() without error (so it must be an integer).
*/
static void sumintInverse(
  [sqlite3_context](c3ref/context.html) *ctx,
  int nArg,
  [sqlite3_value](c3ref/value.html) *apArg[]
){
  [sqlite3_int64](c3ref/int64.html) *pInt;
  assert( [sqlite3_value_type](c3ref/value_blob.html)(apArg[0])==SQLITE_INTEGER );
  pInt = (sqlite3_int64*)sqlite3_aggregate_context(ctx, sizeof([sqlite3_int64](c3ref/int64.html)));
  *pInt -= [sqlite3_value_int64](c3ref/value_blob.html)(apArg[0]);
}

/*
** xFinal for sumint().
**
** Return the current value of the aggregate window function. Because
** this implementation does not allocate any resources beyond the buffer
** returned by [sqlite3_aggregate_context](c3ref/aggregate_context.html), which is automatically freed
** by the system, there are no resources to free. And so this method is
** identical to xValue().
*/
static void sumintFinal([sqlite3_context](c3ref/context.html) *ctx){
  [sqlite3_int64](c3ref/int64.html) res = 0;
  [sqlite3_int64](c3ref/int64.html) *pInt;
  pInt = (sqlite3_int64*)[sqlite3_aggregate_context](c3ref/aggregate_context.html)(ctx, 0);
  if( pInt ) res = *pInt;
  [sqlite3_result_int64](c3ref/result_blob.html)(ctx, res);
}

/*
** xValue for sumint().
**
** Return the current value of the aggregate window function.
*/
static void sumintValue([sqlite3_context](c3ref/context.html) *ctx){
  [sqlite3_int64](c3ref/int64.html) res = 0;
  [sqlite3_int64](c3ref/int64.html) *pInt;
  pInt = (sqlite3_int64*)[sqlite3_aggregate_context](c3ref/aggregate_context.html)(ctx, 0);
  if( pInt ) res = *pInt;
  [sqlite3_result_int64](c3ref/result_blob.html)(ctx, res);
}

/*
** Register sumint() window aggregate with database handle db.
*/
int register_sumint([sqlite3](c3ref/sqlite3.html) *db){
  return [sqlite3_create_window_function](c3ref/create_function.html)(db, "sumint", 1, SQLITE_UTF8, 0,
      sumintStep, sumintFinal, sumintValue, sumintInverse, 0
  );
}

```



```

 The following example uses the sumint() function implemented by the above
C code. For each row, the window consists of the preceding row (if any), the current row and the following row (again, if any):




```
CREATE TABLE t3(x, y);
INSERT INTO t3 VALUES('a', 4),
                     ('b', 5),
                     ('c', 3),
                     ('d', 8),
                     ('e', 1);

-- Assuming the database is populated using the above script, the 
-- following SELECT statement returns:
-- 
--   x | sum_y
--------------
--   a | 9    
--   b | 12   
--   c | 16   
--   d | 12   
--   e | 9    
-- 
SELECT x, sumint(y) OVER (
  ORDER BY x ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
) AS sum_y
FROM t3 ORDER BY x;

```

In processing the query above, SQLite invokes the sumint callbacks as
follows:






1. **xStep(4\)** \- add "4" to the current window.
2. **xStep(5\)** \- add "5" to the current window.
3. **xValue()** \- invoke xValue() to obtain the value of sumint() for
 the row with (x\='a'). The window currently consists of values 4 and 5,
 and so the result is 9\.
4. **xStep(3\)** \- add "3" to the current window.
5. **xValue()** \- invoke xValue() to obtain the value of sumint() for
 the row with (x\='b'). The window currently consists of values 4, 5 and
 3, and so the result is 12\.
6. **xInverse(4\)** \- remove "4" from the window.
7. **xStep(8\)** \- add "8" to the current window. The window now consists
 of values 5, 3 and 8\.
8. **xValue()** \- invoked to obtain the value for the row with (x\='c').
 In this case, 16\.
9. **xInverse(5\)** \- remove value "5" from the window.
10. **xStep(1\)** \- add value "1" to the window.
11. **xValue()** \- invoked to obtain the value for row (x\='d').
12. **xInverse(3\)** \- remove value "3" from the window. The window now
 contains values 8 and 1 only.
13. **xFinal()** \- invoked to reclaim any allocated resources and to
 obtain the value for row (x\='e'). 9\. .


If the user were to abandon query execution by calling sqlite3\_reset() or
sqlite3\_finalize() on the statement handle before SQLite has called xFinal(),
then xFinal() is called automatically from within the sqlite3\_reset() or
sqlite3\_finalize() call in order to reclaim any allocated resources, even
though the value is not required. In this case any error returned by the xFinal
implementation is silently discarded.



