# 3\. Built\-in Window Functions


 As well as aggregate window functions, SQLite features a set of built\-in
window functions based on
[those supported by PostgreSQL](https://www.postgresql.org/docs/10/static/functions-window.html).



 Built\-in window functions honor any PARTITION BY clause in the same way
as aggregate window functions \- each selected row is assigned to a partition
and each partition is processed separately. The ways in which any ORDER BY
clause affects each built\-in window function is described below. Some of
the window functions (rank(), dense\_rank(), percent\_rank() and ntile()) use
the concept of "peer groups" (rows within the same partition that have the
same values for all ORDER BY expressions). In these cases, it does not matter
whether the frame\-spec specifies ROWS, GROUPS, or RANGE.
For the purposes of built\-in window function processing, rows with the same values
for all ORDER BY expressions are considered peers regardless of the frame type.



 Most built\-in window functions ignore the
frame\-spec, the exceptions being first\_value(),
last\_value() and nth\_value(). It is a syntax error to specify a FILTER
clause as part of a built\-in window function invocation.




 SQLite supports the following 11 built\-in window functions:




**row\_number()**


 The number of the row within the current partition. Rows are
 numbered starting from 1 in the order defined by the ORDER BY clause in
 the window definition, or in arbitrary order otherwise.
 

**rank()**


 The row\_number() of the first peer in each group \- the rank of the
 current row with gaps. If there is no ORDER BY clause, then all rows
 are considered peers and this function always returns 1\.
 

**dense\_rank()**


 The number of the current row's peer group within its partition \- the
 rank of the current row without gaps. Rows are numbered starting
 from 1 in the order defined by the ORDER BY clause in the window
 definition. If there is no ORDER BY clause, then all rows are
 considered peers and this function always returns 1\.
 

**percent\_rank()**


 Despite the name, this function always returns a value between 0\.0
 and 1\.0 equal to (*rank* \- 1\)/(*partition\-rows* \- 1\), where
 *rank* is the value returned by built\-in window function rank()
 and *partition\-rows* is the total number of rows in the
 partition. If the partition contains only one row, this function
 returns 0\.0\.
 

**cume\_dist()**


 The cumulative distribution. Calculated as
 *row\-number*/*partition\-rows*, where *row\-number* is
 the value returned by row\_number() for the last peer in the group
 and *partition\-rows* the number of rows in the partition.
 

**ntile(N)**


 Argument *N* is handled as an integer. This function divides the
 partition into N groups as evenly as possible and assigns an integer
 between 1 and *N* to each group, in the order defined by the ORDER
 BY clause, or in arbitrary order otherwise. If necessary, larger groups
 occur first. This function returns the integer value assigned to the
 group that the current row is a part of.

 

**lag(expr)  
lag(expr, offset)  
lag(expr, offset, default)**


 The first form of the lag() function returns the result of evaluating
 expression *expr* against the previous row in the partition. Or, if
 there is no previous row (because the current row is the first), NULL.

 

 If the *offset* argument is provided, then it must be a
 non\-negative integer. In this case the value returned is the result
 of evaluating *expr* against the row *offset* rows before the
 current row within the partition. If *offset* is 0, then
 *expr* is evaluated against the current row. If there is no row
 *offset* rows before the current row, NULL is returned.

 

 If *default* is also provided, then it is returned instead of
 NULL if the row identified by *offset* does not exist.

 

**lead(expr)  
lead(expr, offset)  
lead(expr, offset, default)**


 The first form of the lead() function returns the result of evaluating
 expression *expr* against the next row in the partition. Or, if
 there is no next row (because the current row is the last), NULL.

 

 If the *offset* argument is provided, then it must be a
 non\-negative integer. In this case the value returned is the result
 of evaluating *expr* against the row *offset* rows after the
 current row within the partition. If *offset* is 0, then
 *expr* is evaluated against the current row. If there is no row
 *offset* rows after the current row, NULL is returned.

 

 If *default* is also provided, then it is returned instead of
 NULL if the row identified by *offset* does not exist.
 

**first\_value(expr)**


 This built\-in window function calculates the window frame for each
 row in the same way as an aggregate window function. It returns the
 value of *expr* evaluated against the first row in the window frame
 for each row.
 

**last\_value(expr)**


 This built\-in window function calculates the window frame for each
 row in the same way as an aggregate window function. It returns the
 value of *expr* evaluated against the last row in the window frame
 for each row.
 

**nth\_value(expr, N)**


 This built\-in window function calculates the window frame for each
 row in the same way as an aggregate window function. It returns the
 value of *expr* evaluated against the row *N* of the window
 frame. Rows are numbered within the window frame starting from 1 in
 the order defined by the ORDER BY clause if one is present, or in
 arbitrary order otherwise. If there is no *N*th row in the
 partition, then NULL is returned.
 



The examples in this section use the
[previously defined T1 table](windowfunctions.html#aggwinfunc)
as well as the following T2 table:




```
CREATE TABLE t2(a, b);
INSERT INTO t2 VALUES('a', 'one'),
                     ('a', 'two'),
                     ('a', 'three'),
                     ('b', 'four'),
                     ('c', 'five'),
                     ('c', 'six');

```

The following example illustrates the behaviour of the five ranking
functions \- row\_number(), rank(), dense\_rank(), percent\_rank() and
cume\_dist().




```
-- The following SELECT statement returns:
-- 
--   a | row_number | rank | dense_rank | percent_rank | cume_dist
------------------------------------------------------------------
--   a |          1 |    1 |          1 |          0.0 |       0.5
--   a |          2 |    1 |          1 |          0.0 |       0.5
--   a |          3 |    1 |          1 |          0.0 |       0.5
--   b |          4 |    4 |          2 |          0.6 |       0.66
--   c |          5 |    5 |          3 |          0.8 |       1.0
--   c |          6 |    5 |          3 |          0.8 |       1.0
-- 
SELECT a                        AS a,
       row_number() OVER win    AS row_number,
       rank() OVER win          AS rank,
       dense_rank() OVER win    AS dense_rank,
       percent_rank() OVER win  AS percent_rank,
       cume_dist() OVER win     AS cume_dist
FROM t2
WINDOW win AS (ORDER BY a);

```

The example below uses ntile() to divide the six rows into two groups (the
ntile(2\) call) and into four groups (the ntile(4\) call). For ntile(2\), there
are three rows assigned to each group. For ntile(4\), there are two groups of
two and two groups of one. The larger groups of two appear first.




```
-- The following SELECT statement returns:
-- 
--   a | b     | ntile_2 | ntile_4
----------------------------------
--   a | one   |       1 |       1
--   a | two   |       1 |       1
--   a | three |       1 |       2
--   b | four  |       2 |       2
--   c | five  |       2 |       3
--   c | six   |       2 |       4
-- 
SELECT a                        AS a,
       b                        AS b,
       ntile(2) OVER win        AS ntile_2,
       ntile(4) OVER win        AS ntile_4
FROM t2
WINDOW win AS (ORDER BY a);

```

 The next example demonstrates lag(), lead(), first\_value(), last\_value()
and nth\_value(). The frame\-spec is ignored by
both lag() and lead(), but respected by first\_value(), last\_value()
and nth\_value().




```
-- The following SELECT statement returns:
-- 
--   b | lead | lag  | first_value | last_value | nth_value_3
-------------------------------------------------------------
--   A | C    | NULL | A           | A          | NULL       
--   B | D    | A    | A           | B          | NULL       
--   C | E    | B    | A           | C          | C          
--   D | F    | C    | A           | D          | C          
--   E | G    | D    | A           | E          | C          
--   F | n/a  | E    | A           | F          | C          
--   G | n/a  | F    | A           | G          | C          
-- 
SELECT b                          AS b,
       lead(b, 2, 'n/a') OVER win AS lead,
       lag(b) OVER win            AS lag,
       first_value(b) OVER win    AS first_value,
       last_value(b) OVER win     AS last_value,
       nth_value(b, 3) OVER win   AS nth_value_3
FROM t1
WINDOW win AS (ORDER BY b ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)

```


