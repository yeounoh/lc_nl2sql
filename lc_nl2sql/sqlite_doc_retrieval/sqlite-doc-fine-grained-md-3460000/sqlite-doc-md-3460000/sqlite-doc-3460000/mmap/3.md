## Configuring Memory\-Mapped I/O


The "mmap\_size" is the maximum number of bytes of the database file that
SQLite will try to map into the process address space at one time. The
mmap\_size applies separately to each database file, so the total amount
of process address space that could potentially be used is the mmap\_size
times the number of open database files.


To activate memory\-mapped I/O, an application can set the mmap\_size to some
large value. For example:



> ```
> 
> PRAGMA mmap_size=268435456;
> 
> ```


To disable memory\-mapped I/O, simply set the mmap\_size to zero:



> ```
> 
> PRAGMA mmap_size=0;
> 
> ```


If mmap\_size is set to N then all current implementations map the first
N bytes of the database file and use legacy xRead() calls for any content
beyond N bytes. If the database file is smaller than N bytes, then the entire
file is mapped. In the future, new OS interfaces could, in theory, map
regions of the file other than the first N bytes, but no such 
implementation currently exists.


The mmap\_size is set separately for each database file using the
"[PRAGMA mmap\_size](pragma.html#pragma_mmap_size)" statement. The usual default mmap\_size is zero,
meaning that memory mapped I/O is disabled by default. However, the
default mmap\_size can be increased either at compile\-time using
the [SQLITE\_DEFAULT\_MMAP\_SIZE](compile.html#default_mmap_size) macro or at start\-time using the
[sqlite3\_config](c3ref/config.html)([SQLITE\_CONFIG\_MMAP\_SIZE](c3ref/c_config_covering_index_scan.html#sqliteconfigmmapsize),...) interface.


SQLite also maintains a hard upper bound on the mmap\_size. Attempts
to increase the mmap\_size above this hard upper bound (using
[PRAGMA mmap\_size](pragma.html#pragma_mmap_size)) will automatically cap the mmap\_size at the hard
upper bound. If the hard upper bound is zero, then memory mapped I/O
is impossible. The hard upper bound can be set at compile\-time using
the [SQLITE\_MAX\_MMAP\_SIZE](compile.html#max_mmap_size) macro. If [SQLITE\_MAX\_MMAP\_SIZE](compile.html#max_mmap_size) is set to
zero, then the code used to implement memory mapped I/O is omitted from
the build. The hard upper bound is automatically set to zero on certain
platforms (ex: OpenBSD) where memory mapped I/O does not work due to the
lack of a unified buffer cache.


If the hard upper bound on mmap\_size is non\-zero at compilation time,
it may still be reduced or zeroed at start\-time using the
[sqlite3\_config](c3ref/config.html)([SQLITE\_CONFIG\_MMAP\_SIZE](c3ref/c_config_covering_index_scan.html#sqliteconfigmmapsize),X,Y) interface. The X and
Y parameters must both be 64\-bit signed integers. The X parameter
is the default mmap\_size of the process and the Y is the new hard upper bound.
The hard upper bound cannot be increased above its compile\-time setting
using [SQLITE\_CONFIG\_MMAP\_SIZE](c3ref/c_config_covering_index_scan.html#sqliteconfigmmapsize) but it can be reduced or zeroed.


*This page last modified on [2022\-04\-18 02:55:50](https://sqlite.org/docsrc/honeypot) UTC* 




