# Memory\-Mapped I/O


The default mechanism by which SQLite accesses and updates database disk
files is the xRead() and xWrite() methods of the
[sqlite3\_io\_methods](c3ref/io_methods.html) VFS object. These methods are typically implemented as
"read()" and "write()" system calls which cause the operating system
to copy disk content between the kernel buffer cache and user space.


Beginning with [version 3\.7\.17](releaselog/3_7_17.html) (2013\-05\-20\), SQLite has the option of 
accessing disk content directly using memory\-mapped I/O and the new
xFetch() and xUnfetch() methods on [sqlite3\_io\_methods](c3ref/io_methods.html).


There are advantages and disadvantages to using memory\-mapped I/O.
Advantages include:


1. Many operations, especially I/O intensive operations, can be
 faster since content need not be copied between kernel space
 and user space.

- The SQLite library may need less RAM since it shares pages with
 the operating\-system page cache and does not always need its own copy of
 working pages.


But there are also disadvantages:


1. An I/O error on a memory\-mapped file cannot be caught and dealt with by
 SQLite. Instead, the I/O error causes a signal which, if not caught
 by the application, results in a program crash.

- The operating system must have a unified buffer cache in order for
 the memory\-mapped I/O extension to work correctly, especially in
 situations where two processes are accessing the same database
 file and one process is using memory\-mapped I/O while the other
 is not. Not all operating systems have a unified buffer cache.
 In some operating systems that claim to have a unified buffer cache,
 the implementation is buggy and can lead to corrupt databases.

- Performance does not always increase with memory\-mapped I/O. In fact,
 it is possible to construct test cases where performance is reduced
 by the use of memory\-mapped I/O.

- Windows is unable to truncate a memory\-mapped file. Hence, on Windows,
 if an operation such as [VACUUM](lang_vacuum.html) or [auto\_vacuum](pragma.html#pragma_auto_vacuum) tries to reduce the
 size of a memory\-mapped database file, the size reduction attempt will
 silently fail, leaving unused space at the end of the database file.
 No data is lost due to this problem, and the unused space will be
 reused again the next time the database grows. However if a version 
 of SQLite prior to 3\.7\.0 runs [PRAGMA integrity\_check](pragma.html#pragma_integrity_check) on such a 
 database, it will (incorrectly) report database corruption due to 
 the unused space at the end. Or if a version of SQLite prior to 3\.7\.0
 writes to the database while it still has unused space at the end, it
 may make that unused space inaccessible and unavailable for reuse until
 after the next [VACUUM](lang_vacuum.html).


Because of the potential disadvantages, memory\-mapped I/O is disabled
by default. To activate memory\-mapped I/O, use the [mmap\_size pragma](pragma.html#pragma_mmap_size)
and set the mmap\_size to some large number, usually 256MB or larger, depending
on how much address space your application can spare. The rest is
automatic. The [PRAGMA mmap\_size](pragma.html#pragma_mmap_size) statement will be a silent no\-op on
systems that do not support memory\-mapped I/O.


