#### 2\.2 Executing SQL statements



> ```
> 
>    typedef int (*sqlite_callback)(void*,int,char**, char**);
>    int sqlite3_exec(sqlite3*, const char *sql, sqlite_callback, void*, char**);
> 
> ```



The [sqlite3\_exec()](c3ref/exec.html) function works much as it did in SQLite version 2\.
Zero or more SQL statements specified in the second parameter are compiled
and executed. Query results are returned to a callback routine.




In SQLite version 3, the sqlite3\_exec routine is just a wrapper around
calls to the prepared statement interface.




> ```
> 
>    typedef struct sqlite3_stmt sqlite3_stmt;
>    int sqlite3_prepare(sqlite3*, const char*, int, sqlite3_stmt**, const char**);
>    int sqlite3_prepare16(sqlite3*, const void*, int, sqlite3_stmt**, const void**);
>    int sqlite3_finalize(sqlite3_stmt*);
>    int sqlite3_reset(sqlite3_stmt*);
> 
> ```



The sqlite3\_prepare interface compiles a single SQL statement into byte code
for later execution. This interface is now the preferred way of accessing
the database.




The SQL statement is a UTF\-8 string for sqlite3\_prepare().
The sqlite3\_prepare16() works the same way except
that it expects a UTF\-16 string as SQL input.
Only the first SQL statement in the input string is compiled.
The fifth parameter is filled in with a pointer to the next (uncompiled)
SQLite statement in the input string, if any.
The sqlite3\_finalize() routine deallocates a prepared SQL statement.
All prepared statements must be finalized before the database can be
closed.
The sqlite3\_reset() routine resets a prepared SQL statement so that it
can be executed again.




The SQL statement may contain tokens of the form "?" or "?nnn" or ":aaa"
where "nnn" is an integer and "aaa" is an identifier.
Such tokens represent unspecified literal values (or "wildcards")
to be filled in later by the 
[sqlite3\_bind](c3ref/bind_blob.html) interface.
Each wildcard has an associated number which is its sequence in the
statement or the "nnn" in the case of a "?nnn" form. 
It is allowed for the same wildcard
to occur more than once in the same SQL statement, in which case
all instance of that wildcard will be filled in with the same value.
Unbound wildcards have a value of NULL.




> ```
> 
>    int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));
>    int sqlite3_bind_double(sqlite3_stmt*, int, double);
>    int sqlite3_bind_int(sqlite3_stmt*, int, int);
>    int sqlite3_bind_int64(sqlite3_stmt*, int, long long int);
>    int sqlite3_bind_null(sqlite3_stmt*, int);
>    int sqlite3_bind_text(sqlite3_stmt*, int, const char*, int n, void(*)(void*));
>    int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int n, void(*)(void*));
>    int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);
> 
> ```



There is an assortment of sqlite3\_bind routines used to assign values
to wildcards in a prepared SQL statement. Unbound wildcards
are interpreted as NULLs. Bindings are not reset by sqlite3\_reset().
But wildcards can be rebound to new values after an sqlite3\_reset().




After an SQL statement has been prepared (and optionally bound), it
is executed using:




> ```
> 
>    int sqlite3_step(sqlite3_stmt*);
> 
> ```



The sqlite3\_step() routine return SQLITE\_ROW if it is returning a single
row of the result set, or SQLITE\_DONE if execution has completed, either
normally or due to an error. It might also return SQLITE\_BUSY if it is
unable to open the database file. If the return value is SQLITE\_ROW, then
the following routines can be used to extract information about that row
of the result set:




> ```
> 
>    const void *sqlite3_column_blob(sqlite3_stmt*, int iCol);
>    int sqlite3_column_bytes(sqlite3_stmt*, int iCol);
>    int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);
>    int sqlite3_column_count(sqlite3_stmt*);
>    const char *sqlite3_column_decltype(sqlite3_stmt *, int iCol);
>    const void *sqlite3_column_decltype16(sqlite3_stmt *, int iCol);
>    double sqlite3_column_double(sqlite3_stmt*, int iCol);
>    int sqlite3_column_int(sqlite3_stmt*, int iCol);
>    long long int sqlite3_column_int64(sqlite3_stmt*, int iCol);
>    const char *sqlite3_column_name(sqlite3_stmt*, int iCol);
>    const void *sqlite3_column_name16(sqlite3_stmt*, int iCol);
>    const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);
>    const void *sqlite3_column_text16(sqlite3_stmt*, int iCol);
>    int sqlite3_column_type(sqlite3_stmt*, int iCol);
> 
> ```



The [sqlite3\_column\_count()](c3ref/column_count.html)
function returns the number of columns in
the results set. sqlite3\_column\_count() can be called at any time after
[sqlite3\_prepare\_v2()](c3ref/prepare.html). [sqlite3\_data\_count()](c3ref/data_count.html) works similarly to
[sqlite3\_column\_count()](c3ref/column_count.html) except that it only works following [sqlite3\_step()](c3ref/step.html).
If the previous call to [sqlite3\_step()](c3ref/step.html) returned SQLITE\_DONE or an error code,
then [sqlite3\_data\_count()](c3ref/data_count.html) will return 0 whereas [sqlite3\_column\_count()](c3ref/column_count.html) will
continue to return the number of columns in the result set.



Returned data is examined using the other 
[sqlite3\_column\_\*\*\*()](c3ref/column_blob.html) functions, 
all of which take a column number as their second parameter. Columns are
zero\-indexed from left to right. Note that this is different to parameters,
which are indexed starting at one.




The [sqlite3\_column\_type()](c3ref/column_blob.html) function returns the
datatype for the value in the Nth column. The return value is one
of these:




> ```
> 
>    #define SQLITE_INTEGER  1
>    #define SQLITE_FLOAT    2
>    #define SQLITE_TEXT     3
>    #define SQLITE_BLOB     4
>    #define SQLITE_NULL     5
> 
> ```



The sqlite3\_column\_decltype() routine returns text which is the
declared type of the column in the CREATE TABLE statement. For an
expression, the return type is an empty string. sqlite3\_column\_name()
returns the name of the Nth column. sqlite3\_column\_bytes() returns
the number of bytes in a column that has type BLOB or the number of bytes
in a TEXT string with UTF\-8 encoding. sqlite3\_column\_bytes16() returns
the same value for BLOBs but for TEXT strings returns the number of bytes
in a UTF\-16 encoding.
sqlite3\_column\_blob() return BLOB data. 
sqlite3\_column\_text() return TEXT data as UTF\-8\.
sqlite3\_column\_text16() return TEXT data as UTF\-16\.
sqlite3\_column\_int() return INTEGER data in the host machines native
integer format.
sqlite3\_column\_int64() returns 64\-bit INTEGER data.
Finally, sqlite3\_column\_double() return floating point data.




It is not necessary to retrieve data in the format specify by
sqlite3\_column\_type(). If a different format is requested, the data
is converted automatically.




Data format conversions can invalidate the pointer returned by
prior calls to sqlite3\_column\_blob(), sqlite3\_column\_text(), and/or
sqlite3\_column\_text16(). Pointers might be invalided in the following
cases:



* The initial content is a BLOB and sqlite3\_column\_text() 
or sqlite3\_column\_text16()
is called. A zero\-terminator might need to be added to the string.
* The initial content is UTF\-8 text and sqlite3\_column\_bytes16() or
sqlite3\_column\_text16() is called. The content must be converted to UTF\-16\.
* The initial content is UTF\-16 text and sqlite3\_column\_bytes() or
sqlite3\_column\_text() is called. The content must be converted to UTF\-8\.



Note that conversions between UTF\-16be and UTF\-16le 
are always done in place and do
not invalidate a prior pointer, though of course the content of the buffer
that the prior pointer points to will have been modified. Other kinds
of conversion are done in place when it is possible, but sometime it is
not possible and in those cases prior pointers are invalidated. 




The safest and easiest to remember policy is this: assume that any
result from
* sqlite3\_column\_blob(),
* sqlite3\_column\_text(), or
* sqlite3\_column\_text16()


is invalided by subsequent calls to 
* sqlite3\_column\_bytes(),
* sqlite3\_column\_bytes16(),
* sqlite3\_column\_text(), or
* sqlite3\_column\_text16().


This means that you should always call sqlite3\_column\_bytes() or
sqlite3\_column\_bytes16() before calling sqlite3\_column\_blob(),
sqlite3\_column\_text(), or sqlite3\_column\_text16().



