#### 2\.3 User\-defined functions



User defined functions can be created using the following routine:




> ```
> 
>    typedef struct sqlite3_value sqlite3_value;
>    int sqlite3_create_function(
>      sqlite3 *,
>      const char *zFunctionName,
>      int nArg,
>      int eTextRep,
>      void*,
>      void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
>      void (*xStep)(sqlite3_context*,int,sqlite3_value**),
>      void (*xFinal)(sqlite3_context*)
>    );
>    int sqlite3_create_function16(
>      sqlite3*,
>      const void *zFunctionName,
>      int nArg,
>      int eTextRep,
>      void*,
>      void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
>      void (*xStep)(sqlite3_context*,int,sqlite3_value**),
>      void (*xFinal)(sqlite3_context*)
>    );
>    #define SQLITE_UTF8     1
>    #define SQLITE_UTF16    2
>    #define SQLITE_UTF16BE  3
>    #define SQLITE_UTF16LE  4
>    #define SQLITE_ANY      5
> 
> ```



The nArg parameter specifies the number of arguments to the function.
A value of 0 indicates that any number of arguments is allowed. The
eTextRep parameter specifies what representation text values are expected
to be in for arguments to this function. The value of this parameter should
be one of the parameters defined above. SQLite version 3 allows multiple
implementations of the same function using different text representations.
The database engine chooses the function that minimization the number
of text conversions required.




Normal functions specify only xFunc and leave xStep and xFinal set to NULL.
Aggregate functions specify xStep and xFinal and leave xFunc set to NULL.
There is no separate sqlite3\_create\_aggregate() API.




The function name is specified in UTF\-8\. A separate sqlite3\_create\_function16()
API works the same as sqlite\_create\_function()
except that the function name is specified in UTF\-16 host byte order.




Notice that the parameters to functions are now pointers to sqlite3\_value
structures instead of pointers to strings as in SQLite version 2\.X.
The following routines are used to extract useful information from these
"values":




> ```
> 
>    const void *sqlite3_value_blob(sqlite3_value*);
>    int sqlite3_value_bytes(sqlite3_value*);
>    int sqlite3_value_bytes16(sqlite3_value*);
>    double sqlite3_value_double(sqlite3_value*);
>    int sqlite3_value_int(sqlite3_value*);
>    long long int sqlite3_value_int64(sqlite3_value*);
>    const unsigned char *sqlite3_value_text(sqlite3_value*);
>    const void *sqlite3_value_text16(sqlite3_value*);
>    int sqlite3_value_type(sqlite3_value*);
> 
> ```



Function implementations use the following APIs to acquire context and
to report results:




> ```
> 
>    void *sqlite3_aggregate_context(sqlite3_context*, int nbyte);
>    void *sqlite3_user_data(sqlite3_context*);
>    void sqlite3_result_blob(sqlite3_context*, const void*, int n, void(*)(void*));
>    void sqlite3_result_double(sqlite3_context*, double);
>    void sqlite3_result_error(sqlite3_context*, const char*, int);
>    void sqlite3_result_error16(sqlite3_context*, const void*, int);
>    void sqlite3_result_int(sqlite3_context*, int);
>    void sqlite3_result_int64(sqlite3_context*, long long int);
>    void sqlite3_result_null(sqlite3_context*);
>    void sqlite3_result_text(sqlite3_context*, const char*, int n, void(*)(void*));
>    void sqlite3_result_text16(sqlite3_context*, const void*, int n, void(*)(void*));
>    void sqlite3_result_value(sqlite3_context*, sqlite3_value*);
>    void *sqlite3_get_auxdata(sqlite3_context*, int);
>    void sqlite3_set_auxdata(sqlite3_context*, int, void*, void (*)(void*));
> 
> ```


