## 2\.14\. The xFindFunction Method



```
int (*xFindFunction)(
  sqlite3_vtab *pVtab,
  int nArg,
  const char *zName,
  void (**pxFunc)(sqlite3_context*,int,sqlite3_value**),
  void **ppArg
);

```

This method is called during [sqlite3\_prepare()](c3ref/prepare.html) to give the virtual
table implementation an opportunity to overload functions. 
This method may be set to NULL in which case no overloading occurs.



When a function uses a column from a virtual table as its first 
argument, this method is called to see if the virtual table would 
like to overload the function. The first three parameters are inputs: 
the virtual table, the number of arguments to the function, and the 
name of the function. If no overloading is desired, this method
returns 0\. To overload the function, this method writes the new 
function implementation into \*pxFunc and writes user data into \*ppArg 
and returns either 1 or a number between
[SQLITE\_INDEX\_CONSTRAINT\_FUNCTION](c3ref/c_index_constraint_eq.html) and 255\.



Historically, the return value from xFindFunction() was either zero
or one. Zero means that the function is not overloaded and one means that
it is overload. The ability to return values of 
[SQLITE\_INDEX\_CONSTRAINT\_FUNCTION](c3ref/c_index_constraint_eq.html) or greater was added in
version 3\.25\.0 (2018\-09\-15\). If xFindFunction returns
[SQLITE\_INDEX\_CONSTRAINT\_FUNCTION](c3ref/c_index_constraint_eq.html) or greater, than means that the function
takes two arguments and the function
can be used as a boolean in the WHERE clause of a query and that
the virtual table is able to exploit that function to speed up the query
result. When xFindFunction returns [SQLITE\_INDEX\_CONSTRAINT\_FUNCTION](c3ref/c_index_constraint_eq.html) or 
larger, the value returned becomes the [sqlite3\_index\_info](c3ref/index_info.html).aConstraint.op
value for one of the constraints passed into [xBestIndex()](vtab.html#xbestindex). The first
argument to the function is the column identified by 
aConstraint\[].iColumn field of the constraint and the second argument to the
function is the value that will be passed into [xFilter()](vtab.html#xfilter) (if the
aConstraintUsage\[].argvIndex value is set) or the value returned from
[sqlite3\_vtab\_rhs\_value()](c3ref/vtab_rhs_value.html).



The [Geopoly module](geopoly.html) is an example of a virtual table that makes use
of [SQLITE\_INDEX\_CONSTRAINT\_FUNCTION](c3ref/c_index_constraint_eq.html) to improve performance.
The xFindFunction() method for Geopoly returns
SQLITE\_INDEX\_CONSTRAINT\_FUNCTION for the [geopoly\_overlap()](geopoly.html#goverlap) SQL function
and it returns
SQLITE\_INDEX\_CONSTRAINT\_FUNCTION\+1 for the [geopoly\_within()](geopoly.html#gwithin) SQL function.
This permits search optimizations for queries such as:




```
SELECT * FROM geopolytab WHERE geopoly_overlap(_shape, $query_polygon);
SELECT * FROM geopolytab WHERE geopoly_within(_shape, $query_polygon);

```

Note that infix functions ([LIKE](lang_expr.html#like), [GLOB](lang_expr.html#glob), [REGEXP](lang_expr.html#regexp), and [MATCH](lang_expr.html#match)) reverse 
the order of their arguments. So "like(A,B)" would normally work the same
as "B like A".
However, xFindFunction() always looks a the left\-most argument, not
the first logical argument.
Hence, for the form "B like A", SQLite looks at the
left operand "B" and if that operand is a virtual table column
it invokes the xFindFunction() method on that virtual table.
But if the form "like(A,B)" is used instead, then SQLite checks
the A term to see if it is column of a virtual table and if so
it invokes the xFindFunction() method for the virtual table of
column A. 



The function pointer returned by this routine must be valid for
the lifetime of the [sqlite3\_vtab](c3ref/vtab.html) object given in the first parameter.




