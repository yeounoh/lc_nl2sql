## 1\.2\. Implementation


Several new C\-level objects are used by the virtual table implementation:




```
typedef struct sqlite3_vtab sqlite3_vtab;
typedef struct sqlite3_index_info sqlite3_index_info;
typedef struct sqlite3_vtab_cursor sqlite3_vtab_cursor;
typedef struct sqlite3_module sqlite3_module;

```

The [sqlite3\_module](c3ref/module.html) structure defines a module object used to implement
a virtual table. Think of a module as a class from which one can 
construct multiple virtual tables having similar properties. For example,
one might have a module that provides read\-only access to 
comma\-separated\-value (CSV) files on disk. That one module can then be
used to create several virtual tables where each virtual table refers
to a different CSV file.



The module structure contains methods that are invoked by SQLite to
perform various actions on the virtual table such as creating new
instances of a virtual table or destroying old ones, reading and
writing data, searching for and deleting, updating, or inserting rows. 
The module structure is explained in more detail below.



Each virtual table instance is represented by an [sqlite3\_vtab](c3ref/vtab.html) structure. 
The sqlite3\_vtab structure looks like this:




```
struct sqlite3_vtab {
  const sqlite3_module *pModule;
  int nRef;
  char *zErrMsg;
};

```

Virtual table implementations will normally subclass this structure 
to add additional private and implementation\-specific fields. 
The nRef field is used internally by the SQLite core and should not 
be altered by the virtual table implementation. The virtual table 
implementation may pass error message text to the core by putting 
an error message string in zErrMsg.
Space to hold this error message string must be obtained from an
SQLite memory allocation function such as [sqlite3\_mprintf()](c3ref/mprintf.html) or
[sqlite3\_malloc()](c3ref/free.html).
Prior to assigning a new value to zErrMsg, the virtual table 
implementation must free any preexisting content of zErrMsg using 
[sqlite3\_free()](c3ref/free.html). Failure to do this will result in a memory leak. 
The SQLite core will free and zero the content of zErrMsg when it 
delivers the error message text to the client application or when 
it destroys the virtual table. The virtual table implementation only 
needs to worry about freeing the zErrMsg content when it overwrites 
the content with a new, different error message.



The [sqlite3\_vtab\_cursor](c3ref/vtab_cursor.html) structure represents a pointer to a specific
row of a virtual table. This is what an sqlite3\_vtab\_cursor looks like:




```
struct sqlite3_vtab_cursor {
  sqlite3_vtab *pVtab;
};

```

Once again, practical implementations will likely subclass this 
structure to add additional private fields.



The [sqlite3\_index\_info](c3ref/index_info.html) structure is used to pass information into
and out of the xBestIndex method of the module that implements a 
virtual table.



Before a [CREATE VIRTUAL TABLE](lang_createvtab.html) statement can be run, the module 
specified in that statement must be registered with the database 
connection. This is accomplished using either of the [sqlite3\_create\_module()](c3ref/create_module.html)
or [sqlite3\_create\_module\_v2()](c3ref/create_module.html) interfaces:




```
int sqlite3_create_module(
  sqlite3 *db,               /* SQLite connection to register module with */
  const char *zName,         /* Name of the module */
  const sqlite3_module *,    /* Methods for the module */
  void *                     /* Client data for xCreate/xConnect */
);
int sqlite3_create_module_v2(
  sqlite3 *db,               /* SQLite connection to register module with */
  const char *zName,         /* Name of the module */
  const sqlite3_module *,    /* Methods for the module */
  void *,                    /* Client data for xCreate/xConnect */
  void(*xDestroy)(void*)     /* Client data destructor function */
);

```

The [sqlite3\_create\_module()](c3ref/create_module.html) and [sqlite3\_create\_module\_v2()](c3ref/create_module.html)
routines associates a module name with 
an [sqlite3\_module](c3ref/module.html) structure and a separate client data that is specific 
to each module. The only difference between the two create\_module methods
is that the \_v2 method includes an extra parameter that specifies a
destructor for client data pointer. The module structure is what defines
the behavior of a virtual table. The module structure looks like this:




```

struct sqlite3_module {
  int iVersion;
  int (*xCreate)(sqlite3*, void *pAux,
               int argc, char *const*argv,
               sqlite3_vtab **ppVTab,
               char **pzErr);
  int (*xConnect)(sqlite3*, void *pAux,
               int argc, char *const*argv,
               sqlite3_vtab **ppVTab,
               char **pzErr);
  int (*xBestIndex)(sqlite3_vtab *pVTab, sqlite3_index_info*);
  int (*xDisconnect)(sqlite3_vtab *pVTab);
  int (*xDestroy)(sqlite3_vtab *pVTab);
  int (*xOpen)(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor);
  int (*xClose)(sqlite3_vtab_cursor*);
  int (*xFilter)(sqlite3_vtab_cursor*, int idxNum, const char *idxStr,
                int argc, sqlite3_value **argv);
  int (*xNext)(sqlite3_vtab_cursor*);
  int (*xEof)(sqlite3_vtab_cursor*);
  int (*xColumn)(sqlite3_vtab_cursor*, sqlite3_context*, int);
  int (*xRowid)(sqlite3_vtab_cursor*, sqlite_int64 *pRowid);
  int (*xUpdate)(sqlite3_vtab *, int, sqlite3_value **, sqlite_int64 *);
  int (*xBegin)(sqlite3_vtab *pVTab);
  int (*xSync)(sqlite3_vtab *pVTab);
  int (*xCommit)(sqlite3_vtab *pVTab);
  int (*xRollback)(sqlite3_vtab *pVTab);
  int (*xFindFunction)(sqlite3_vtab *pVtab, int nArg, const char *zName,
                     void (**pxFunc)(sqlite3_context*,int,sqlite3_value**),
                     void **ppArg);
  int (*xRename)(sqlite3_vtab *pVtab, const char *zNew);
  /* The methods above are in version 1 of the sqlite_module object. Those 
  ** below are for version 2 and greater. */
  int (*xSavepoint)(sqlite3_vtab *pVTab, int);
  int (*xRelease)(sqlite3_vtab *pVTab, int);
  int (*xRollbackTo)(sqlite3_vtab *pVTab, int);
  /* The methods above are in versions 1 and 2 of the sqlite_module object.
  ** Those below are for version 3 and greater. */
  int (*xShadowName)(const char*);
  /* The methods above are in versions 1 through 3 of the sqlite_module object.
  ** Those below are for version 4 and greater. */
  int (*xIntegrity)(sqlite3_vtab *pVTab, const char *zSchema,
                    const char *zTabName, int mFlags, char **pzErr);
};

```

The module structure defines all of the methods for each virtual 
table object. The module structure also contains the iVersion field which
defines the particular edition of the module table structure. Currently, 
iVersion is always 4 or less, but in future releases of SQLite the module
structure definition might be extended with additional methods and in 
that case the maximum iVersion value will be increased.



The rest of the module structure consists of methods used to implement
various features of the virtual table. Details on what each of these 
methods do are provided in the sequel.



