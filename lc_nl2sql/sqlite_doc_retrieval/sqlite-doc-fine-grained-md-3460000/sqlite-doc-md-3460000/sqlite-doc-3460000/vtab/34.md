### 2\.3\.1\. Inputs


The main thing that the SQLite core is trying to communicate to 
the virtual table is the constraints that are available to limit 
the number of rows that need to be searched. The aConstraint\[] array 
contains one entry for each constraint. There will be exactly 
nConstraint entries in that array.



Each constraint will usually correspond to a term in the WHERE clause
or in a USING or ON clause that is of the form




> column OP EXPR


Where "column" is a column in the virtual table, OP is an operator 
like "\=" or "\<", and EXPR is an arbitrary expression. So, for example,
if the WHERE clause contained a term like this:




```
a = 5

```

Then one of the constraints would be on the "a" column with 
operator "\=" and an expression of "5". Constraints need not have a
literal representation of the WHERE clause. The query optimizer might
make transformations to the 
WHERE clause in order to extract as many constraints 
as it can. So, for example, if the WHERE clause contained something 
like this:




```
x BETWEEN 10 AND 100 AND 999>y

```

The query optimizer might translate this into three separate constraints:




```
x >= 10
x <= 100
y < 999

```

For each such constraint, the aConstraint\[].iColumn field indicates which 
column appears on the left\-hand side of the constraint.
The first column of the virtual table is column 0\. 
The rowid of the virtual table is column \-1\. 
The aConstraint\[].op field indicates which operator is used. 
The SQLITE\_INDEX\_CONSTRAINT\_\* constants map integer constants 
into operator values.
Columns occur in the order they were defined by the call to
[sqlite3\_declare\_vtab()](c3ref/declare_vtab.html) in the [xCreate](vtab.html#xcreate) or [xConnect](vtab.html#xconnect) method.
Hidden columns are counted when determining the column index.



If the [xFindFunction()](vtab.html#xfindfunction) method for the virtual table is defined, and 
if xFindFunction() sometimes returns [SQLITE\_INDEX\_CONSTRAINT\_FUNCTION](c3ref/c_index_constraint_eq.html) or
larger, then the constraints might also be of the form:




> FUNCTION( column, EXPR)


In this case the aConstraint\[].op value is the same as the value
returned by [xFindFunction()](vtab.html#xfindfunction) for FUNCTION.



The aConstraint\[] array contains information about all constraints 
that apply to the virtual table. But some of the constraints might
not be usable because of the way tables are ordered in a join. 
The xBestIndex method must therefore only consider constraints 
that have an aConstraint\[].usable flag which is true.



In addition to WHERE clause constraints, the SQLite core also 
tells the xBestIndex method about the ORDER BY clause. 
(In an aggregate query, the SQLite core might put in GROUP BY clause 
information in place of the ORDER BY clause information, but this fact
should not make any difference to the xBestIndex method.) 
If all terms of the ORDER BY clause are columns in the virtual table, 
then nOrderBy will be the number of terms in the ORDER BY clause 
and the aOrderBy\[] array will identify the column for each term 
in the order by clause and whether or not that column is ASC or DESC.




In SQLite [version 3\.10\.0](releaselog/3_10_0.html) (2016\-01\-06\) and later, 
the colUsed field is available
to indicate which fields of the virtual table are actually used by the
statement being prepared. If the lowest bit of colUsed is set, that
means that the first column is used. The second lowest bit corresponds
to the second column. And so forth. If the most significant bit of
colUsed is set, that means that one or more columns other than the 
first 63 columns are used. If column usage information is needed by the
[xFilter](vtab.html#xfilter) method, then the required bits must be encoded into either
the output idxNum field or idxStr content.



