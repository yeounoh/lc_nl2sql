### Support for UTF\-8 and UTF\-16



The new API for SQLite 3\.0 contains routines that accept text as
both UTF\-8 and UTF\-16 in the native byte order of the host machine.
Each database file manages text as either UTF\-8, UTF\-16BE (big\-endian),
or UTF\-16LE (little\-endian). Internally and in the disk file, the
same text representation is used everywhere. If the text representation
specified by the database file (in the file header) does not match
the text representation required by the interface routines, then text
is converted on\-the\-fly.
Constantly converting text from one representation to another can be
computationally expensive, so it is suggested that programmers choose a
single representation and stick with it throughout their application.




In the current implementation of SQLite, the SQL parser only works
with UTF\-8 text. So if you supply UTF\-16 text it will be converted.
This is just an implementation issue and there is nothing to prevent
future versions of SQLite from parsing UTF\-16 encoded SQL natively.




When creating new user\-defined SQL functions and collating sequences,
each function or collating sequence can specify if it works with
UTF\-8, UTF\-16be, or UTF\-16le. Separate implementations can be registered
for each encoding. If an SQL function or collating sequence is required
but a version for the current text encoding is not available, then 
the text is automatically converted. As before, this conversion takes
computation time, so programmers are advised to pick a single
encoding and stick with it in order to minimize the amount of unnecessary
format juggling.




SQLite is not particular about the text it receives and is more than
happy to process text strings that are not normalized or even
well\-formed UTF\-8 or UTF\-16\. Thus, programmers who want to store
ISO8859 data can do so using the UTF\-8 interfaces. As long as no
attempts are made to use a UTF\-16 collating sequence or SQL function,
the byte sequence of the text will not be modified in any way.



