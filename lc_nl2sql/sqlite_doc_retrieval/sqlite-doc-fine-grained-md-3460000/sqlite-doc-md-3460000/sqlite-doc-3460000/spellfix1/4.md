# 4\. Algorithm


The spellfix1 virtual table creates a single
shadow table named "%\_vocab" (where the % is replaced by the name of
the virtual table; Ex: "demo\_vocab" for the "demo" virtual table). 
the shadow table contains the following columns:




**id**


The unique id (INTEGER PRIMARY KEY)

**rank**


The rank of word.

**langid**


The language id for this entry.

**word**


The original UTF8 text of the vocabulary word

**k1**


The word transliterated into lower\-case ASCII. 
There is a standard table of mappings from non\-ASCII
characters into ASCII. Examples: "æ" \-\> "ae",
"þ" \-\> "th", "ß" \-\> "ss", "á" \-\> "a", ... The
accessory function spellfix1\_translit(X) will do
the non\-ASCII to ASCII mapping. The built\-in lower(X)
function will convert to lower\-case. Thus:
k1 \= lower(spellfix1\_translit(word)).

If the word is already all lower\-case ASCII, then the k1 column
will contain a NULL. This reduces the storage requirements for
the %\_vocab table and helps spellfix to run a little faster.
Therefore, it is advantageous to populate as much of the spellfix
table as possible using lower\-case ASCII vocabulary.

**k2**


This field holds a phonetic code derived from coalesce(k1,word).
Letters that have similar sounds are mapped into the same symbol.
For example, all vowels and vowel clusters become the
single symbol "A". And the letters "p", "b", "f", and
"v" all become "B". All nasal sounds are represented
as "N". And so forth. The mapping is based on
ideas found in Soundex, Metaphone, and other
long\-standing phonetic matching systems. This key can
be generated by the function spellfix1\_phonehash(X). 
Hence: k2 \= spellfix1\_phonehash(coalesce(k1,word))

There is also a function for computing the Wagner edit distance or the
Levenshtein distance between a pattern and a word. This function
is exposed as spellfix1\_editdist(X,Y). The edit distance function
returns the "cost" of converting X into Y. Some transformations
cost more than others. Changing one vowel into a different vowel,
for example is relatively cheap, as is doubling a constant, or
omitting the second character of a double\-constant. Other transformations
or more expensive. The idea is that the edit distance function returns
a low cost for words that are similar and a higher cost for words
that are further apart. In this implementation, the maximum cost
of any single\-character edit (delete, insert, or substitute) is 100,
with lower costs for some edits (such as transforming vowels).



The "score" for a comparison is the edit distance between the pattern
and the word, adjusted down by the base\-2 logarithm of the word rank.
For example, a match with distance 100 but rank 1000 would have a
score of 122 (\= 100 \- log2(1000\) \+ 32\) whereas a match with distance
100 with a rank of 1 would have a score of 131 (100 \- log2(1\) \+ 32\).
(NB: The constant 32 is added to each score to keep it from going
negative in case the edit distance is zero.) In this way, frequently
used words get a slightly lower cost which tends to move them toward
the top of the list of alternative spellings.



A straightforward implementation of a spelling corrector would be
to compare the search term against every word in the vocabulary
and select the 20 with the lowest scores. However, there will 
typically be hundreds of thousands or millions of words in the
vocabulary, and so this approach is not fast enough.



Suppose the term that is being spell\-corrected is X. To limit
the search space, X is converted to a k2\-like key using the
equivalent of:




> ```
> 
>    key = spellfix1_phonehash(lower(spellfix1_translit(X)))
> 
> ```


This key is then limited to "scope" characters. The default scope
value is 4, but an alternative scope can be specified using the
"scope\=N" term in the WHERE clause. After the key has been truncated,
the edit distance is run against every term in the vocabulary that
has a k2 value that begins with the abbreviated key.



For example, suppose the input word is "Paskagula". The phonetic 
key is "BACACALA" which is then truncated to 4 characters "BACA".
The edit distance is then run on the 4980 entries (out of
272,597 entries total) of the vocabulary whose k2 values begin with
BACA, yielding "Pascagoula" as the best match.



Only terms of the vocabulary with a matching langid are searched.
Hence, the same table can contain entries from multiple languages
and only the requested language will be used. The default langid
is 0\.




