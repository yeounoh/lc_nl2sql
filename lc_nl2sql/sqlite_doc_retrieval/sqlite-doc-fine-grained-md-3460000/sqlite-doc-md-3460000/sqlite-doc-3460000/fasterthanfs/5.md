## 2\.1\. Read Performance Measurements


The chart below shows data collected using 
[kvtest.c](https://www.sqlite.org/src/file/test/kvtest.c) on five different
systems:



* **Win7**: A circa\-2009 Dell Inspiron laptop, Pentium dual\-core
 at 2\.30GHz, 4GiB RAM, Windows7\.
* **Win10**: A 2016 Lenovo YOGA 910, Intel i7\-7500 at 2\.70GHz,
 16GiB RAM, Windows10\.
* **Mac**: A 2015 MacBook Pro, 3\.1GHz intel Core i7, 16GiB RAM,
 MacOS 10\.12\.5
* **Ubuntu**: Desktop built from Intel i7\-4770K at 3\.50GHz, 32GiB RAM,
 Ubuntu 16\.04\.2 LTS
* **Android**: Galaxy S3, ARMv7, 2GiB RAM


All machines use SSD except Win7 which has a
hard\-drive. The test database is 100K blobs with sizes uniformly
distributed between 8K and 12K, for a total of about 1 gigabyte
of content. The database page size
is 4KiB. The \-DSQLITE\_DIRECT\_OVERFLOW\_READ compile\-time option was
used for all of these tests.
Tests were run multiple times.
The first run was used to warm up the cache and its timings were discarded.




The chart below shows average time to read a blob directly from the
filesystem versus the time needed to read the same blob from the SQLite 
database.
The actual timings vary considerably from one system to another 
(the Ubuntu desktop is much
faster than the Galaxy S3 phone, for example). 
This chart shows the ratio of the
times needed to read blobs from a file divided by the time needed to
from the database. The left\-most column in the chart is the normalized
time to read from the database, for reference.




In this chart, an SQL statement ("SELECT v FROM kv WHERE k\=?1") 
is prepared once. Then for each blob, the blob key value is bound 
to the ?1 parameter and the statement is evaluated to extract the
blob content.




The chart shows that on Windows10, content can be read from the SQLite
database about 5 times faster than it can be read directly from disk.
On Android, SQLite is only about 35% faster than reading from disk.





![](images/faster-read-sql.jpg)

  

Chart 1: SQLite read latency relative to direct filesystem reads.  

100K blobs, avg 10KB each, random order using SQL


The performance can be improved slightly by bypassing the SQL layer
and reading the blob content directly using the
[sqlite3\_blob\_read()](c3ref/blob_read.html) interface, as shown in the next chart:





![](images/faster-read-blobapi.jpg)

  

Chart 2: SQLite read latency relative to direct filesystem reads.  

100K blobs, avg size 10KB, random order  

using sqlite3\_blob\_read().


Further performance improves can be made by using the
[memory\-mapped I/O](mmap.html) feature of SQLite. In the next chart, the
entire 1GB database file is memory mapped and blobs are read
(in random order) using the [sqlite3\_blob\_read()](c3ref/blob_read.html) interface.
With these optimizations, SQLite is twice as fast as Android
or MacOS\-X and over 10 times faster than Windows.





![](images/faster-read-mmap.jpg)

  

Chart 3: SQLite read latency relative to direct filesystem reads.  

100K blobs, avg size 10KB, random order  

using sqlite3\_blob\_read() from a memory\-mapped database.


The third chart shows that reading blob content out of SQLite can be
twice as fast as reading from individual files on disk for Mac and
Android, and an amazing ten times faster for Windows.



