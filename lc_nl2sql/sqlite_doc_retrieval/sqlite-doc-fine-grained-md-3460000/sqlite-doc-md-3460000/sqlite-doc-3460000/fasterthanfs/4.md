# 2\. How These Measurements Are Made


I/O performance is measured using the
[kvtest.c](https://www.sqlite.org/src/file/test/kvtest.c) program
from the SQLite source tree.
To compile this test program, first gather the kvtest.c source file
into a directory with the [SQLite amalgamation](amalgamation.html) source
files "sqlite3\.c" and "sqlite3\.h". Then on unix, run a command like
the following:




```
gcc -Os -I. -DSQLITE_DIRECT_OVERFLOW_READ \
  kvtest.c sqlite3.c -o kvtest -ldl -lpthread

```

Or on Windows with MSVC:




```
cl -I. -DSQLITE_DIRECT_OVERFLOW_READ kvtest.c sqlite3.c

```

Instructions for compiling for Android
are [shown below](#compile-android).




Use the resulting "kvtest" program to
generate a test database with 100,000 random uncompressible
blobs, each with a random
size between 8,000 and 12,000 bytes
using a command like this:




```
./kvtest init test1.db --count 100k --size 10k --variance 2k

```


If desired, you can verify the new database by running this command:




```
./kvtest stat test1.db

```


Next, make copies of all the blobs into individual files in a directory
using a command like this:




```
./kvtest export test1.db test1.dir

```


At this point, you can measure the amount of disk space used by
the test1\.db database and the space used by the test1\.dir directory
and all of its content. On a standard Ubuntu Linux desktop, the
database file will be 1,024,512,000 bytes in size and the test1\.dir
directory will use 1,228,800,000 bytes of space (according to "du \-k"),
about 20% more than the database.




The "test1\.dir" directory created above puts all the blobs into a single
folder. It was conjectured that some operating systems would perform 
poorly when a single directory contains 100,000 objects. To test this,
the kvtest program can also store the blobs in a hierarchy of folders with no
more than 100 files and/or subdirectories per folder. The alternative
on\-disk representation of the blobs can be created using the \-\-tree
command\-line option to the "export" command, like this:




```
./kvtest export test1.db test1.tree --tree

```


The test1\.dir directory will contain 100,000 files
with names like "000000", "000001", "000002" and so forth but the
test1\.tree directory will contain the same files in subdirectories like
"00/00/00", "00/00/01", and so on. The test1\.dir and test1\.test
directories take up approximately the same amount of space, though
test1\.test is very slightly larger due to the extra directory entries.




All of the experiments that follow operate the same with either 
"test1\.dir" or "test1\.tree". Very little performance difference is
measured in either case, regardless of operating system.




Measure the performance for reading blobs from the database and from
individual files using these commands:




```
./kvtest run test1.db --count 100k --blob-api
./kvtest run test1.dir --count 100k --blob-api
./kvtest run test1.tree --count 100k --blob-api

```


Depending on your hardware and operating system, you should see that reads 
from the test1\.db database file are about 35% faster than reads from 
individual files in the test1\.dir or test1\.tree folders. Results can vary
significantly from one run to the next due to caching, so it is advisable
to run tests multiple times and take an average or a worst case or a best
case, depending on your requirements.



The \-\-blob\-api option on the database read test causes kvtest to use
the [sqlite3\_blob\_read()](c3ref/blob_read.html) feature of SQLite to load the content of the
blobs, rather than running pure SQL statements. This helps SQLite to run
a little faster on read tests. You can omit that option to compare the
performance of SQLite running SQL statements.
In that case, the SQLite still out\-performs direct reads, though
by not as much as when using [sqlite3\_blob\_read()](c3ref/blob_read.html).
The \-\-blob\-api option is ignored for tests that read from individual disk
files.




Measure write performance by adding the \-\-update option. This causes
the blobs are overwritten in place with another random blob of
exactly the same size.




```
./kvtest run test1.db --count 100k --update
./kvtest run test1.dir --count 100k --update
./kvtest run test1.tree --count 100k --update

```


The writing test above is not completely fair, since SQLite is doing
[power\-safe transactions](transactional.html) whereas the direct\-to\-disk writing is not.
To put the tests on a more equal footing, add either the \-\-nosync
option to the SQLite writes to disable calling fsync() or
FlushFileBuffers() to force content to disk, or using the \-\-fsync option
for the direct\-to\-disk tests to force them to invoke fsync() or
FlushFileBuffers() when updating disk files.




By default, kvtest runs the database I/O measurements all within
a single transaction. Use the \-\-multitrans option to run each blob
read or write in a separate transaction. The \-\-multitrans option makes
SQLite much slower, and uncompetitive with direct disk I/O. This
option proves, yet again, that to get the most performance out of
SQLite, you should group as much database interaction as possible within
a single transaction.




There are many other testing options, which can be seen by running
the command:




```
./kvtest help

```

