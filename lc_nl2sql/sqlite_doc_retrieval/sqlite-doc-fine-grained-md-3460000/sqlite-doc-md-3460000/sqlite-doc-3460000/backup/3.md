## Example 2: Online Backup of a Running Database



```

/*
** Perform an online backup of database pDb to the database file named
** by zFilename. This function copies 5 database pages from pDb to
** zFilename, then unlocks pDb and sleeps for 250 ms, then repeats the
** process until the entire database is backed up.
** 
** The third argument passed to this function must be a pointer to a progress
** function. After each set of 5 pages is backed up, the progress function
** is invoked with two integer parameters: the number of pages left to
** copy, and the total number of pages in the source file. This information
** may be used, for example, to update a GUI progress bar.
**
** While this function is running, another thread may use the database pDb, or
** another process may access the underlying database file via a separate 
** connection.
**
** If the backup process is successfully completed, SQLITE_OK is returned.
** Otherwise, if an error occurs, an SQLite error code is returned.
*/
int backupDb(
  [sqlite3](c3ref/sqlite3.html) *pDb,               /* Database to back up */
  const char *zFilename,      /* Name of file to back up to */
  void(*xProgress)(int, int)  /* Progress function to invoke */     
){
  int rc;                     /* Function return code */
  [sqlite3](c3ref/sqlite3.html) *pFile;             /* Database connection opened on zFilename */
  [sqlite3_backup](c3ref/backup.html) *pBackup;    /* Backup handle used to copy data */

  /* Open the database file identified by zFilename. */
  rc = [sqlite3_open](c3ref/open.html)(zFilename, &pFile);
  if( rc==SQLITE_OK ){

    /* Open the [sqlite3_backup](c3ref/backup.html) object used to accomplish the transfer */
    pBackup = [sqlite3_backup_init](c3ref/backup_finish.html#sqlite3backupinit)(pFile, "main", pDb, "main");
    if( pBackup ){

      /* Each iteration of this loop copies 5 database pages from database
      ** pDb to the backup database. If the return value of backup_step()
      ** indicates that there are still further pages to copy, sleep for
      ** 250 ms before repeating. */
      do {
        rc = [sqlite3_backup_step](c3ref/backup_finish.html#sqlite3backupstep)(pBackup, 5);
        xProgress(
            [sqlite3_backup_remaining](c3ref/backup_finish.html#sqlite3backupremaining)(pBackup),
            [sqlite3_backup_pagecount](c3ref/backup_finish.html#sqlite3backuppagecount)(pBackup)
        );
        if( rc==SQLITE_OK || rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){
          [sqlite3_sleep](c3ref/sleep.html)(250);
        }
      } while( rc==SQLITE_OK || rc==SQLITE_BUSY || rc==SQLITE_LOCKED );

      /* Release resources allocated by backup_init(). */
      (void)[sqlite3_backup_finish](c3ref/backup_finish.html#sqlite3backupfinish)(pBackup);
    }
    rc = [sqlite3_errcode](c3ref/errcode.html)(pFile);
  }
  
  /* Close the database connection opened on database file zFilename
  ** and return the result of this function. */
  (void)[sqlite3_close](c3ref/close.html)(pFile);
  return rc;
}

```


 The function presented in the previous example copies the entire source
 database in one call to [sqlite3\_backup\_step()](c3ref/backup_finish.html#sqlite3backupstep). This requires holding a 
 read\-lock on the source database file for the duration of the operation,
 preventing any other database user from writing to the database. It also
 holds the mutex associated with database pInMemory throughout the copy,
 preventing any other thread from using it. The C function in this section,
 designed to be called by a background thread or process for creating a 
 backup of an online database, avoids these problems using the following 
 approach:

 1. Function [sqlite3\_backup\_init()](c3ref/backup_finish.html#sqlite3backupinit) is called to create an [sqlite3\_backup](c3ref/backup.html)
 object to copy data from database pDb to the backup database file 
 identified by zFilename.
 - Function [sqlite3\_backup\_step()](c3ref/backup_finish.html#sqlite3backupstep) is called with a parameter of 5 to
 copy 5 pages of database pDb to the backup database (file zFilename).
 - If there are still more pages to copy from database pDb, then the
 function sleeps for 250 milliseconds (using the [sqlite3\_sleep()](c3ref/sleep.html)
 utility) and then returns to step 2\.
 - Function [sqlite3\_backup\_finish()](c3ref/backup_finish.html#sqlite3backupfinish) is called to clean up resources
 allocated by [sqlite3\_backup\_init()](c3ref/backup_finish.html#sqlite3backupinit).


**File and Database Connection Locking**

 During the 250 ms sleep in step 3 above, no read\-lock is held on the database
 file and the mutex associated with pDb is not held. This allows other threads
 to use [database connection](c3ref/sqlite3.html) pDb and other connections to write to the
 underlying database file. 


 If another thread or process writes to the source database while this 
 function is sleeping, then SQLite detects this and usually restarts the 
 backup process when sqlite3\_backup\_step() is next called. There is one 
 exception to this rule: If the source database is not an in\-memory database,
 and the write is performed from within the same process as the backup
 operation and uses the same database handle (pDb), then the destination
 database (the one opened using connection pFile) is automatically updated
 along with the source. The backup process may then be continued after the 
 sqlite3\_sleep() call returns as if nothing had happened. 


 Whether or not the backup process is restarted as a result of writes to
 the source database mid\-backup, the user can be sure that when the backup
 operation is completed the backup database contains a consistent and 
 up\-to\-date snapshot of the original. However:

 * Writes to an in\-memory source database, or writes to a file\-based 
 source database by an external process or thread using a 
 database connection other than pDb are significantly more expensive 
 than writes made to a file\-based source database using pDb (as the
 entire backup operation must be restarted in the former two cases).

 * If the backup process is restarted frequently enough it may never
 run to completion and the backupDb() function may never return.


**backup\_remaining() and backup\_pagecount()**

 The backupDb() function uses the sqlite3\_backup\_remaining() and
 sqlite3\_backup\_pagecount() functions to report its progress via the
 user\-supplied xProgress() callback. Function sqlite3\_backup\_remaining()
 returns the number of pages left to copy and sqlite3\_backup\_pagecount()
 returns the total number of pages in the source database (in this case 
 the database opened by pDb). So the percentage completion of the process
 may be calculated as:


 Completion \= 100% \* (pagecount() \- remaining()) / pagecount()


 The sqlite3\_backup\_remaining() and sqlite3\_backup\_pagecount() APIs report
 values stored by the previous call to sqlite3\_backup\_step(), they do not
 actually inspect the source database file. This means that if the source
 database is written to by another thread or process after the call to
 sqlite3\_backup\_step() returns but before the values returned by
 sqlite3\_backup\_remaining() and sqlite3\_backup\_pagecount() are used, the 
 values may be technically incorrect. This is not usually a problem.



*This page last modified on [2022\-04\-18 02:55:50](https://sqlite.org/docsrc/honeypot) UTC* 
















































