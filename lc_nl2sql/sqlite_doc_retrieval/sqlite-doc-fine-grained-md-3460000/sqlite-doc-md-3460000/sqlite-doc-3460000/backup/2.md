## Example 1: Loading and Saving In\-Memory Databases



```

/*
** This function is used to load the contents of a database file on disk 
** into the "main" database of open database connection pInMemory, or
** to save the current contents of the database opened by pInMemory into
** a database file on disk. pInMemory is probably an in-memory database, 
** but this function will also work fine if it is not.
**
** Parameter zFilename points to a nul-terminated string containing the
** name of the database file on disk to load from or save to. If parameter
** isSave is non-zero, then the contents of the file zFilename are 
** overwritten with the contents of the database opened by pInMemory. If
** parameter isSave is zero, then the contents of the database opened by
** pInMemory are replaced by data loaded from the file zFilename.
**
** If the operation is successful, SQLITE_OK is returned. Otherwise, if
** an error occurs, an SQLite error code is returned.
*/
int loadOrSaveDb([sqlite3](c3ref/sqlite3.html) *pInMemory, const char *zFilename, int isSave){
  int rc;                   /* Function return code */
  [sqlite3](c3ref/sqlite3.html) *pFile;           /* Database connection opened on zFilename */
  [sqlite3_backup](c3ref/backup.html) *pBackup;  /* Backup object used to copy data */
  [sqlite3](c3ref/sqlite3.html) *pTo;             /* Database to copy to (pFile or pInMemory) */
  [sqlite3](c3ref/sqlite3.html) *pFrom;           /* Database to copy from (pFile or pInMemory) */

  /* Open the database file identified by zFilename. Exit early if this fails
  ** for any reason. */
  rc = [sqlite3_open](c3ref/open.html)(zFilename, &pFile);
  if( rc==SQLITE_OK ){

    /* If this is a 'load' operation (isSave==0), then data is copied
    ** from the database file just opened to database pInMemory. 
    ** Otherwise, if this is a 'save' operation (isSave==1), then data
    ** is copied from pInMemory to pFile.  Set the variables pFrom and
    ** pTo accordingly. */
    pFrom = (isSave ? pInMemory : pFile);
    pTo   = (isSave ? pFile     : pInMemory);

    /* Set up the backup procedure to copy from the "main" database of 
    ** connection pFile to the main database of connection pInMemory.
    ** If something goes wrong, pBackup will be set to NULL and an error
    ** code and message left in connection pTo.
    **
    ** If the backup object is successfully created, call backup_step()
    ** to copy data from pFile to pInMemory. Then call backup_finish()
    ** to release resources associated with the pBackup object.  If an
    ** error occurred, then an error code and message will be left in
    ** connection pTo. If no error occurred, then the error code belonging
    ** to pTo is set to SQLITE_OK.
    */
    pBackup = [sqlite3_backup_init](c3ref/backup_finish.html#sqlite3backupinit)(pTo, "main", pFrom, "main");
    if( pBackup ){
      (void)[sqlite3_backup_step](c3ref/backup_finish.html#sqlite3backupstep)(pBackup, -1);
      (void)[sqlite3_backup_finish](c3ref/backup_finish.html#sqlite3backupfinish)(pBackup);
    }
    rc = [sqlite3_errcode](c3ref/errcode.html)(pTo);
  }

  /* Close the database connection opened on database file zFilename
  ** and return the result of this function. */
  (void)[sqlite3_close](c3ref/close.html)(pFile);
  return rc;
}

```


 The C function to the right demonstrates one of the simplest,
 and most common, uses of the backup API: loading and saving the contents
 of an in\-memory database to a file on disk. The backup API is used as
 follows in this example:

 1. Function [sqlite3\_backup\_init()](c3ref/backup_finish.html#sqlite3backupinit) is called to create an [sqlite3\_backup](c3ref/backup.html)
 object to copy data between the two databases (either from a file and
 into the in\-memory database, or vice\-versa).
 - Function [sqlite3\_backup\_step()](c3ref/backup_finish.html#sqlite3backupstep) is called with a parameter of 
 \-1 to copy the entire source database to the destination.
 - Function [sqlite3\_backup\_finish()](c3ref/backup_finish.html#sqlite3backupfinish) is called to clean up resources
 allocated by [sqlite3\_backup\_init()](c3ref/backup_finish.html#sqlite3backupinit).


**Error handling**

 If an error occurs in any of the three main backup API routines
 then the [error code](rescode.html) and [message](c3ref/errcode.html) are attached to
 the destination [database connection](c3ref/sqlite3.html).
 Additionally, if
 [sqlite3\_backup\_step()](c3ref/backup_finish.html#sqlite3backupstep) encounters an error, then the [error code](rescode.html) is returned
 by both the [sqlite3\_backup\_step()](c3ref/backup_finish.html#sqlite3backupstep) call itself, and by the subsequent call
 to [sqlite3\_backup\_finish()](c3ref/backup_finish.html#sqlite3backupfinish). So a call to [sqlite3\_backup\_finish()](c3ref/backup_finish.html#sqlite3backupfinish)
 does not overwrite an [error code](rescode.html) stored in the destination
 [database connection](c3ref/sqlite3.html) by [sqlite3\_backup\_step()](c3ref/backup_finish.html#sqlite3backupstep). This feature
 is used in the example code to reduce amount of error handling required.
 The return values of the [sqlite3\_backup\_step()](c3ref/backup_finish.html#sqlite3backupstep) and [sqlite3\_backup\_finish()](c3ref/backup_finish.html#sqlite3backupfinish)
 calls are ignored and the error code indicating the success or failure of
 the copy operation collected from the destination [database connection](c3ref/sqlite3.html)
 afterward.

**Possible Enhancements**

 The implementation of this function could be enhanced in at least two ways:

 1. Failing to obtain the lock on database file zFilename (an [SQLITE\_BUSY](rescode.html#busy)
 error) could be handled, and
 - Cases where the page\-sizes of database pInMemory and zFilename are
 different could be handled better.



 Since database zFilename is a file on disk, then it may be accessed 
 externally by another process. This means that when the call to
 sqlite3\_backup\_step() attempts to read from or write data to it, it may
 fail to obtain the required file lock. If this happens, this implementation
 will fail, returning SQLITE\_BUSY immediately. The solution would be to
 register a busy\-handler callback or 
 timeout with [database connection](c3ref/sqlite3.html) pFile 
 using [sqlite3\_busy\_handler()](c3ref/busy_handler.html) or [sqlite3\_busy\_timeout()](c3ref/busy_timeout.html)
 as soon as it is opened. If it fails to obtain a required lock immediately,
 [sqlite3\_backup\_step()](c3ref/backup_finish.html#sqlite3backupstep) uses any registered busy\-handler callback or timeout
 in the same way as [sqlite3\_step()](c3ref/step.html) or [sqlite3\_exec()](c3ref/exec.html) does.


 Usually, it does not matter if the page\-sizes of the source database and the
 destination database are different before the contents of the destination
 are overwritten. The page\-size of the destination database is simply changed
 as part of the backup operation. The exception is if the destination database
 happens to be an in\-memory database. In this case, if the page sizes
 are not the same at the start of the backup operation, then the operation
 fails with an SQLITE\_READONLY error. Unfortunately, this could occur when
 loading a database image from a file into an in\-memory database using
 function loadOrSaveDb().


 However, if in\-memory database pInMemory has just been opened (and is 
 therefore completely empty) before being passed to function loadOrSaveDb(), 
 then it is still possible to change its page size using an SQLite "PRAGMA
 page\_size" command. Function loadOrSaveDb() could detect this case, and
 attempt to set the page\-size of the in\-memory database to the page\-size
 of database zFilename before invoking the online backup API functions.
 
