# 3\. Queries Using Partial Indexes


Let X be the expression in the WHERE clause of a partial
index, and let W be the WHERE clause of a query that uses the
table that is indexed. Then, the query is permitted to use 
the partial index if W⇒X, where the ⇒ operator
(usually pronounced "implies") is the logic operator 
equivalent to "X or not W".
Hence, determining whether or not a partial index
is usable in a particular query reduces to proving a theorem in
first\-order logic.


SQLite does not have a sophisticated theorem
prover with which to determine W⇒X. Instead, SQLite uses 
two simple rules to find the common cases where W⇒X is true, and
it assumes all the other cases are false. The rules used by SQLite
are these:



1. If W is AND\-connected terms and X is
OR\-connected terms and if any term of W
appears as a term of X, then the partial index is usable.


For example, let the index be



```
CREATE INDEX ex1 ON tab1(a,b) WHERE a=5 OR b=6;

```

And let the query be:



```
SELECT * FROM tab1 WHERE b=6 AND a=7; -- uses partial index

```

Then the index is usable by the query because the "b\=6" term appears
in both the index definition and in the query. Remember: terms in the
index should be OR\-connected and terms in the query should be AND\-connected.


The terms in W and X must match exactly. SQLite does not
do algebra to try to get them to look the same.
The term "b\=6" does not match "b\=3\+3" or "b\-6\=0" or "b BETWEEN 6 AND 6".
"b\=6" will match to "6\=b" as long as "b\=6" is on the index and "6\=b" is
in the query. If a term of the form "6\=b" appears in the index, it will
never match anything.
2. If a term in X is of the form "z IS NOT NULL" and if a term in
 W is a comparison operator on "z" other than "IS", then those
 terms match.


Example: Let the index be



```
CREATE INDEX ex2 ON tab2(b,c) WHERE c IS NOT NULL;

```

Then any query that uses operators \=, \<, \>, \<\=, \>\=, \<\>,
IN, LIKE, or GLOB on column "c" 
would be usable with the partial index because those
comparison operators are only true if "c" is not NULL. So the following
query could use the partial index:



```
SELECT * FROM tab2 WHERE b=456 AND c<>0;  -- uses partial index

```

But the next query can not use the partial index:



```
SELECT * FROM tab2 WHERE b=456;  -- cannot use partial index

```

The latter query can not use the partial index because there might be
rows in the table with b\=456 and where c is NULL. But those rows would
not be in the partial index.


These two rules describe how the query planner for SQLite works as of
this writing (2013\-08\-01\). And the rules above will always be honored.
However, future versions of SQLite might incorporate a better theorem prover
that can find other cases where W⇒X is true and thus may
find more instances where partial indexes are useful.


