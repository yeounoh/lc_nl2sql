## 1\.1\. Untrusted SQL Inputs



Applications that accept untrusted SQL inputs should take the following
precautions:



1. Set the [SQLITE\_DBCONFIG\_DEFENSIVE](c3ref/c_dbconfig_defensive.html#sqlitedbconfigdefensive) flag.
This prevents ordinary SQL statements from deliberately corrupting the 
database file. SQLite should be proof against attacks that involve both
malicious SQL inputs and a maliciously corrupted database file at the
same time. Nevertheless, denying a script\-only attacker access to 
corrupt database inputs provides an extra layer of defense.
2. Reduce the [limits](limits.html) that SQLite imposes on inputs. This can help prevent
denial of service attacks and other kinds of mischief that can occur
as a result of unusually large inputs. You can do this either at compile\-time
using \-DSQLITE\_MAX\_... options, or at run\-time using the
[sqlite3\_limit()](c3ref/limit.html) interface. Most applications can reduce limits
dramatically without impacting functionality. The table below
provides some suggestions, though exact values will vary depending
on the application:





| Limit Setting | Default Value | High\-security Value |
| --- | --- | --- |
| LIMIT\_LENGTH | 1,000,000,000 | 1,000,000 |
| LIMIT\_SQL\_LENGTH | 1,000,000,000 | 100,000 |
| LIMIT\_COLUMN | 2,000 | 100 |
| LIMIT\_EXPR\_DEPTH | 1,000 | 10 |
| LIMIT\_COMPOUND\_SELECT | 500 | 3 |
| LIMIT\_VDBE\_OP | 250,000,000 | 25,000 |
| LIMIT\_FUNCTION\_ARG | 127 | 8 |
| LIMIT\_ATTACH | 10 | 0 |
| LIMIT\_LIKE\_PATTERN\_LENGTH | 50,000 | 50 |
| LIMIT\_VARIABLE\_NUMBER | 999 | 10 |
| LIMIT\_TRIGGER\_DEPTH | 1,000 | 10 |
3. Consider using the [sqlite3\_set\_authorizer()](c3ref/set_authorizer.html) interface to limit
the scope of SQL that will be processed. For example, an application
that does not need to change the database schema might add an
sqlite3\_set\_authorizer() callback that causes any CREATE or DROP
statement to fail.
4. The SQL language is very powerful, and so it is always possible for
malicious SQL inputs (or erroneous SQL inputs caused by an application
bug) to submit SQL that runs for a very long time. To prevent this
from becoming a denial\-of\-service attack, consider using the
[sqlite3\_progress\_handler()](c3ref/progress_handler.html) interface to invoke a callback periodically
as each SQL statement runs, and have that callback return non\-zero to
abort the statement if the statement runs for too long. Alternatively,
set a timer in a separate thread and invoke [sqlite3\_interrupt()](c3ref/interrupt.html) when
the timer goes off to prevent the SQL statement from running forever.
5. Limit the maximum amount of memory that SQLite will allocate using
the [sqlite3\_hard\_heap\_limit64()](c3ref/hard_heap_limit64.html) interface. This helps prevent
denial\-of\-service attacks. To find out how much heap space an
application actually needs, run the it against typical inputs and
then measure the maximum instantaneous memory usage with the 
[sqlite3\_memory\_highwater()](c3ref/memory_highwater.html) interface. Set the hard heap limit
to the maximum observed instantaneous memory usage plus some margin.
6. Consider setting the [SQLITE\_MAX\_ALLOCATION\_SIZE](compile.html#max_allocation_size) compile\-time option
to something smaller than its default value of 2147483391 (0x7ffffeff).
A value of 100000000 (100 million) or even smaller would not be unreasonable,
depending on the application.
7. For embedded systems, consider compiling SQLite with the
[\-DSQLITE\_ENABLE\_MEMSYS5](compile.html#enable_memsys5) option and then providing SQLite with
a fixed chunk of memory to use as its heap via the
[sqlite3\_config](c3ref/config.html)([SQLITE\_CONFIG\_HEAP](c3ref/c_config_covering_index_scan.html#sqliteconfigheap)) interface. This will
prevent malicious SQL from executing a denial\-of\-service attack
by using an excessive amount of memory. If (say) 5 MB of memory
is provided for SQLite to use, once that much has been consumed,
SQLite will start returning SQLITE\_NOMEM errors rather than
soaking up memory needed by other parts of the application.
This also sandboxes SQLite's memory so that a write\-after\-free
error in some other part of the application will not cause
problems for SQLite, or vice versa.
8. To control memory usage in the [printf() SQL function](lang_corefunc.html#printf), compile
with "[\-DSQLITE\_PRINTF\_PRECISION\_LIMIT\=100000](compile.html#printf_precision_limit)" or some similarly
reasonable value.
This \#define limits the width and precision for %\-substitutions in the
printf() function, and thus prevents a hostile SQL statement from
consuming large amounts of RAM via constructs such as
"printf('%1000000000s','hi')".



Note that SQLite uses its built\-in printf() internally to help it
format the sql column in the [sqlite\_schema table](schematab.html). For that reason,
no table, index, view, or trigger definition can be much larger than the
precision limit. You can set a precision limit of less than 100000,
but be careful that whatever precision limit you use is at least as
long as the longest CREATE statement in your schema.



