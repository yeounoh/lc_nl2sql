# 1\.  Features


The SQLite core and its memory allocation subsystem provides the 
following capabilities:


* **Robust against allocation failures.**
If a memory allocation ever fails (that is to say, 
if malloc() or realloc() ever return NULL)
then SQLite will recover gracefully. SQLite will first attempt
to free memory from unpinned cache pages then retry the allocation
request. 
Failing that, SQLite will either stop what
it is doing and return the
[SQLITE\_NOMEM](rescode.html#nomem) error code back up to the application or it will
make do without the requested memory.
* **No memory leaks.**
The application is responsible for destroying any objects it allocates.
(For example, the application must use [sqlite3\_finalize()](c3ref/finalize.html) on 
every [prepared statement](c3ref/stmt.html) and [sqlite3\_close()](c3ref/close.html) on every 
[database connection](c3ref/sqlite3.html).) But as long as
the application cooperates, SQLite will never leak memory. This is
true even in the face of memory allocation failures or other system
errors.
* **Memory usage limits.**
The [sqlite3\_soft\_heap\_limit64()](c3ref/hard_heap_limit64.html) mechanism allows the application to
set a memory usage limit that SQLite strives to stay below. SQLite
will attempt to reuse memory from its caches rather than allocating new
memory as it approaches the soft limit.
* **Zero\-malloc option.**
The application can optionally provide SQLite with several buffers of bulk memory
at startup and SQLite will then use those provided buffers for all of
its memory allocation needs and never call system malloc() or free().
* **Application\-supplied memory allocators.**
The application can provide SQLite with pointers to alternative 
memory allocators at start\-time. The alternative memory allocator
will be used in place of system malloc() and free().
* **Proof against breakdown and fragmentation.**
SQLite can be configured so that, subject to certain usage constraints
detailed below, it is guaranteed to never fail a memory allocation
or fragment the heap.
This property is important to long\-running, high\-reliability
embedded systems where a memory allocation error could contribute
to an overall system failure.
* **Memory usage statistics.**
Applications can see how much memory they are using and detect when
memory usage is approaching or exceeding design boundaries.
* **Plays well with memory debuggers.**
Memory allocation in SQLite is structured so that standard
third\-party memory debuggers (such as [dmalloc](http://dmalloc.com) or 
[valgrind](http://valgrind.org)) can be used to verify correct
memory allocation behavior.
* **Minimal calls to the allocator.**
The system malloc() and free() implementations are inefficient
on many systems. SQLite strives to reduce overall processing time
by minimizing its use of malloc() and free().
* **Open access.**
Pluggable SQLite extensions or even the application itself can 
access to the same underlying memory allocation
routines used by SQLite through the
[sqlite3\_malloc()](c3ref/free.html), [sqlite3\_realloc()](c3ref/free.html), and [sqlite3\_free()](c3ref/free.html) interfaces.



