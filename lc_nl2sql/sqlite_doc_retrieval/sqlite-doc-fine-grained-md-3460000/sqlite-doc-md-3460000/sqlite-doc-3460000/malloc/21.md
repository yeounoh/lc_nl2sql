## 4\.1\.  Computing and controlling parameters **M** and **n**


The Robson proof applies separately to each of the memory allocators
used by SQLite:


* The general\-purpose memory allocator ([memsys5](malloc.html#memsys5)).
* The [pagecache memory allocator](malloc.html#pagecache).
* The [lookaside memory allocator](malloc.html#lookaside).


For allocators other than [memsys5](malloc.html#memsys5),
all memory allocations are of the same size. Hence, **n**\=1
and therefore **N**\=**M**. In other words, the memory pool need
be no larger than the largest amount of memory in use at any given moment.


The usage of pagecache memory is somewhat harder to control in
SQLite version 3\.6\.1, though mechanisms are planned for subsequent
releases that will make controlling pagecache memory much easier.
Prior to the introduction of these new mechanisms, the only way
to control pagecache memory is using the [cache\_size pragma](pragma.html#pragma_cache_size).


Safety\-critical applications will usually want to modify the
default lookaside memory configuration so that when the initial
lookaside memory buffer is allocated during [sqlite3\_open()](c3ref/open.html) the
resulting memory allocation is not so large as to force the **n**
parameter to be too large. In order to keep **n** under control,
it is best to try to keep the largest memory allocation below 2 or 4
kilobytes. Hence, a reasonable default setup for the lookaside
memory allocator might any one of the following:



> ```
> 
> sqlite3_config(SQLITE_CONFIG_LOOKASIDE, 32, 32);  /* 1K */
> sqlite3_config(SQLITE_CONFIG_LOOKASIDE, 64, 32);  /* 2K */
> sqlite3_config(SQLITE_CONFIG_LOOKASIDE, 32, 64);  /* 2K */
> sqlite3_config(SQLITE_CONFIG_LOOKASIDE, 64, 64);  /* 4K */
> 
> ```


Another approach is to initially disable the lookaside memory
allocator:



> ```
> 
> sqlite3_config(SQLITE_CONFIG_LOOKASIDE, 0, 0);
> 
> ```


Then let the application maintain a separate pool of larger
lookaside memory buffers that it can distribute to [database connections](c3ref/sqlite3.html)
as they are created. In the common case, the application will only
have a single [database connection](c3ref/sqlite3.html) and so the lookaside memory pool
can consist of a single large buffer.



> ```
> 
> sqlite3_db_config(db, SQLITE_DBCONFIG_LOOKASIDE, aStatic, 256, 500);
> 
> ```


The lookaside memory allocator is really intended as performance
optimization, not as a method for assuring breakdown\-free memory allocation,
so it is not unreasonable to completely disable the lookaside memory
allocator for safety\-critical operations.


The general purpose memory allocator is the most difficult memory pool
to manage because it supports allocations of varying sizes. Since 
**n** is a multiplier on **M** we want to keep **n** as small
as possible. This argues for keeping the minimum allocation size for
[memsys5](malloc.html#memsys5) as large as possible. In most applications, the
[lookaside memory allocator](malloc.html#lookaside) is able to handle small allocations. So
it is reasonable to set the minimum allocation size for [memsys5](malloc.html#memsys5) to
2, 4 or even 8 times the maximum size of a lookaside allocation. 
A minimum allocation size of 512 is a reasonable setting.


Further to keeping **n** small, one desires to keep the size of
the largest memory allocations under control.
Large requests to the general\-purpose memory allocator
might come from several sources:


1. SQL table rows that contain large strings or BLOBs.
2. Complex SQL queries that compile down to large [prepared statements](c3ref/stmt.html).
3. SQL parser objects used internally by [sqlite3\_prepare\_v2()](c3ref/prepare.html).
4. Storage space for [database connection](c3ref/sqlite3.html) objects.
5. Page cache memory allocations that overflow into the general\-purpose
 memory allocator.
6. Lookaside buffer allocations for new [database connections](c3ref/sqlite3.html).


The last two allocations can be controlled and/or eliminated by
configuring the [pagecache memory allocator](malloc.html#pagecache),
and [lookaside memory allocator](malloc.html#lookaside) appropriately, as described above.
The storage space required for [database connection](c3ref/sqlite3.html) objects depends
to some extent on the length of the filename of the database file, but
rarely exceeds 2KB on 32\-bit systems. (More space is required on
64\-bit systems due to the increased size of pointers.)
Each parser object uses about 1\.6KB of memory. Thus, elements 3 through 6
above can easily be controlled to keep the maximum memory allocation
size below 2KB.


If the application is designed to manage data in small pieces,
then the database should never contain any large strings or BLOBs
and hence element 1 above should not be a factor. If the database
does contain large strings or BLOBs, they should be read using
[incremental BLOB I/O](c3ref/blob.html) and rows that contain the
large strings or BLOBs should never be update by any means other
than [incremental BLOB I/O](c3ref/blob.html). Otherwise, the 
[sqlite3\_step()](c3ref/step.html) routine will need to read the entire row into
contiguous memory at some point, and that will involve at least
one large memory allocation.


The final source of large memory allocations is the space to hold
the [prepared statements](c3ref/stmt.html) that result from compiling complex SQL
operations. Ongoing work by the SQLite developers is reducing the
amount of space required here. But large and complex queries might
still require [prepared statements](c3ref/stmt.html) that are several kilobytes in
size. The only workaround at the moment is for the application to
break complex SQL operations up into two or more smaller and simpler 
operations contained in separate [prepared statements](c3ref/stmt.html).


All things considered, applications should normally be able to
hold their maximum memory allocation size below 2K or 4K. This
gives a value for log2(**n**) of 2 or 3\. This will
limit **N** to between 2 and 2\.5 times **M**.


The maximum amount of general\-purpose memory needed by the application
is determined by such factors as how many simultaneous open 
[database connection](c3ref/sqlite3.html) and [prepared statement](c3ref/stmt.html) objects the application
uses, and on the complexity of the [prepared statements](c3ref/stmt.html). For any
given application, these factors are normally fixed and can be
determined experimentally using [SQLITE\_STATUS\_MEMORY\_USED](c3ref/c_status_malloc_count.html#sqlitestatusmemoryused).
A typical application might only use about 40KB of general\-purpose
memory. This gives a value of **N** of around 100KB.


