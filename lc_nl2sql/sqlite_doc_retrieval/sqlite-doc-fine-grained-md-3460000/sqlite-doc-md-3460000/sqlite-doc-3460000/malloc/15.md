## 3\.2\.  Page cache memory


In most applications, the database page cache subsystem within 
SQLite uses more dynamically allocated memory than all other parts
of SQLite combined. It is not unusual to see the database page cache
consume over 10 times more memory than the rest of SQLite combined.


SQLite can be configured to make page cache memory allocations from
a separate and distinct memory pool of fixed\-size
slots. This can have two advantages:


* Because allocations are all the same size, the memory allocator can
operate much faster. The allocator need not bother with coalescing 
adjacent free slots or searching for a slot
of an appropriate size. All unallocated memory slots can be stored on
a linked list. Allocating consists of removing the first entry from the
list. Deallocating is simply adding an entry to the beginning of the list.
* With a single allocation size, the **n** parameter in the
[Robson proof](malloc.html#nofrag) is 1, and the total memory space required by the allocator
(**N**) is exactly equal to maximum memory used (**M**). 
No additional memory is required to cover fragmentation overhead, thus 
reducing memory requirements. This is particularly important for the
page cache memory since the page cache constitutes the largest component
of the memory needs of SQLite.


The page\-cache memory allocator is disabled by default.
An application can enable it at start\-time as follows:



> ```
> 
> [sqlite3_config](c3ref/config.html)([SQLITE_CONFIG_PAGECACHE](c3ref/c_config_covering_index_scan.html#sqliteconfigpagecache), pBuf, sz, N);
> 
> ```


The pBuf parameter is a pointer to a contiguous range of bytes that
SQLite will use for page\-cache memory allocations. The buffer must be
at least sz\*N bytes in size. The "sz" parameter
is the size of each page\-cache allocation. N is the maximum 
number of available allocations.


If SQLite needs a page\-cache entry that is larger than "sz" bytes or
if it needs more than N entries, it falls back to using the
general\-purpose memory allocator.



