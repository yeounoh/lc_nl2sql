## 2\.1\.  Use of reallocarray()


The reallocarray() interface is a recent innovation (circa 2014\)
from the OpenBSD community that grow out of efforts to prevent the
next ["heartbleed" bug](http://heartbleed.com) by avoiding 32\-bit integer
arithmetic overflow on memory allocation size computations. The
reallocarray() function has both unit\-size and count parameters.
To allocate memory sufficient to hold an array of N elements each X\-bytes
in size, one calls "reallocarray(0,X,N)". This is preferred over
the traditional technique of invoking "malloc(X\*N)" as reallocarray()
eliminates the risk that the X\*N multiplication will overflow and
cause malloc() to return a buffer that is a different size from what
the application expected.


SQLite does not use reallocarray(). The reason is that reallocarray()
is not useful to SQLite. It turns out that SQLite never does memory
allocations that are the simple product of two integers. Instead, SQLite
does allocations of the form "X\+C" or "N\*X\+C" or "M\*N\*X\+C" or
"N\*X\+M\*Y\+C", and so forth. The reallocarray() interface is not helpful
in avoiding integer overflow in those cases.


Nevertheless, integer overflow in the computation of memory allocation
sizes is a concern that SQLite would like to deal with. To prevent
problems, all SQLite internal memory allocations occur using thin wrapper
functions that take a signed 64\-bit integer size parameter. The SQLite 
source code is audited to ensure that all size computations are carried 
out using 64\-bit signed integers as well. SQLite will
refuse to allocate more than about 2GB of memory at one go. (In common
use, SQLite seldom ever allocates more than about 8KB of memory at a time
so a 2GB allocation limit is not a burden.) So the 64\-bit size parameter
provides lots of headroom for detecting overflows. The same audit that
verifies that all size computations are done as 64\-bit signed integers
also verifies that it is impossible to overflow a 64\-bit integer
during the computation.


The code audits used to ensure that memory allocation size computations
do not overflow in SQLite are repeated prior to every SQLite release.



