## 1\.3\. Subqueries



 In all the examples above, there has only been a single SELECT statement.
 If a query contains sub\-selects, those are shown as being children of
 the outer SELECT. For example:




```
sqlite> EXPLAIN QUERY PLAN SELECT (SELECT b FROM t1 WHERE a=0), (SELECT a FROM t1 WHERE b=t2.c) FROM t2;
|--SCAN TABLE t2 USING COVERING INDEX i4
|--SCALAR SUBQUERY
|  `--SEARCH t1 USING COVERING INDEX i2 (a=?)
`--CORRELATED SCALAR SUBQUERY
   `--SEARCH t1 USING INDEX i3 (b=?)

```


 The example above contains two "SCALAR" subqueries. The subqueries
 are SCALAR in the sense that they return a single value \- a one\-row,
 one\-column table. If the actual query returns more than that, then
 only the first column of the first row is used.



 The first subquery above is constant with respect to the outer query.
 The value for the first subquery can be computed once and then reused
 for each row of the outer SELECT. The second subquery, however, is
 "CORRELATED". The value of the second subquery changes depending
 on values in the current row of the outer query. Hence, the second
 subquery must be run once for each output row in the outer SELECT.




 Unless the [flattening optimization](optoverview.html#flattening) is applied, if a subquery appears in
 the FROM clause of a SELECT statement, SQLite can either run the subquery and
 stores the results in a temporary table, or it can run the subquery as a
 co\-routine. The following query is an example of the latter. The subquery
 is run by a co\-routine. The outer query blocks whenever it needs another
 row of input from the subquery. Control switches to the co\-routine which
 produces the desired output row, then control switches back to the main
 routine which continues processing. 




```
sqlite> EXPLAIN QUERY PLAN SELECT count(*)
      > FROM (SELECT max(b) AS x FROM t1 GROUP BY a) AS qqq
      > GROUP BY x;
QUERY PLAN
|--CO-ROUTINE qqq
|  `--SCAN t1 USING COVERING INDEX i2
|--SCAN qqqq
`--USE TEMP B-TREE FOR GROUP BY

```


 
 If the [flattening optimization](optoverview.html#flattening) is used on a subquery in the FROM clause
 of a SELECT statement, that effectively merges the subquery into the outer
 query. The output of EXPLAIN QUERY PLAN reflects this, as in the following
 example:




```
sqlite> EXPLAIN QUERY PLAN SELECT * FROM (SELECT * FROM t2 WHERE c=1) AS t3, t1;
QUERY PLAN
|--SEARCH t2 USING INDEX i4 (c=?)
`--SCAN t1

```



 If the content of a subquery might need to be visited more than once, then
 the use of a co\-routine is undesirable, as the co\-routine would then have to
 compute the data more than once. And if the subquery cannot be flattened,
 that means the subquery must be manifested into a transient table.




```
sqlite> SELECT * FROM
      >   (SELECT * FROM t1 WHERE a=1 ORDER BY b LIMIT 2) AS x,
      >   (SELECT * FROM t2 WHERE c=1 ORDER BY d LIMIT 2) AS y;
QUERY PLAN
|--MATERIALIZE x
|  `--SEARCH t1 USING COVERING INDEX i2 (a=?)
|--MATERIALIZE y
|  |--SEARCH t2 USING INDEX i4 (c=?)
|  `--USE TEMP B-TREE FOR ORDER BY
|--SCAN x
`--SCAN y

```

