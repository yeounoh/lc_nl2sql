## 1\.1\. Table and Index Scans



 When processing a SELECT (or other) statement, SQLite may retrieve data from
 database tables in a variety of ways. It may scan through all the records in
 a table (a full\-table scan), scan a contiguous subset of the records in a
 table based on the rowid index, scan a contiguous subset of the entries in a
 database [index](lang_createtable.html), or use a combination of the above strategies
 in a single scan. The various ways in which SQLite may retrieve data from a
 table or index are described in detail [here](queryplanner.html#searching).




 For each table read by the query, the output of EXPLAIN QUERY 
 PLAN includes a record for which the value in the "detail" column begins
 with either "SCAN" or "SEARCH". "SCAN" is used for a full\-table scan,
 including cases where SQLite iterates through all records in a table
 in an order defined by an index. "SEARCH" indicates that only a subset of 
 the table rows are visited. Each SCAN or SEARCH record includes the
 following information:



* The name of the table, view, or subquery that data is read from.
* Whether or not an index or [automatic index](optoverview.html#autoindex) is used.
* Whether or not the [covering index](queryplanner.html#covidx) optimization applies.
* Which terms of the WHERE clause are used for indexing.



 For example, the following EXPLAIN QUERY PLAN command operates on a SELECT
 statement that is implemented by performing a full\-table scan on table t1:



```
sqlite> EXPLAIN QUERY PLAN SELECT a, b FROM t1 WHERE a=1;
QUERY PLAN
`--SCAN t1

```


 The example above shows
 SQLite picking full\-table scan will visit all rows in the table.
 If the query were able to use an index, then the 
 SCAN/SEARCH record would include the name of the index and, for a
 SEARCH record, an indication of how the subset of rows visited is
 identified. For example:



```
sqlite> CREATE INDEX i1 ON t1(a);
sqlite> EXPLAIN QUERY PLAN SELECT a, b FROM t1 WHERE a=1;
QUERY PLAN
`--SEARCH t1 USING INDEX i1 (a=?)

```


 The previous example, SQLite uses index "i1" to optimize
 a WHERE clause term of the form (a\=?) \- in this case "a\=1".
 The previous example could not use a [covering index](queryplanner.html#covidx), but the following
 example can, and that fact is reflected in the output:



```
sqlite> CREATE INDEX i2 ON t1(a, b);
sqlite> EXPLAIN QUERY PLAN SELECT a, b FROM t1 WHERE a=1; 
QUERY PLAN
`--SEARCH t1 USING COVERING INDEX i2 (a=?)

```


 All joins in SQLite are [implemented using nested scans](optoverview.html#joins). When a
 SELECT query that features a join is analyzed using EXPLAIN QUERY PLAN, one
 SCAN or SEARCH record is output for each nested loop. For example:



```
sqlite> EXPLAIN QUERY PLAN SELECT t1.*, t2.* FROM t1, t2 WHERE t1.a=1 AND t1.b>2;
QUERY PLAN
|--SEARCH t1 USING INDEX i2 (a=? AND b>?)
`--SCAN t2

```


 The order of the entries indicates the nesting order. In
 this case, the scan of table t1 using index i2 is the outer loop (since it
 appears first)
 and the full\-table scan of table t2 is the inner loop (since it appears
 last).
 In the following example, the positions of t1 and t2 in the FROM 
 clause of the SELECT are reversed. The query strategy remains the same.
 The output from EXPLAIN QUERY PLAN shows how the query is actually
 evaluated, not how it is specified in the SQL statement.



```
sqlite> EXPLAIN QUERY PLAN SELECT t1.*, t2.* FROM t2, t1 WHERE t1.a=1 AND t1.b>2;
QUERY PLAN
|--SEARCH t1 USING INDEX i2 (a=? AND b>?)
`--SCAN t2

```



 If the WHERE clause of a query contains an OR expression, then SQLite might
 use the ["OR by union"](queryplanner.html#or_in_where) strategy (also known as the
 [OR optimization](optoverview.html#or_opt)). In this case there will be single top\-level record
 for the search, with two sub\-records, one for each index:



```
sqlite> CREATE INDEX i3 ON t1(b);
sqlite> EXPLAIN QUERY PLAN SELECT * FROM t1 WHERE a=1 OR b=2;
QUERY PLAN
`--MULTI-INDEX OR
   |--SEARCH t1 USING COVERING INDEX i2 (a=?)
   `--SEARCH t1 USING INDEX i3 (b=?)

```

