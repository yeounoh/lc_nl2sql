# 13\. CAST expressions


A CAST expression of the form "CAST(*expr* AS *type\-name*)"
is used to convert the value of *expr* to
a different [storage class](datatype3.html#storageclasses) specified by type\-name.
A CAST conversion is similar to the conversion that takes
place when a [column affinity](datatype3.html#affinity) is applied to a value except that with
the CAST operator the conversion always takes place even if the conversion
lossy and irreversible, whereas column affinity only changes the data type
of a value if the change is lossless and reversible.



If the value of *expr* is NULL, then the result of the CAST
expression is also NULL. Otherwise, the storage class of the result
is determined by applying the [rules for determining column affinity](datatype3.html#affname) to
the type\-name.




> | Affinity of type\-name | Conversion Processing |
> | --- | --- |
> | NONE | Casting a value to a type\-name with no affinity  causes the value to  be converted into a BLOB. Casting to a BLOB consists of first casting  the value to TEXT in the [encoding](pragma.html#pragma_encoding) of the database connection, then  interpreting the resulting byte sequence as a BLOB instead of as TEXT. |
> | TEXT | To cast a BLOB value to TEXT, the sequence of bytes that make up the  BLOB is interpreted as text encoded using the database encoding.    Casting an INTEGER or REAL value into TEXT renders the value as if via  [sqlite3\_snprintf()](c3ref/mprintf.html) except that the resulting TEXT uses the [encoding](pragma.html#pragma_encoding) of  the database connection. |
> | REAL | When casting a BLOB value to a REAL, the value is first converted to  TEXT.  When casting a TEXT value to REAL, the longest possible prefix of  the value that can be interpreted as a real number is extracted from  the TEXT value and the remainder ignored. Any leading spaces in the  TEXT value are ignored when converging from TEXT to REAL. If there is  no prefix that can be interpreted as a real number, the result of the  conversion is 0\.0\. |
> | INTEGER | When casting a BLOB value to INTEGER, the value is first converted to  TEXT.  When casting a TEXT value to INTEGER, the longest possible prefix of  the value that can be interpreted as an integer number is extracted from  the TEXT value and the remainder ignored. Any leading spaces in the  TEXT value when converting from TEXT to INTEGER are ignored. If there  is no prefix that can be interpreted as an integer number, the result  of the conversion is 0\. If the prefix integer is greater than  \+9223372036854775807 then the result of the cast is exactly  \+9223372036854775807\. Similarly, if the prefix integer is  less than \-9223372036854775808 then the result of the cast is  exactly \-9223372036854775808\.   When casting to INTEGER, if the text looks like a floating point  value with an exponent, the exponent will be ignored because it is  no part of the integer prefix. For example,  "CAST('123e\+5' AS INTEGER)" results in 123, not in 12300000\.    The CAST operator understands decimal  integers only â€” conversion of [hexadecimal integers](lang_expr.html#hexint) stops  at the "x" in the "0x" prefix of the hexadecimal integer string  and thus result of the CAST is always zero.   A cast of a REAL value into an INTEGER results in the integer  between the REAL value and zero that is closest to the REAL value.  If a REAL is greater than the greatest possible signed  integer (\+9223372036854775807\) then the result is the greatest possible  signed integer and if the REAL is less than the least possible signed  integer (\-9223372036854775808\) then the result is the least possible  signed integer.   Prior to SQLite version 3\.8\.2 (2013\-12\-06\),  casting a REAL value greater than  \+9223372036854775807\.0 into an integer resulted in the most negative  integer, \-9223372036854775808\. This behavior was meant to emulate the  behavior of x86/x64 hardware when doing the equivalent cast. |
> | NUMERIC | Casting a TEXT or BLOB value into NUMERIC yields either an INTEGER or  a REAL result.  If the input text looks like an integer (there is no decimal point nor  exponent) and the value is small enough to fit in a 64\-bit signed integer,  then the result will be INTEGER.  Input text that looks like floating point (there is a decimal point and/or  an exponent) and the text describes a value that  can be losslessly converted back and forth between IEEE 754 64\-bit float and a  51\-bit signed integer, then the result is INTEGER.  (In the previous sentence, a 51\-bit integer is specified since that is one  bit less than the length of the mantissa of an IEEE 754 64\-bit float and  thus provides a 1\-bit of margin for the text\-to\-float conversion operation.)  Any text input that describes a value outside the range of a 64\-bit  signed integer yields a REAL result.   Casting a REAL or INTEGER value to NUMERIC is a no\-op, even if a real  value could be losslessly converted to an integer. |


Note that the result from casting any non\-BLOB value into a
BLOB and the result from casting any BLOB value into a non\-BLOB value
may be different depending on whether the database [encoding](pragma.html#pragma_encoding) is UTF\-8,
UTF\-16be, or UTF\-16le.





