## Channel Reliability



 The "API Call" channel is highly reliable, to the extent
 that error rates are unstated and ignored as negligible.
 The channel fails only when the system loses power
 (excepting meteorites, etc.)




 The "File I/O" channel, when it directly reaches a local storage device,
 is also highly reliable.
 (Spinning storage MTBF exceeds 1 million hours,
 and NVRAM lasts longer.)
 Local devices also have a characteristic
 which is critical for enabling database management software
 to be designed to ensure [ACID](transactional.html) behavior:
 When all process writes to the device have completed,
 (when POSIX fsync() or Windows FlushFileBuffers() calls return),
 the filesystem then either has
 stored the "written" data or will do so
 before storing any subsequently written data.




 When network filesystem apparatus and software layers are interposed
 between filesystem clients and a filesystem over an actual storage device,
 significant sources of failure and misbehavior are introduced.
 While network data transfers are error\-checked well, transfer packets
 do not all reliably arrive at their destination once sent.
 Some packets are clobbered by other packets and must be resent.
 Under packet clobbering conditions, repeated retries
 can impose delays exceeding
 what is needed for similar data to reach local storage.
 Some portions of what a client writes can end up stored
 out of time order relative to other portions written.




 Because of the disordering and outright data loss
 which occur in network filesystem writes, it is critical
 that sets of file writes can be accurately known to be done
 before a subsequent set of file writes begins.
 This assurance is obtained by use of robustly designed
 and correctly implemented fsync() (or equivalent) OS functions.
 Unfortunately for some applications, network filesystem sync
 operation can be less robust than local filesystem sync.
 Attaining robust sync in the face of network packet transport errors
 is hard, and safeguards are sometimes relaxed in favor of performance.




 A similar hazard arises with file locking in network filesystems.
 SQLite relies on exclusive locks for write operations, and those have
 been known to operate incorrectly for some network filesystems. This
 has led to database corruption. That may happen again as the designers
 of such change their implementation to suit more common use cases.




 The bottom line is that network filesystem sync and locking reliability
 vary among implementations and installations. The design
 assumptions upon which it relies may hold more true where
 an application is tested than where it is relied upon.
 **Rely upon it at your (and your customers') peril.**
 See [How To Corrupt Your Database Files](lockingv3.html#how_to_corrupt).



