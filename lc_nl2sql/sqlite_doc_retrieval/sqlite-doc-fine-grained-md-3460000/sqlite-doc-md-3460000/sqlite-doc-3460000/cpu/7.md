# 3\. Performance Measurement Workflow



As SQLite developers edit the SQLite source code, they run the
[speed\-check.sh](https://sqlite.org/src/file/tool/speed-check.sh)
shell script to track the performance impact of changes. This
script compiles the speedtest1\.c program, runs it under cachegrind,
processes the cachegrind output using the
[cg\_anno.tcl](https://sqlite.org/src/file/tool/cg_anno.tcl) TCL
script, then saves the results in a series of text files.
Typical output from the speed\-check.sh script looks like this:




> ```
> 
> ==8683== 
> ==8683== I   refs:      1,060,925,768
> ==8683== I1  misses:       23,731,246
> ==8683== LLi misses:            5,176
> ==8683== I1  miss rate:          2.24%
> ==8683== LLi miss rate:          0.00%
> ==8683== 
> ==8683== D   refs:        557,686,925  (361,828,925 rd   + 195,858,000 wr)
> ==8683== D1  misses:        5,067,063  (  3,544,278 rd   +   1,522,785 wr)
> ==8683== LLd misses:           57,958  (     16,067 rd   +      41,891 wr)
> ==8683== D1  miss rate:           0.9% (        1.0%     +         0.8%  )
> ==8683== LLd miss rate:           0.0% (        0.0%     +         0.0%  )
> ==8683== 
> ==8683== LL refs:          28,798,309  ( 27,275,524 rd   +   1,522,785 wr)
> ==8683== LL misses:            63,134  (     21,243 rd   +      41,891 wr)
> ==8683== LL miss rate:            0.0% (        0.0%     +         0.0%  )
>    text	   data	    bss	    dec	    hex	filename
>  523044	   8240	   1976	 533260	  8230c	sqlite3.o
>  220507 1007870 7769352 sqlite3.c
> 
> ```


The important parts of the output (the parts that the developers pay
the most attention to) are shown in red.
Basically, the developers want to know the size of the compiled SQLite
library and how many CPU cycles were needed to run the performance test.



The output from the 
[cg\_anno.tcl](https://sqlite.org/src/file/tool/cg_anno.tcl) script
shows the number of CPU cycles spent on each line of code.
The report is approximately 80,000 lines long. The following is a brief
snippet taken from the middle of the report to show what it looks like:




> ```
> 
>          .  SQLITE_PRIVATE int sqlite3BtreeNext(BtCursor *pCur, int *pRes){
>          .    MemPage *pPage;
>          .    assert( cursorOwnsBtShared(pCur) );
>          .    assert( pRes!=0 );
>          .    assert( *pRes==0 || *pRes==1 );
>          .    assert( pCur->skipNext==0 || pCur->eState!=CURSOR_VALID );
>    369,648    pCur->info.nSize = 0;
>    369,648    pCur->curFlags &= ~(BTCF_ValidNKey|BTCF_ValidOvfl);
>    369,648    *pRes = 0;
>    739,296    if( pCur->eState!=CURSOR_VALID ) return btreeNext(pCur, pRes);
>  1,473,580    pPage = pCur->apPage[pCur->iPage];
>  1,841,975    if( (++pCur->aiIdx[pCur->iPage])>=pPage->nCell ){
>      4,340      pCur->aiIdx[pCur->iPage]--;
>      5,593      return btreeNext(pCur, pRes);
>          .    }
>    728,110    if( pPage->leaf ){
>          .      return SQLITE_OK;
>          .    }else{
>      3,117      return moveToLeftmost(pCur);
>          .    }
>    721,876  }
> 
> ```



The numbers on the left are the CPU cycle counts for that line of code,
of course.




The cg\_anno.tcl script removes extraneous details from the default 
cachegrind annotation
output so that before\-and\-after reports can be compared using a 
side\-by\-side diff to view specific details of how a
micro\-optimization attempt affected performance.




