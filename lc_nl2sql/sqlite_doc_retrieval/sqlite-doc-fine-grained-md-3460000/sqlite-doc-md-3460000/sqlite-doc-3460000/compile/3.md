# 3\.  Platform Configuration



**\_HAVE\_SQLITE\_CONFIG\_H**


> If the \_HAVE\_SQLITE\_CONFIG\_H macro is defined
>  then the SQLite source code will attempt to \#include a file named "sqlite\_cfg.h".
>  The "sqlite\_cfg.h" file usually contains other configuration options, especially
>  "HAVE\_*INTERFACE*" type options generated by autoconf scripts. Note that this
>  header is intended only for use for platform\-level configuration, not library\-level
>  configuration. To set SQLite\-level configuration flags in a custom header, define
>  SQLITE\_CUSTOM\_INCLUDE\=myconfig.h, as described in the previous section.


**HAVE\_FDATASYNC**


> If the HAVE\_FDATASYNC compile\-time option is true, then the default [VFS](vfs.html)
>  for unix systems will attempt to use fdatasync() instead of fsync() where
>  appropriate. If this flag is missing or false, then fsync() is always used.


**HAVE\_GMTIME\_R**


> If the HAVE\_GMTIME\_R option is true and if [SQLITE\_OMIT\_DATETIME\_FUNCS](compile.html#omit_datetime_funcs) is true,
>  then the CURRENT\_TIME, CURRENT\_DATE, and CURRENT\_TIMESTAMP keywords will use
>  the threadsafe "gmtime\_r()" interface rather than "gmtime()". In the usual case
>  where [SQLITE\_OMIT\_DATETIME\_FUNCS](compile.html#omit_datetime_funcs) is not defined or is false, then the
>  built\-in [date and time functions](lang_datefunc.html) are used to implement the CURRENT\_TIME,
>  CURRENT\_DATE, and CURRENT\_TIMESTAMP keywords and neither gmtime\_r() nor
>  gmtime() is ever called.


**HAVE\_ISNAN**


> If the HAVE\_ISNAN option is true, then SQLite invokes the system library isnan()
>  function to determine if a double\-precision floating point value is a NaN.
>  If HAVE\_ISNAN is undefined or false, then SQLite substitutes its own home\-grown
>  implementation of isnan().


**HAVE\_LOCALTIME\_R**


> If the HAVE\_LOCALTIME\_R option is true, then SQLite uses the threadsafe
>  localtime\_r() library routine instead of localtime()
>  to help implement the [localtime modifier](lang_datefunc.html#localtime)
>  to the built\-in [date and time functions](lang_datefunc.html).


**HAVE\_LOCALTIME\_S**


> If the HAVE\_LOCALTIME\_S option is true, then SQLite uses the threadsafe
>  localtime\_s() library routine instead of localtime()
>  to help implement the [localtime modifier](lang_datefunc.html#localtime)
>  to the built\-in [date and time functions](lang_datefunc.html).


**HAVE\_MALLOC\_USABLE\_SIZE**


> If the HAVE\_MALLOC\_USABLE\_SIZE option is true, then SQLite tries uses the
>  malloc\_usable\_size() interface to find the size of a memory allocation obtained
>  from the standard\-library malloc() or realloc() routines. This option is only
>  applicable if the standard\-library malloc() is used. On Apple systems,
>  "zone malloc" is used instead, and so this option is not applicable. And, of
>  course, if the application supplies its own malloc implementation using
>  [SQLITE\_CONFIG\_MALLOC](c3ref/c_config_covering_index_scan.html#sqliteconfigmalloc) then this option has no effect.
>  
>  If the HAVE\_MALLOC\_USABLE\_SIZE option is omitted or is false, then SQLite
>  uses a wrapper around system malloc() and realloc() that enlarges each allocation
>  by 8 bytes and writes the size of the allocation in the initial 8 bytes, and
>  then SQLite also implements its own home\-grown version of malloc\_usable\_size()
>  that consults that 8\-byte prefix to find the allocation size. This approach
>  works but it is suboptimal. Applications are encouraged to use
>  HAVE\_MALLOC\_USABLE\_SIZE whenever possible.


**HAVE\_STRCHRNUL**


> If the HAVE\_STRCHRNUL option is true, then SQLite uses the strchrnul() library
>  function. If this option is missing or false, then SQLite substitutes its own
>  home\-grown implementation of strchrnul().


**HAVE\_UTIME**


> If the HAVE\_UTIME option is true, then the built\-in but non\-standard
>  "unix\-dotfile" VFS will use the utime() system call, instead of utimes(),
>  to set the last access time on the lock file.


**SQLITE\_BYTEORDER\=*(0\|1234\|4321\)***


> SQLite needs to know if the native byte order of the target CPU is
>  big\-endian or little\-ending. The SQLITE\_BYTEORDER preprocessor is set
>  to 4321 for big\-endian machines and 1234 for little\-endian machines, or
>  it can be 0 to mean that the byte order must be determined at run\-time.
>  There are \#ifdefs in the code that set SQLITE\_BYTEORDER automatically
>  for all common platforms and compilers. However, it may be advantageous
>  to set SQLITE\_BYTEORDER appropriately when compiling SQLite for obscure
>  targets. If the target byte order cannot be determined at compile\-time,
>  then SQLite falls back to doing run\-time checks, which always work, though
>  with a small performance penalty.



