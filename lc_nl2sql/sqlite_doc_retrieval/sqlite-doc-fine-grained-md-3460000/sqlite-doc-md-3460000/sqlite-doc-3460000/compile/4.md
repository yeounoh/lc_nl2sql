# 4\.  Options To Set Default Parameter Values



**SQLITE\_DEFAULT\_AUTOMATIC\_INDEX\=*\<0 or 1\>***


> This macro determines the initial setting for [PRAGMA automatic\_index](pragma.html#pragma_automatic_index)
>  for newly opened [database connections](c3ref/sqlite3.html).
>  For all versions of SQLite through 3\.7\.17,
>  automatic indices are normally enabled for new database connections if
>  this compile\-time option is omitted.
>  However, that might change in future releases of SQLite.
>  See also: [SQLITE\_OMIT\_AUTOMATIC\_INDEX](compile.html#omit_automatic_index)


**SQLITE\_DEFAULT\_AUTOVACUUM\=*\<0 or 1 or 2\>***


> This macro determines if SQLite creates databases with the
>  [auto\_vacuum](pragma.html#pragma_auto_vacuum) flag set by default to OFF (0\), FULL (1\), or
>  INCREMENTAL (2\). The default value is 0 meaning that databases
>  are created with auto\-vacuum turned off.
>  In any case the compile\-time default may be overridden by the
>  [PRAGMA auto\_vacuum](pragma.html#pragma_auto_vacuum) command.


**SQLITE\_DEFAULT\_CACHE\_SIZE\=*\<N\>***


> This macro sets the default maximum size of the page\-cache for each attached
>  database. A positive value means that the limit is N page. If N is negative
>  that means to limit the cache size to \-N\*1024 bytes.
>  The suggested maximum cache size can be overridden by the
>  [PRAGMA cache\_size](pragma.html#pragma_cache_size) command. The default value is \-2000, which translates
>  into a maximum of 2048000 bytes per cache.


**SQLITE\_DEFAULT\_FILE\_FORMAT\=*\<1 or 4\>***


> The default [schema format number](fileformat2.html#schemaformat) used by SQLite when creating
>  new database files is set by this macro. The schema formats are all
>  very similar. The difference between formats 1 and 4 is that format
>  4 understands [descending indices](lang_createindex.html#descidx) and has a tighter encoding for
>  boolean values.
> 
> 
>  All versions of SQLite since 3\.3\.0 (2006\-01\-10\)
>  can read and write any schema format
>  between 1 and 4\. But older versions of SQLite might not be able to
>  read formats greater than 1\. So that older versions of SQLite will
>  be able to read and write database files created by newer versions
>  of SQLite, the default schema format was set to 1 for SQLite versions
>  through 3\.7\.9 (2011\-11\-01\). Beginning with
>  [version 3\.7\.10](releaselog/3_7_10.html) (2012\-01\-16\), the default
>  schema format is 4\.
> 
> 
>  The schema format number for a new database can be set at runtime using
>  the [PRAGMA legacy\_file\_format](pragma.html#pragma_legacy_file_format) command.


**SQLITE\_DEFAULT\_FILE\_PERMISSIONS\=*N***


> The default numeric file permissions for newly created database files
>  under unix. If not specified, the default is 0644 which means that
>  the files is globally readable but only writable by the creator.


**SQLITE\_DEFAULT\_FOREIGN\_KEYS\=*\<0 or 1\>***


> This macro determines whether enforcement of
>  [foreign key constraints](foreignkeys.html) is enabled or disabled by default for
>  new database connections. Each database connection can always turn
>  enforcement of foreign key constraints on and off and run\-time using
>  the [foreign\_keys pragma](pragma.html#pragma_foreign_keys). Enforcement of foreign key constraints
>  is normally off by default, but if this compile\-time parameter is
>  set to 1, enforcement of foreign key constraints will be on by default.


**SQLITE\_DEFAULT\_MMAP\_SIZE\=*N***


> This macro sets the default limit on the amount of memory that
>  will be used for memory\-mapped I/O
>  for each open database file. If the *N*
>  is zero, then memory mapped I/O is disabled by default. This
>  compile\-time limit and the [SQLITE\_MAX\_MMAP\_SIZE](compile.html#max_mmap_size) can be modified
>  at start\-time using the
>  [sqlite3\_config](c3ref/config.html)([SQLITE\_CONFIG\_MMAP\_SIZE](c3ref/c_config_covering_index_scan.html#sqliteconfigmmapsize)) call, or at run\-time
>  using the [mmap\_size pragma](pragma.html#pragma_mmap_size).


**SQLITE\_DEFAULT\_JOURNAL\_SIZE\_LIMIT\=*\<bytes\>***


> This option sets the size limit on [rollback journal](lockingv3.html#rollback) files in
>  [persistent journal mode](pragma.html#pragma_journal_mode) and
>  [exclusive locking mode](pragma.html#pragma_locking_mode) and on the size of the
>  write\-ahead log file in [WAL mode](wal.html). When this
>  compile\-time option is omitted there is no upper bound on the
>  size of the rollback journals or write\-ahead logs.
>  The journal file size limit
>  can be changed at run\-time using the [journal\_size\_limit pragma](pragma.html#pragma_journal_size_limit).


**SQLITE\_DEFAULT\_LOCKING\_MODE\=*\<1 or 0\>***


> If set to 1, then the default [locking\_mode](pragma.html#pragma_locking_mode) is set to EXCLUSIVE.
>  If omitted or set to 0 then the default [locking\_mode](pragma.html#pragma_locking_mode) is NORMAL.


**SQLITE\_DEFAULT\_LOOKASIDE\=*SZ,N***


> Sets the default size of the [lookaside memory allocator](malloc.html#lookaside) memory pool
>  to N entries of SZ bytes each. This setting can be modified at
>  start\-time using [sqlite3\_config](c3ref/config.html)([SQLITE\_CONFIG\_LOOKASIDE](c3ref/c_config_covering_index_scan.html#sqliteconfiglookaside)) and/or
>  as each [database connection](c3ref/sqlite3.html) is opened using
>  [sqlite3\_db\_config](c3ref/db_config.html)(db, [SQLITE\_DBCONFIG\_LOOKASIDE](c3ref/c_dbconfig_defensive.html#sqlitedbconfiglookaside)).


**SQLITE\_DEFAULT\_MEMSTATUS\=*\<1 or 0\>***


> This macro is used to determine whether or not the features enabled and
>  disabled using the SQLITE\_CONFIG\_MEMSTATUS argument to [sqlite3\_config()](c3ref/config.html)
>  are available by default. The default value is 1 ([SQLITE\_CONFIG\_MEMSTATUS](c3ref/c_config_covering_index_scan.html#sqliteconfigmemstatus)
>  related features enabled).
>  
>  The [sqlite3\_memory\_used()](c3ref/memory_highwater.html) and [sqlite3\_memory\_highwater()](c3ref/memory_highwater.html) interfaces,
>  the [sqlite3\_status64](c3ref/status.html)([SQLITE\_STATUS\_MEMORY\_USED](c3ref/c_status_malloc_count.html#sqlitestatusmemoryused)) interface,
>  and the [SQLITE\_MAX\_MEMORY](compile.html#max_memory) compile\-time option are all non\-functional
>  when memory usage tracking is disabled.


**SQLITE\_DEFAULT\_PCACHE\_INITSZ\=*N***


> This macro determines the number of pages initially allocated by the
>  page cache module when [SQLITE\_CONFIG\_PAGECACHE](c3ref/c_config_covering_index_scan.html#sqliteconfigpagecache) configuration option is
>  not use and memory for the page cache is obtained from [sqlite3\_malloc()](c3ref/free.html)
>  instead. The number of pages set by this macro are allocated in a single
>  allocation, which reduces the load on the memory allocator.


**SQLITE\_DEFAULT\_PAGE\_SIZE\=*\<bytes\>***


> This macro is used to set the default page\-size used when a
>  database is created. The value assigned must be a power of 2\. The
>  default value is 4096\. The compile\-time default may be overridden at
>  runtime by the [PRAGMA page\_size](pragma.html#pragma_page_size) command.


**SQLITE\_DEFAULT\_SYNCHRONOUS\=*\<0\-3\>***


> This macro determines the default value of the
>  [PRAGMA synchronous](pragma.html#pragma_synchronous) setting. If not overridden at compile\-time,
>  the default setting is 2 (FULL).


**SQLITE\_DEFAULT\_WAL\_SYNCHRONOUS\=*\<0\-3\>***


> This macro determines the default value of the
>  [PRAGMA synchronous](pragma.html#pragma_synchronous) setting for database files that open in
>  [WAL mode](wal.html). If not overridden at compile\-time, this value is the
>  same as [SQLITE\_DEFAULT\_SYNCHRONOUS](compile.html#default_synchronous).
>  
>  If SQLITE\_DEFAULT\_WAL\_SYNCHRONOUS differs from SQLITE\_DEFAULT\_SYNCHRONOUS,
>  and if the application has not modified the synchronous setting for
>  the database file using the [PRAGMA synchronous](pragma.html#pragma_synchronous) statement, then
>  the synchronous setting is changed to value defined by
>  SQLITE\_DEFAULT\_WAL\_SYNCHRONOUS when the database connection switches
>  into WAL mode for the first time.
>  If the SQLITE\_DEFAULT\_WAL\_SYNCHRONOUS value is not overridden at
>  compile\-time, then it will always be the same as
>  [SQLITE\_DEFAULT\_SYNCHRONOUS](compile.html#default_synchronous) and so no automatic synchronous setting
>  changes will ever occur.


**SQLITE\_DEFAULT\_WAL\_AUTOCHECKPOINT\=*\<pages\>***


> This macro sets the default page count for the [WAL](wal.html)
> [automatic checkpointing](wal.html#ckpt) feature. If unspecified,
>  the default page count is 1000\.


**SQLITE\_DEFAULT\_WORKER\_THREADS\=*N***


> This macro sets the default value for
>  the [SQLITE\_LIMIT\_WORKER\_THREADS](c3ref/c_limit_attached.html#sqlitelimitworkerthreads) parameter. The [SQLITE\_LIMIT\_WORKER\_THREADS](c3ref/c_limit_attached.html#sqlitelimitworkerthreads)
>  parameter sets the maximum number of auxiliary threads that a single
>  [prepared statement](c3ref/stmt.html) will launch to assist it with a query. If not specified,
>  the default maximum is 0\.
>  The value set here cannot be more than [SQLITE\_MAX\_WORKER\_THREADS](compile.html#max_worker_threads).


**SQLITE\_DQS\=*N***


> This macro determines the default values for
>  [SQLITE\_DBCONFIG\_DQS\_DDL](c3ref/c_dbconfig_defensive.html#sqlitedbconfigdqsddl) and [SQLITE\_DBCONFIG\_DQS\_DML](c3ref/c_dbconfig_defensive.html#sqlitedbconfigdqsdml), which
>  in turn determine how SQLite handles each [double\-quoted string literal](quirks.html#dblquote).
>  The "DQS" name stands for
>  "Double\-Quoted String".
>  The *N* argument should be an integer 0, 1, 2, or 3\.
>  
> > | SQLITE\_DQS Double\-Quoted Strings Allowed   Remarks  | In DDL In DML  | 3 yes yes default  | 2 yes no | 1 no yes | 0 no no recommended | | | | | --- | --- | --- | --- | | | | | | --- | --- | --- | --- | --- | --- | --- | --- | | | | | | | | | | | | | | |
> > | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
> 
> 
> The recommended setting is 0, meaning that double\-quoted
>  strings are disallowed in all contexts. However, the default
>  setting is 3 for maximum compatibility with legacy applications.


**SQLITE\_EXTRA\_DURABLE**


> The SQLITE\_EXTRA\_DURABLE compile\-time option that used to cause the default
>  [PRAGMA synchronous](pragma.html#pragma_synchronous) setting to be EXTRA, rather than FULL. This option
>  is no longer supported. Use
>  [SQLITE\_DEFAULT\_SYNCHRONOUS\=3](compile.html#default_synchronous) instead.


**SQLITE\_FTS3\_MAX\_EXPR\_DEPTH\=*N***


> This macro sets the maximum depth of the search tree that corresponds to
>  the right\-hand side of the MATCH operator in an [FTS3](fts3.html) or [FTS4](fts3.html#fts4) full\-text
>  index. The full\-text search uses a recursive algorithm, so the depth of
>  the tree is limited to prevent using too much stack space. The default
>  limit is 12\. This limit is sufficient for up to 4095 search terms on the
>  right\-hand side of the MATCH operator and it holds stack space usage to
>  less than 2000 bytes.
>  
>  For ordinary FTS3/FTS4 queries, the search tree depth is approximately
>  the base\-2 logarithm of the number of terms in the right\-hand side of the
>  MATCH operator. However, for [phrase queries](fts3.html#phrase) and [NEAR queries](fts3.html#near) the
>  search tree depth is linear in the number of right\-hand side terms.
>  So the default depth limit of 12 is sufficient for up to 4095 ordinary
>  terms on a MATCH, it is only sufficient for 11 or 12 phrase or NEAR
>  terms. Even so, the default is more than enough for most application.


**SQLITE\_JSON\_MAX\_DEPTH\=*N***


> This macro sets the maximum nesting depth for JSON objects and arrays.
>  The default value is 1000\.
>  
>  The [JSON SQL functions](json1.html) use a
>  [recursive decent parser](https://en.wikipedia.org/wiki/Recursive_descent_parser).
>  This means that deeply nested JSON might require a lot of stack space to
>  parse. On systems with limited stack space, SQLite can be compiled with
>  a greatly reduced maximum JSON nesting depth to avoid the possibility of
>  a stack overflow, even from hostile inputs. A value of 10 or 20 is normally
>  sufficient even for the most complex real\-world JSON.


**SQLITE\_LIKE\_DOESNT\_MATCH\_BLOBS**


> This compile\-time option causes the [LIKE](lang_expr.html#like) operator to always return
>  False if either operand is a BLOB. The default behavior of [LIKE](lang_expr.html#like)
>  is that BLOB operands are cast to TEXT before the comparison is done.
>  
>  This compile\-time option makes SQLite run more efficiently when processing
>  queries that use the [LIKE](lang_expr.html#like) operator, at the expense of breaking backwards
>  compatibility. However, the backwards compatibility break may be only
>  a technicality. There was a long\-standing bug in the [LIKE](lang_expr.html#like) processing logic
>  (see <https://www.sqlite.org/src/info/05f43be8fdda9f>) that caused it to
>  misbehavior for BLOB operands and nobody observed that bug in nearly
>  10 years of active use. So for more users, it is probably safe to
>  enable this compile\-time option and thereby save a little CPU time
>  on LIKE queries.
>  
>  This compile\-time option affects the SQL [LIKE](lang_expr.html#like) operator only and has
>  no impact on the [sqlite3\_strlike()](c3ref/strlike.html) C\-language interface.


**SQLITE\_MAX\_MEMORY\=*N***


> This option limits the total amount of memory that SQLite will request
>  from malloc() to *N* bytes. Any attempt by SQLite to allocate
>  new memory that would cause the sum of all allocations held by SQLite to exceed
>  *N* bytes will result in an out\-of\-memory error.
>  This is a hard upper limit. See also the [sqlite3\_soft\_heap\_limit()](c3ref/soft_heap_limit.html)
>  interface.
>  
>  This option is a limit on the *total* amount of memory allocated.
>  See the [SQLITE\_MAX\_ALLOCATION\_SIZE](compile.html#max_allocation_size) option for a limitation on the amount
>  of memory allowed in any single memory allocation.
>  
>  This limit is only functional if memory usage statistics are available via
>  the [sqlite3\_memory\_used()](c3ref/memory_highwater.html) and [sqlite3\_status64](c3ref/status.html)([SQLITE\_STATUS\_MEMORY\_USED](c3ref/c_status_malloc_count.html#sqlitestatusmemoryused))
>  interfaces. Without that memory usage information, SQLite has no way of
>  knowing when it is about to go over the limit, and thus is unable to prevent
>  the excess memory allocation. Memory usage tracking is turned on by default,
>  but can be disabled at compile\-time using the [SQLITE\_DEFAULT\_MEMSTATUS](compile.html#default_memstatus) option,
>  or at start\-time using [sqlite3\_config](c3ref/config.html)([SQLITE\_CONFIG\_MEMSTATUS](c3ref/c_config_covering_index_scan.html#sqliteconfigmemstatus)).


**SQLITE\_MAX\_MMAP\_SIZE\=*N***


> This macro sets a hard upper bound on the amount of address space that
>  can be used by any single database for memory\-mapped I/O.
>  Setting this value to 0 completely disables memory\-mapped I/O and
>  causes logic associated with memory\-mapped I/O to be omitted from the
>  build. This option does change the default memory\-mapped I/O address
>  space size (set by [SQLITE\_DEFAULT\_MMAP\_SIZE](compile.html#default_mmap_size) or
>  sqlite3\_config([SQLITE\_CONFIG\_MMAP\_SIZE](c3ref/c_config_covering_index_scan.html#sqliteconfigmmapsize)) or the
>  run\-time memory\-mapped I/O address space size (set by
>  sqlite3\_file\_control([SQLITE\_FCNTL\_MMAP\_SIZE](c3ref/c_fcntl_begin_atomic_write.html#sqlitefcntlmmapsize)) or
>  [PRAGMA mmap\_size](pragma.html#pragma_mmap_size)) as long as those other settings are less than the
>  maximum value defined here.


**SQLITE\_MAX\_SCHEMA\_RETRY\=*N***


> Whenever the database schema changes, prepared statements are automatically
>  reprepared to accommodate the new schema. There is a race condition here
>  in that if one thread is constantly changing the schema, another thread
>  might spin on reparses and repreparations of a prepared statement and
>  never get any real work done. This parameter prevents an infinite loop
>  by forcing the spinning thread to give up after a fixed number of attempts
>  at recompiling the prepared statement. The default setting is 50 which is
>  more than adequate for most applications.


**SQLITE\_MAX\_WORKER\_THREADS\=*N***


> Set an upper bound on the [sqlite3\_limit](c3ref/limit.html)(db,[SQLITE\_LIMIT\_WORKER\_THREADS](c3ref/c_limit_attached.html#sqlitelimitworkerthreads),N)
>  setting that determines the maximum number of auxiliary threads that a single
>  [prepared statement](c3ref/stmt.html) will use to aid with CPU\-intensive computations
>  (mostly sorting). See also the [SQLITE\_DEFAULT\_WORKER\_THREADS](compile.html#default_worker_threads) options.


**SQLITE\_MEMDB\_DEFAULT\_MAXSIZE\=*N***


> Set the default size limit (in bytes) for in\-memory databases created using
>  [sqlite3\_deserialize()](c3ref/deserialize.html). This is just the default. The limit can be
>  changed at start\-time using
>  [sqlite3\_config](c3ref/config.html)([SQLITE\_CONFIG\_MEMDB\_MAXSIZE](c3ref/c_config_covering_index_scan.html#sqliteconfigmemdbmaxsize),N)
>  or at run\-time for individual databases using the
>  [SQLITE\_FCNTL\_SIZE\_LIMIT](c3ref/c_fcntl_begin_atomic_write.html#sqlitefcntlsizelimit) [file\-control](c3ref/file_control.html).
>  If no default is specified, 1073741824 is used.


**SQLITE\_MINIMUM\_FILE\_DESCRIPTOR\=*N***


> The unix [VFS](vfs.html) will never use a file descriptor less than *N*. The
>  default value of *N* is 3\.
>  
>  Avoiding the use of low\-numbered file descriptors is a defense against
>  accidental database corruption. If a database file was opened using
>  file descriptor 2, for example, and then an assert() failed and invoked
>  write(2,...), that would likely cause database corruption by overwriting
>  part of the database file with the assertion error message. Using only
>  higher\-valued file descriptors avoids this potential problem. The
>  protection against
>  using low\-numbered file descriptors can be disabled by setting this
>  compile\-time option to 0\.


**SQLITE\_POWERSAFE\_OVERWRITE\=*\<0 or 1\>***


> This option changes the default assumption about [powersafe overwrite](psow.html)
>  for the underlying filesystems for the unix and windows [VFSes](vfs.html).
>  Setting SQLITE\_POWERSAFE\_OVERWRITE to 1 causes SQLite to assume that
>  application\-level writes cannot changes bytes outside the range of
>  bytes written even if the write occurs just before a power loss.
>  With SQLITE\_POWERSAFE\_OVERWRITE set to 0, SQLite assumes that other
>  bytes in the same sector with a written byte might be changed or
>  damaged by a power loss.


**SQLITE\_PRINTF\_PRECISION\_LIMIT\=*N***


> This option limits the maximum width and precision of substitutions
>  for the [printf() SQL function](lang_corefunc.html#printf) and the other C\-language string
>  formatting functions such as [sqlite3\_mprintf()](c3ref/mprintf.html) and
>  [sqlite3\_str\_appendf()](c3ref/str_append.html). This is turn can prevent a hostile or
>  malfunctioning script from using excessive memory by invoking
>  a format such as: "printf('%\*s',2147483647,'hi')".
>  A value for *N* of around 100000 is normally sufficient.
>  
>  The [printf() SQL function](lang_corefunc.html#printf) is subject to the [SQLITE\_LIMIT\_LENGTH](c3ref/c_limit_attached.html#sqlitelimitlength)
>  limit of [sqlite3\_limit()](c3ref/limit.html). Hence any printf() result with a
>  width or precision more than the SQLITE\_LIMIT\_LENGTH will cause
>  an [SQLITE\_TOOBIG](rescode.html#toobig) error. However, the low\-level formatting
>  for the printf() function is done by a subroutine that does not
>  have access to SQLITE\_LIMIT\_LENGTH. So the low\-level formatting
>  is done into a memory allocation that might be considerably larger
>  than SQLITE\_LIMIT\_LENGTH and the SQLITE\_LIMIT\_LENGTH check is only
>  performed after all formatting is complete. Thus there might be a
>  transient buffer that exceeds SQLITE\_LIMIT\_LENGTH. The
>  SQLITE\_PRINTF\_PRECISION\_LIMIT option is an additional check
>  that prevents excess sizes for the transient buffer used inside
>  the low\-level formatting subroutine, prior to the
>  SQLITE\_LIMIT\_LENGTH check.
>  
>  Be careful not to set SQLITE\_PRINTF\_PRECISION\_LIMIT too low.
>  SQLite uses its [built\-in printf()](printf.html) functionality to format the text
>  of CREATE statements stored in the [sqlite\_schema table](schematab.html). So
>  SQLITE\_PRINTF\_PRECISION\_LIMIT should be at least as big as the largest
>  table, index, view, or trigger definition that you are likely to
>  encounter.
>  
>  No error is raised if a width or precision exceeds
>  SQLITE\_PRINTF\_PRECISION\_LIMIT. Instead, the large width or
>  precision is silently truncated.
>  
>  The default value for SQLITE\_PRINTF\_PRECISION\_LIMIT is 2147483647
>  (0x7fffffff).


**SQLITE\_QUERY\_PLANNER\_LIMIT\=*N***


> As part of the query planning process, SQLite enumerates all usable
>  combinations of indexes and WHERE\-clause constraints. For certain
>  pathological queries, the number of these index\-and\-constraint combinations
>  can be very large, resulting in slow performance by the query planner.
>  The SQLITE\_QUERY\_PLANNER\_LIMIT value (in conjunction with the
>  related [SQLITE\_QUERY\_PLANNER\_LIMIT\_INCR](compile.html#query_planner_limit_incr) setting) limits the number
>  of index\-and\-constraint combinations that the query planner will
>  consider, in order to prevent the query planner from using excess
>  CPU time. The default value for SQLITE\_QUERY\_PLANNER\_LIMIT is set
>  high enough so that is never reached for real\-world queries. The
>  query planner search limit only applies to queries that are deliberately
>  crafted to use excess planning time.


**SQLITE\_QUERY\_PLANNER\_LIMIT\_INCR\=*N***


> The [SQLITE\_QUERY\_PLANNER\_LIMIT](compile.html#query_planner_limit) option sets an initial baseline value
>  for the maximum number of index\-and\-constraint combinations that the
>  query planner consider. The baseline query planner limit is increased
>  by SQLITE\_QUERY\_PLANNER\_LIMIT\_INCR prior to processing each table of a
>  join so that each table is guaranteed to be able to propose at least
>  some index\-and\-constraint combinations to the optimizer even if prior
>  tables of the join have exhausted the baseline limit. The default
>  value for both this compile\-time option and the
>  [SQLITE\_QUERY\_PLANNER\_LIMIT](compile.html#query_planner_limit) option are set high enough so that they should
>  never be reached for real\-world queries.


**SQLITE\_REVERSE\_UNORDERED\_SELECTS**


> This option causes the [PRAGMA reverse\_unordered\_selects](pragma.html#pragma_reverse_unordered_selects) setting to be
>  enabled by default. When enabled, [SELECT](lang_select.html) statements that lack an
>  ORDER BY clause will run in reverse order.
>  This option is useful for detecting when applications (incorrectly)
>  assume that the order of rows in a SELECT without an ORDER BY clause
>  will always be the same.


**SQLITE\_SORTER\_PMASZ\=*N***


> If multi\-threaded processing is enabled via the
>  [PRAGMA threads](pragma.html#pragma_threads) setting, then sort operations will
>  attempt to start helper threads when the amount of content
>  to be sorted exceeds the minimum of the [cache\_size](pragma.html#pragma_cache_size) and PMA Size
>  determined by the [SQLITE\_CONFIG\_PMASZ](c3ref/c_config_covering_index_scan.html#sqliteconfigpmasz) start\-time option.
>  This compile\-time option sets the default value for the
>  [SQLITE\_CONFIG\_PMASZ](c3ref/c_config_covering_index_scan.html#sqliteconfigpmasz) start\-time option.
>  The default value is 250\.


**SQLITE\_STMTJRNL\_SPILL\=*N***


> The SQLITE\_STMTJRNL\_SPILL compile\-time option determines the
>  default setting of the [SQLITE\_CONFIG\_STMTJRNL\_SPILL](c3ref/c_config_covering_index_scan.html#sqliteconfigstmtjrnlspill) start\-time
>  setting. That setting determines the size threshold above which
>  [statement journals](tempfiles.html#stmtjrnl) are moved from memory to disk.


**SQLITE\_WIN32\_MALLOC**


> This option enables the use of the Windows Heap API functions for memory
>  allocation instead of the standard library malloc() and free() routines.


**YYSTACKDEPTH\=*\<max\_depth\>***


> This macro sets the maximum depth of the LALR(1\) stack used by
>  the SQL parser within SQLite. The default value is 100\. A typical
>  application will use less than about 20 levels of the stack.
>  Developers whose applications contain SQL statements that
>  need more than 100 LALR(1\) stack entries should seriously
>  consider refactoring their SQL as it is likely to be well beyond
>  the ability of any human to comprehend.


