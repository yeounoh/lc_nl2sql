## 3\.3\. Queries Against A Graph


Suppose you have an undirected graph where each node is
identified by an integer and edges are defined by a table like
this:




> ```
> 
> CREATE TABLE edge(aa INT, bb INT);
> CREATE INDEX edge_aa ON edge(aa);
> CREATE INDEX edge_bb ON edge(bb);
> 
> ```


The indexes are not required, but they do help performance
for large graphs.
To find all nodes of the graph that are connected to
node 59, use a query similar to the following:




> ```
> 
> WITH RECURSIVE nodes(x) AS (
>    SELECT 59
>    UNION
>    SELECT aa FROM edge JOIN nodes ON bb=x
>    UNION
>    SELECT bb FROM edge JOIN nodes ON aa=x
> )
> SELECT x FROM nodes;
> 
> ```



The initial\-select in this case is the simple query
"SELECT 59". This establishes the base case. The
recursive\-select consists of the other two
SELECT statements. The first recursive SELECT follows edges
in the bb\-to\-aa direction and the second recursive SELECT follows
edges in the aa\-to\-bb direction. UNION is used instead of
UNION ALL to prevent the recursion from entering an infinite
loop if the graph contains cycles.



Here is a real\-world example of using a graph query against a
directed graph:
A version control system (VCS) will typically store the evolving
versions of a project as a directed acyclic graph (DAG). Call each
version of the project a "checkin". A single
checkin can have zero or more parents. Most checkins (except the
first) have a single parent, but in the case of a merge, a checkin
might have two or three or more parents. A schema to keep track of
checkins and the order in which they occur might look something like
this:




> ```
> 
> CREATE TABLE checkin(
>   id INTEGER PRIMARY KEY,
>   mtime INTEGER -- timestamp when this checkin occurred
> );
> CREATE TABLE derivedfrom(
>   xfrom INTEGER NOT NULL REFERENCES checkin, -- parent checkin
>   xto INTEGER NOT NULL REFERENCES checkin,   -- derived checkin
>   PRIMARY KEY(xfrom,xto)
> );
> CREATE INDEX derivedfrom_back ON derivedfrom(xto,xfrom);
> 
> ```


This graph is acyclic. And we assume that the mtime of every
child checkin is no less than the mtime of all its parents. But
unlike the earlier examples, this graph might have multiple paths of
differing lengths between any two checkins.



We want to know the twenty most recent ancestors in time (out of
the thousands and thousands of ancestors in the whole DAG) for
checkin "@BASELINE". (A query similar to this is used
by the [Fossil](http://www.fossil-scm.org/) VCS to
show the N most recent ancestors of a checkin. For example:
[https://www.sqlite.org/src/timeline?p\=trunk\&n\=30](https://www.sqlite.org/src/timeline?p=trunk&n=30).)




> ```
> 
> WITH RECURSIVE
>   ancestor(id,mtime) AS (
>     SELECT id, mtime FROM checkin WHERE id=@BASELINE
>     UNION
>     SELECT derivedfrom.xfrom, checkin.mtime
>       FROM ancestor, derivedfrom, checkin
>      WHERE ancestor.id=derivedfrom.xto
>        AND checkin.id=derivedfrom.xfrom
>      ORDER BY checkin.mtime DESC
>      LIMIT 20
>   )
> SELECT * FROM checkin JOIN ancestor USING(id);
> 
> ```



The "ORDER BY checkin.mtime DESC" term in the recursive\-select makes
the query run much faster by preventing it from following
branches that merge checkins
from long ago. The ORDER BY forces the recursive\-select to focus
on the most recent checkins, the ones we want. Without the ORDER BY
on the recursive\-select, one would be forced to compute the complete set of
thousands of ancestors, sort them all by mtime, then take the top twenty.
The ORDER BY essentially sets up a priority queue that
forces the recursive query to look at the most recent ancestors first,
allowing the use of a LIMIT clause to restrict the scope of the
query to just the checkins of interest.




