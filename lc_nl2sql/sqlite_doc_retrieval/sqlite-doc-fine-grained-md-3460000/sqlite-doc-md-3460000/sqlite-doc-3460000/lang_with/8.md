## 3\.5\. Outlandish Recursive Query Examples


The following query computes an approximation of the Mandelbrot Set
and outputs the result as ASCII\-art:




> ```
> 
> WITH RECURSIVE
>   xaxis(x) AS (VALUES(-2.0) UNION ALL SELECT x+0.05 FROM xaxis WHERE x<1.2),
>   yaxis(y) AS (VALUES(-1.0) UNION ALL SELECT y+0.1 FROM yaxis WHERE y<1.0),
>   m(iter, cx, cy, x, y) AS (
>     SELECT 0, x, y, 0.0, 0.0 FROM xaxis, yaxis
>     UNION ALL
>     SELECT iter+1, cx, cy, x*x-y*y + cx, 2.0*x*y + cy FROM m 
>      WHERE (x*x + y*y) < 4.0 AND iter<28
>   ),
>   m2(iter, cx, cy) AS (
>     SELECT max(iter), cx, cy FROM m GROUP BY cx, cy
>   ),
>   a(t) AS (
>     SELECT group_concat( substr(' .+*#', 1+min(iter/7,4), 1), '') 
>     FROM m2 GROUP BY cy
>   )
> SELECT group_concat(rtrim(t),x'0a') FROM a;
> 
> ```


In this query, the "xaxis" and "yaxis" CTEs define the grid of points for
which the Mandelbrot Set will be approximated. Each row in the
"m(iter,cx,cy,x,y)" CTE means that after "iter" iterations, the Mandelbrot
iteration starting at cx,cy has reached point x,y. The number of iterations
in this example is limited to 28 (which severely limits the resolution of
the computation, but is sufficient for low\-resolution ASCII\-art output).
The "m2(iter,cx,cy)" CTE holds the maximum number of iterations reached when
starting at point cx,cy.
Finally, each row in the "a(t)" CTE holds a string 
which is a single line of the output ASCII\-art.
The SELECT statement at the end just queries the "a" CTE to
retrieve all lines of ASCII\-art, one by one.



Running the query above in an SQLite [command\-line shell](cli.html) results
in the following output:




> ```
> 
>                                     ....#
>                                    ..#*..
>                                  ..+####+.
>                             .......+####....   +
>                            ..##+*##########+.++++
>                           .+.##################+.
>               .............+###################+.+
>               ..++..#.....*#####################+.
>              ...+#######++#######################.
>           ....+*################################.
>  #############################################...
>           ....+*################################.
>              ...+#######++#######################.
>               ..++..#.....*#####################+.
>               .............+###################+.+
>                           .+.##################+.
>                            ..##+*##########+.++++
>                             .......+####....   +
>                                  ..+####+.
>                                    ..#*..
>                                     ....#
>                                     +.
> 
> ```



This next query solves a Sudoku puzzle. The state of the puzzle is
defined by an 81\-character string formed by reading entries from the
puzzle box row by row from left to right and then from top to bottom.
Blank squares in the puzzle are denoted by a "." character. 
Thus the input string:




> 53\..7\....6\..195\....98\....6\.8\...6\...34\..8\.3\..17\...2\...6\.6\....28\....419\..5\....8\..79


Corresponds to a puzzle like this:




> | 5 | 3 |  |  | 7 |  |  |  |  |
> | --- | --- | --- | --- | --- | --- | --- | --- | --- |
> | 6 |  |  | 1 | 9 | 5 |  |  |  |
> |  | 9 | 8 |  |  |  |  | 6 |  |
> | 8 |  |  |  | 6 |  |  |  | 3 |
> | 4 |  |  | 8 |  | 3 |  |  | 1 |
> | 7 |  |  |  | 2 |  |  |  | 6 |
> |  | 6 |  |  |  |  | 2 | 8 |  |
> |  |  |  | 4 | 1 | 9 |  |  | 5 |
> |  |  |  |  | 8 |  |  | 7 | 9 |


This is the query that solves the puzzle:




> ```
> 
> WITH RECURSIVE
>   input(sud) AS (
>     VALUES('53..7....6..195....98....6.8...6...34..8.3..17...2...6.6....28....419..5....8..79')
>   ),
>   digits(z, lp) AS (
>     VALUES('1', 1)
>     UNION ALL SELECT
>     CAST(lp+1 AS TEXT), lp+1 FROM digits WHERE lp<9
>   ),
>   x(s, ind) AS (
>     SELECT sud, instr(sud, '.') FROM input
>     UNION ALL
>     SELECT
>       substr(s, 1, ind-1) || z || substr(s, ind+1),
>       instr( substr(s, 1, ind-1) || z || substr(s, ind+1), '.' )
>      FROM x, digits AS z
>     WHERE ind>0
>       AND NOT EXISTS (
>             SELECT 1
>               FROM digits AS lp
>              WHERE z.z = substr(s, ((ind-1)/9)*9 + lp, 1)
>                 OR z.z = substr(s, ((ind-1)%9) + (lp-1)*9 + 1, 1)
>                 OR z.z = substr(s, (((ind-1)/3) % 3) * 3
>                         + ((ind-1)/27) * 27 + lp
>                         + ((lp-1) / 3) * 6, 1)
>          )
>   )
> SELECT s FROM x WHERE ind=0;
> 
> ```


The "input" CTE defines the input puzzle.
The "digits" CTE defines a table that holds all digits between 1 and 9\.
The work of solving the puzzle is undertaken by the "x" CTE.
An entry in x(s,ind) means that the 81\-character string "s" is a valid
sudoku puzzle (it has no conflicts) and that the first unknown character
is at position "ind", or ind\=\=0 if all character positions are filled in.
The goal, then, is to compute entries for "x" with an "ind" of 0\.



The solver works by adding new entries to the "x" recursive table.
Given prior entries, the recursive\-select tries to fill in a single new
position with all values between 1 and 9 that actually work in that
position. The complicated "NOT EXISTS" subquery is the magic that
figures out whether or not each candidate "s" string is a valid
sudoku puzzle or not.



The final answer is found by looking for a string with ind\=\=0\.
If the original sudoku problem did not have a unique solution, then
the query will return all possible solutions. If the original problem
was unsolvable, then no rows will be returned. In this case, the unique
answer is:




> 534678912672195348198342567859761423426853791713924856961537284287419635345286179


The solution was computed in less than 300 milliseconds on a modern
workstation.




