# 3\. Recursive Common Table Expressions


A recursive common table expression can be used to write a query that
walks a tree or graph. A recursive common table expression has the same
basic syntax as an ordinary common table expression, but with the following
additional attributes:



1. The "[select\-stmt](syntax/select-stmt.html)" must be a [compound select](lang_select.html#compound). That is to say,
 the CTE body must be two or more individual SELECT statements
 separated by compound operators like UNION, UNION ALL, INTERSECT,
 or EXCEPT.
2. One or more of the individual SELECT statements that make up
 the compound must be
 "recursive". A SELECT statement is recursive if
 its FROM clause contains exactly one reference to
 the CTE table (the table named on the left\-hand side of the
 AS clause).
3. One or more of the SELECT statements in the compound must be
 non\-recursive.
4. All non\-recursive SELECT statements must occur before any
 recursive SELECT statements.
5. The recursive SELECT statements must be separated from the
 non\-recursive SELECT statements
 and from each other by the UNION or UNION ALL operators.
 If there are two or more recursive SELECT statements, they all must
 be separated from each other using the same operator that separates
 the first recursive SELECT from the last non\-recursive SELECT statement.
6. Recursive SELECT statements may not use
 [aggregate functions](lang_aggfunc.html) or [window functions](windowfunctions.html).


To put it another way, a recursive common table expression must
look something like the following:

**[recursive\-cte:](syntax/recursive-cte.html)**
hide








cte\-table\-name



AS



(



initial\-select



UNION



ALL



recursive\-select



)






UNION



**[cte\-table\-name:](syntax/cte-table-name.html)**
show








table\-name



(



column\-name



)




,












In the diagram above, initial\-select means one or more
non\-recursive SELECT statements and recursive\-select means
one or more recursive SELECT statements. The most common case is for there
to be exactly one initial\-select and exactly one
recursive\-select but more than one of each is allowed.


Call the table named by the [cte\-table\-name](syntax/cte-table-name.html) in a recursive
common table expression the "recursive table".
In the [recursive\-cte](syntax/recursive-cte.html) bubble diagram above, the recursive
table must appear exactly once in the FROM clause of each
top\-level SELECT statement in the recursive\-select
and must not appear anywhere else in either the
initial\-select or the
recursive\-select, including subqueries.
The initial\-select may be
a [compound select](lang_select.html#compound), but it may not include an ORDER BY, LIMIT, or OFFSET.
The recursive\-select may also be a [compound select](lang_select.html#compound) with
the restriction that all elements of that compound must be separated by
the same UNION or UNION ALL operator that separates
initial\-select from recursive\-select.
The recursive\-select is allowed to include an
ORDER BY, LIMIT, and/or OFFSET but may not use
[aggregate functions](lang_aggfunc.html) or [window functions](windowfunctions.html).



The ability for the recursive\-select to be a compound
was added in [version 3\.34\.0](releaselog/3_34_0.html) (2020\-12\-01\). In earlier versions of
SQLite, the recursive\-select could only be a single
simple SELECT statement.


The basic algorithm for computing the content of the recursive table
is as follows:



1. Run the initial\-select and add the results to a queue.
2. While the queue is not empty:
	1. Extract a single row from the queue.
	2. Insert that single row into the recursive table
	3. Pretend that the single row just extracted is the only
	 row in the recursive table and run the recursive\-select,
	 adding all results to the queue.


The basic procedure above may modified by the following additional rules:



* If a UNION operator connects the initial\-select with the
 recursive\-select, then only add rows to the queue if 
 no identical row has
 been previously added to the queue. Repeated rows are discarded before being
 added to the queue even if the repeated rows have already been extracted
 from the queue by the recursion step. If the operator is UNION ALL,
 then all rows generated by both the initial\-select and the
 recursive\-select are always added to the queue even if
 they are repeats.
 When determining if a row is repeated, NULL values compare
 equal to one another and not equal to any other value.
* The LIMIT clause, if present, determines the maximum number of rows that
 will ever be added to the recursive table in step 2b.
 Once the limit is reached, the recursion stops.
 A limit of zero means that no rows are ever added to the
 recursive table, and a negative limit means an unlimited number of rows
 may be added to the recursive table.
* The OFFSET clause, if it is present and has a positive value N, prevents the
 first N rows from being added to the recursive table.
 The first N rows are still processed
 by the recursive\-select â€” they
 just are not added to the recursive table. Rows are not counted toward
 fulfilling the LIMIT until all OFFSET rows have been skipped.
* If an ORDER BY clause is present, it determines the order in which rows
 are extracted from the queue in step 2a. If there is no ORDER BY clause,
 then the order in which rows are extracted is undefined. (In the current
 implementation, the queue becomes a FIFO if the ORDER BY clause is omitted,
 but applications should not depend on that fact since it might change.)



