## 2\.3\. Registers


Every bytecode program has a fixed (but potentially large) number of
registers. A single register can hold a variety of objects:
* A NULL value
* A signed 64\-bit integer
* An IEEE double\-precision (64\-bit) floating point number
* An arbitrary length string
* An arbitrary length BLOB
* A RowSet object (See the [RowSetAdd](opcode.html#RowSetAdd), [RowSetRead](opcode.html#RowSetRead), and
 [RowSetTest](opcode.html#RowSetTest) opcodes)
* A Frame object (Used by [subprograms](opcode.html#subprog) \- see [Program](opcode.html#Program))


A register can also be "Undefined" meaning that it holds no value
at all. Undefined is different from NULL. Depending on compile\-time
options, an attempt to read an undefined register will usually cause
a run\-time error. If the code generator ([sqlite3\_prepare\_v2()](c3ref/prepare.html))
ever generates a [prepared statement](c3ref/stmt.html) that reads an Undefined register,
that is a bug in the code generator.




Registers are numbered beginning with 0\.
Most opcodes refer to at least one register.



The number of registers in a single prepared statement is fixed
at compile\-time. The content of all registers is cleared when
a prepared statement is [reset](c3ref/reset.html) or
[finalized](c3ref/finalize.html).



The internal Mem object stores the value for a single register.
The abstract [sqlite3\_value](c3ref/value.html) object that is exposed in the API is really
just a Mem object or register.



