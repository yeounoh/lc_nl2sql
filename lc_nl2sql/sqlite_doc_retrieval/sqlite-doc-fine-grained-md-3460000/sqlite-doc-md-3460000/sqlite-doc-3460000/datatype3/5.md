# 3\. Type Affinity



SQL database engines that use rigid typing will usually try to
automatically convert values to the appropriate datatype. Consider this:




> ```
> 
> CREATE TABLE t1(a INT, b VARCHAR(10));
> INSERT INTO t1(a,b) VALUES('123',456);
> 
> ```



Rigidly\-typed database will convert the string '123' into an
integer 123 and the integer 456 into a string '456' prior to
doing the insert.




In order to maximize compatibility between SQLite and other database
engines, and so that the example above will work on SQLite as it does
on other SQL database engines,
SQLite supports the concept of "type affinity" on columns.
The type affinity of a column is the recommended type for data stored
in that column. The important idea here is that the type is recommended, not
required. Any column can still store any type of data.
It is just that some columns, given the choice, will prefer to use
one storage class over another. The preferred storage class for
a column is called its "affinity".



Each column in an SQLite 3 database is assigned one of the
following type affinities:


* TEXT
* NUMERIC
* INTEGER
* REAL
* BLOB


(Historical note: The "BLOB" type affinity used to be called "NONE".
But that term was easy to confuse with "no affinity" and so it was
renamed.)



A column with TEXT affinity stores all data using storage classes
NULL, TEXT or BLOB. If numerical data is inserted into a column with
TEXT affinity it is converted into text form before being stored.


A column with NUMERIC affinity may contain values using all five
storage classes. When text data is inserted into a NUMERIC column, the
storage class of the text is converted to INTEGER or REAL (in order of
preference) if the text is a well\-formed integer or real literal, respectively.
If the TEXT value is a well\-formed integer literal that is too large
to fit in a 64\-bit signed integer, it is converted to REAL.
For conversions between TEXT and REAL storage classes, only the first
15 significant decimal digits of the number are preserved.
If the TEXT value is not a well\-formed integer or real literal,
then the value is stored as TEXT.
For the purposes of this paragraph, hexadecimal integer
literals are not considered well\-formed and are stored as TEXT.
(This is done for historical compatibility with versions of SQLite
prior to [version 3\.8\.6](releaselog/3_8_6.html) 2014\-08\-15 where hexadecimal integer
literals were first introduced into SQLite.)
If a floating point value that can be represented exactly as an integer
is inserted into a column with NUMERIC affinity, the value is
converted into an integer.
No attempt is made to convert NULL or BLOB values.


A string might look like a floating\-point literal with
a decimal point and/or exponent notation but as long as
the value can be expressed as an integer, the NUMERIC affinity will convert
it into an integer. Hence, the string '3\.0e\+5' is stored in a
column with NUMERIC affinity as the integer 300000, not as the floating
point value 300000\.0\.


A column that uses INTEGER affinity behaves the same as a column
with NUMERIC affinity. The difference between INTEGER and NUMERIC affinity
is only evident in a [CAST expression](lang_expr.html#castexpr): The expression
"CAST(4\.0 AS INT)" returns an integer 4, whereas
"CAST(4\.0 AS NUMERIC)" leaves the value as a floating\-point 4\.0\.


A column with REAL affinity behaves like a column with NUMERIC
affinity except that it forces integer values into floating point
representation. (As an internal optimization, small floating point
values with no fractional component and stored in columns with REAL
affinity are written to disk as integers in order to take up less 
space and are automatically converted back into floating point as
the value is read out.
This optimization is completely invisible at the SQL level and can only
be detected by examining the raw bits of the database file.)


A column with affinity BLOB does not prefer one storage class over
another and no attempt is made to coerce data from one storage class into
another.



