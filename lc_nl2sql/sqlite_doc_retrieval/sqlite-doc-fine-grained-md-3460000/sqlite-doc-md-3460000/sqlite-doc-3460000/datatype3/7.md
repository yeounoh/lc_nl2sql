### 3\.1\.1\. Affinity Name Examples


The following table shows how many common datatype names from
more traditional SQL implementations are converted into affinities by the five rules of the
previous section. This table shows only a small subset of the
datatype names that SQLite will accept. Note that numeric arguments
in parentheses that following the type name (ex: "VARCHAR(255\)") are
ignored by SQLite \- SQLite does not impose any length restrictions
(other than the large global [SQLITE\_MAX\_LENGTH](limits.html#max_length) limit) on the length of
strings, BLOBs or numeric values.



> | Example Typenames From TheCREATE TABLE Statement  or CAST Expression | Resulting Affinity | Rule Used To Determine Affinity |
> | --- | --- | --- |
> | INT  INTEGER  TINYINT  SMALLINT  MEDIUMINT  BIGINT  UNSIGNED BIG INT  INT2  INT8 | INTEGER | 1 |
> | CHARACTER(20\)  VARCHAR(255\)  VARYING CHARACTER(255\)  NCHAR(55\)  NATIVE CHARACTER(70\)  NVARCHAR(100\)  TEXT  CLOB | TEXT | 2 |
> | BLOB *no datatype specified* | BLOB | 3 |
> | REAL  DOUBLE  DOUBLE PRECISION  FLOAT | REAL | 4 |
> | NUMERIC  DECIMAL(10,5\)  BOOLEAN  DATE  DATETIME | NUMERIC | 5 |


Note that a declared type of "FLOATING POINT" would give INTEGER
affinity, not REAL affinity, due to the "INT" at the end of "POINT".
And the declared type of "STRING" has an affinity of NUMERIC, not TEXT.




