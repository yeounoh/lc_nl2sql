## 4\.2\. Type Conversions Prior To Comparison


SQLite may attempt to convert values between the storage classes
INTEGER, REAL, and/or TEXT before performing a comparison.
Whether or not any conversions are attempted before the comparison takes
place depends on the type affinity of the operands.



To "apply affinity" means to convert an operand to a particular storage
class if and only if the conversion does not lose essential information.
Numeric values can always be converted into TEXT. TEXT values 
can be converted into numeric values if the text content is a well\-formed 
integer or real literal, but not a hexadecimal integer literal.
BLOB values are converted into TEXT values by simply interpreting
the binary BLOB content as a text string in the current database
encoding.



Affinity is applied to operands of a comparison operator prior to
the comparison according to the following rules in the order shown:


* If one operand has INTEGER, REAL or NUMERIC affinity
and the other operand has TEXT or BLOB or no affinity
then NUMERIC affinity is applied to other operand.
* If one operand has TEXT affinity and the other has no affinity,
then TEXT affinity is applied to the other operand.
* Otherwise, no affinity is applied and both operands are compared
as is.


The expression "a BETWEEN b AND c" is treated as two separate
binary comparisons "a \>\= b AND a \<\= c", even if that means
different affinities are applied to 'a' in each of the comparisons.
Datatype conversions in comparisons of the
form "x IN (SELECT y ...)" are handled as if
the comparison were really "x\=y".
The expression "a IN (x, y, z, ...)" is equivalent to "a \= \+x OR
a \= \+y OR a \= \+z OR ...". 
In other words, the values to the right of the IN operator (the "x", "y",
and "z" values in this example) are considered to have no affinity, 
even if they happen to be column values or CAST expressions. 



