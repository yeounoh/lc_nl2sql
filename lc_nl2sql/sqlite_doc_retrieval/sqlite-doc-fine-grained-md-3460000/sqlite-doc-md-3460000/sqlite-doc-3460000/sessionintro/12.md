## 3\.3\. Inspecting the Contents of a Changeset


 The example code below demonstrates the techniques used to iterate
through and extract the data related to all changes in a changeset. To
summarize:



1. The [sqlite3changeset\_start()](session/sqlite3changeset_start.html) API is called to create and
 initialize an iterator to iterate through the contents of a
 changeset. Initially, the iterator points to no element at all.
2. The first call to [sqlite3changeset\_next()](session/sqlite3changeset_next.html) on the iterator moves
 it to point to the first change in the changeset (or to EOF, if
 the changeset is completely empty). sqlite3changeset\_next() returns
 SQLITE\_ROW if it moves the iterator to point to a valid entry,
 SQLITE\_DONE if it moves the iterator to EOF, or an SQLite error
 code if an error occurs.
3. If the iterator points to a valid entry, the [sqlite3changeset\_op()](session/sqlite3changeset_op.html)
 API may be used to determine the type of change (INSERT, UPDATE or
 DELETE) that the iterator points to. Additionally, the same API
 can be used to obtain the name of the table the change applies to
 and its expected number of columns and primary key columns.
4. If the iterator points to a valid INSERT or UPDATE entry, the
 [sqlite3changeset\_new()](session/sqlite3changeset_new.html) API may be used to obtain the new.\* values
 within the change payload.
5. If the iterator points to a valid DELETE or UPDATE entry, the
 [sqlite3changeset\_old()](session/sqlite3changeset_old.html) API may be used to obtain the old.\* values
 within the change payload.
6. An iterator is deleted using a call to the
 [sqlite3changeset\_finalize()](session/sqlite3changeset_finalize.html) API. If an error occured while
 iterating, an SQLite error code is returned (even if the same error
 code has already been returned by sqlite3changeset\_next()). Or,
 if no error has occurred, SQLITE\_OK is returned.



```
/*
** Print the contents of the changeset to stdout.
*/
static int print_changeset(void *pChangeset, int nChangeset){
  int rc;
  sqlite3_changeset_iter *pIter = 0;

  /* Create an iterator to iterate through the changeset */
  rc = sqlite3changeset_start(&pIter, nChangeset, pChangeset);
  if( rc!=SQLITE_OK ) return rc;

  /* This loop runs once for each change in the changeset */
  while( SQLITE_ROW==sqlite3changeset_next(pIter) ){
    const char *zTab;           /* Table change applies to */
    int nCol;                   /* Number of columns in table zTab */
    int op;                     /* SQLITE_INSERT, UPDATE or DELETE */
    sqlite3_value *pVal;

    /* Print the type of operation and the table it is on */
    rc = sqlite3changeset_op(pIter, &zTab, &nCol, &op, 0);
    if( rc!=SQLITE_OK ) goto exit_print_changeset;
    printf("%s on table %s\n",
      op==SQLITE_INSERT?"INSERT" : op==SQLITE_UPDATE?"UPDATE" : "DELETE",
      zTab
    );

    /* If this is an UPDATE or DELETE, print the old.* values */
    if( op==SQLITE_UPDATE || op==SQLITE_DELETE ){
      printf("Old values:");
      for(i=0; i<nCol; i++){
        rc = sqlite3changeset_old(pIter, i, &pVal);
        if( rc!=SQLITE_OK ) goto exit_print_changeset;
        printf(" %s", pVal ? sqlite3_value_text(pVal) : "-");
      }
      printf("\n");
    }

    /* If this is an UPDATE or INSERT, print the new.* values */
    if( op==SQLITE_UPDATE || op==SQLITE_INSERT ){
      printf("New values:");
      for(i=0; i<nCol; i++){
        rc = sqlite3changeset_new(pIter, i, &pVal);
        if( rc!=SQLITE_OK ) goto exit_print_changeset;
        printf(" %s", pVal ? sqlite3_value_text(pVal) : "-");
      }
      printf("\n");
    }
  }

  /* Clean up the changeset and return an error code (or SQLITE_OK) */
 exit_print_changeset:
  rc2 = sqlite3changeset_finalize(pIter);
  if( rc==SQLITE_OK ) rc = rc2;
  return rc;
}

```

