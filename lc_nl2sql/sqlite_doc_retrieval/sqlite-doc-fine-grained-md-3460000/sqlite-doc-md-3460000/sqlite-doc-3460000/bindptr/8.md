### 3\.1\.1\. Pointer types are static strings



Pointer types are static strings, which ideally should be string literals
embedded directly in the SQLite API call, not parameters passed in from
other functions. Consideration was given to using integer values as
the pointer type, but static strings provides a much larger name space
which reduces the chance of accidental type\-name collisions between
unrelated extensions.




By "static string", we mean a zero\-terminated array of bytes that is
fixed and unchanging for the life of the program. In other words, the
pointer type string should be a string constant.
In contrast, a "dynamic string" is a zero\-terminated array of bytes
that is held in memory allocated
from the heap, and which must be freed to avoid a memory leak.
Do not use dynamic strings as the pointer type string.




Multiple commentators have expressed a desire to use dynamic strings
for the pointer type, and to have SQLite take ownership of the type strings
and to automatically free the type string
when it has finished using it. That design is rejected for the
following reasons:



1. The pointer type is not intended to be flexible and dynamic. The
pointer type is intended to be a design\-time constant. Applications
should not synthesize pointer type strings at run\-time. Providing
support for dynamic pointer type strings would lead developers
to misuse the pointer\-passing interfaces by creating run\-time
synthesized pointer type strings. Requiring the pointer type strings
to be static encourages developers to do the right thing by choosing
fixed pointer type names at design\-time and encoding those names
as constant strings.
2. All string values at the SQL level in SQLite are dynamic strings. 
Requiring type strings to be static makes it difficult to 
create an application\-defined SQL function that
can synthesize a pointer of an arbitrary type. We do not want users
to create such SQL functions, since such functions would compromise the
security of the system. Thus, the requirement to use static strings
helps to defend that the integrity of the pointer\-passing interfaces against
ill\-designed SQL functions. The static string requirement is not
a perfect defense, since a sophisticated programmer can code around
it, and a novice program can simply take the memory leak. But by
stating that the pointer type string must be static, we hope to encourage
developers who might otherwise use a dynamic string for the pointer type
to think more carefully about the problem and avoid introducing
security issues.
3. Having SQLite take ownership of the type strings would impose a performance
cost on all applications, even applications that do not use the 
pointer\-passing interfaces. SQLite passes values around as instances
of the [sqlite3\_value](c3ref/value.html) object. That object has a destructor, which because
of the fact that sqlite3\_value objects are used for nearly everything, is
invoked frequently. If the destructor needs to check to see if there is
a pointer type string that needs to be freed, that is a few extra CPU
cycles that need to be burned on each call to the destructor. Those
cycles add up. We would be willing to bear the cost of the extra CPU
cycles if pointer\-passing was a commonly used programming paradigm, but
pointer\-passing is rare, and so it seems unwise to impose a run\-time cost
on billions and billions of applications that do not use pointer passing
just for convenience of a few applications that do.



If you feel that you need dynamic pointer type strings in your application,
that is a strong indicator that you are misusing the pointer\-passing interface.
Your intended use may be unsafe.
Please rethink your design. Determine if you really need to be passing
pointers through SQL in the first place. Or perhaps find a different
mechanism other than the pointer\-passing interfaces described by this
article.



