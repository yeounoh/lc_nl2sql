# 5\. Summary


Key take\-aways from this essay:



1. The internet is an increasingly hostile place. These day, developers
should assume that attackers will find a way to execute arbitrary SQL 
in an application.
Applications should be designed to prevent the execution of arbitrary
SQL from escalating into a more severe exploit.
2. A few SQLite extensions benefit from passing pointers:



	* The [FTS3](fts3.html) MATCH operator passes pointers into [snippet()](fts3.html#snippet),
	 [offsets()](fts3.html#offsets), and [matchinfo()](fts3.html#matchinfo).
	* The [carray table\-valued function](carray.html) needs to accept a pointer to
	 an array of C\-language values from the application.
	* The [remember() extension](https://sqlite.org/src/file/ext/misc/remember.c)
	 needs a pointer to a C\-language integer variable in which to remember
	 the value it passes.
	* Applications need to receive a pointer to the "fts5\_api" object in order
	 to add extensions, such as custom tokenizers, to the [FTS5](fts5.html) extension.
3. Pointers should never be exchanged by encoding them as some other
SQL datatype, such as integers or BLOBs. Instead, use the interfaces
designed to facilitate secure pointer passing:
[sqlite3\_bind\_pointer()](c3ref/bind_blob.html), [sqlite3\_result\_pointer()](c3ref/result_blob.html), and
[sqlite3\_value\_pointer()](c3ref/value_blob.html).
4. The use of pointer\-passing is an advanced technique that should be used
infrequently and cautiously. Pointer\-passing should not be
used haphazardly or carelessly. Pointer\-passing is a sharp tool 
that can leave deep scars if misused.
5. The "pointer type" string which is the last parameter to each of the
pointer\-passing interfaces should be a distinct, application\-specific
string literal that appears directly in the API call. The pointer type
should not be a parameter passed in from a higher\-level function.


*This page last modified on [2022\-10\-07 10:23:26](https://sqlite.org/docsrc/honeypot) UTC* 


