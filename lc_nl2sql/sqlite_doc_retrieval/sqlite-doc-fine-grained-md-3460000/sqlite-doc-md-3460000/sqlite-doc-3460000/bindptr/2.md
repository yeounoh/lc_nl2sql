# 2\. A Brief History Of Pointer Passing In SQLite



It is sometimes convenient for SQLite extensions to
communicate non\-SQL values between subcomponents or between the extension
and the application. Some examples:



* In the [FTS3](fts3.html) extension, the 
[MATCH operator](fts3.html#full_text_index_queries) (which does the full\-text search)
needs to communicate details of matching entries 
to the [snippet()](fts3.html#snippet), [offsets()](fts3.html#offsets),
and [matchinfo()](fts3.html#matchinfo) functions so that those functions can convert the details
of the match into useful output.
* In order for an application to 
[add new extensions to FTS5](fts5.html#extending_fts5), such as new tokenizers, 
the application needs a pointer to the "fts5\_api" object.
* In the [CARRAY extension](carray.html), the application needs to tell the 
extension the
location of a C\-language array that contains the data for the table\-valued
function that the extension implements.



The traditional way of communicating this information was to transform a
C\-language pointer into a BLOB or a 64\-bit integer, then move that BLOB or
integer through SQLite using the usual interfaces like
[sqlite3\_bind\_blob()](c3ref/bind_blob.html), [sqlite3\_result\_blob()](c3ref/result_blob.html), [sqlite3\_value\_blob()](c3ref/value_blob.html) or
the integer equivalents.



