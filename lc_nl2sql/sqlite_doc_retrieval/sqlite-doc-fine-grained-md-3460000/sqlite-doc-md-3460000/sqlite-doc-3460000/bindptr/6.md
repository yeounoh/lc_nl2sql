# 3\. The New Pointer\-Passing Interfaces



Allowing extension components to pass private information to one another
securely and without introducing pointer leaks requires new interfaces:



* **[sqlite3\_bind\_pointer](c3ref/bind_blob.html)(S,I,P,T,D)** →
Bind pointer P of type T to the I\-th parameter of prepared statement S.
D is an optional destructor function for P.
* **[sqlite3\_result\_pointer](c3ref/result_blob.html)(C,P,T,D)** →
Return pointer P of type T as the argument of function C.
D is an optional destructor function for P.
* **[sqlite3\_value\_pointer](c3ref/value_blob.html)(V,T)** →
Return the pointer of type T associated with value V, or if V has no
associated pointer, or if the pointer on V is of a type different from
T, then return NULL.



To SQL, the values created by [sqlite3\_bind\_pointer()](c3ref/bind_blob.html) and 
[sqlite3\_result\_pointer()](c3ref/result_blob.html) are indistinguishable from NULL. An
SQL statement that tries to use the [hex()](lang_corefunc.html#hex) function to read the
value of a pointer will get an SQL NULL answer. The only way to
discover whether or not a value has an associated pointer is to
use the [sqlite3\_value\_pointer()](c3ref/value_blob.html) interface with the appropriate
type string T. 




Pointer values read by [sqlite3\_value\_pointer()](c3ref/value_blob.html)
cannot be generated by pure SQL. Hence, it is not possible for SQL to
forge pointers.




Pointer values generated by [sqlite3\_bind\_pointer()](c3ref/bind_blob.html) and
[sqlite3\_result\_pointer()](c3ref/result_blob.html) cannot be read by pure SQL.
Hence, it is not possible for SQL to leak the value of pointers.




In this way the new pointer\-passing interface seems to solve all of the
security problems associated with passing pointer values from one
extension to another in SQLite.




