# 8\. Use of WAL Without Shared\-Memory


Beginning in SQLite [version 3\.7\.4](releaselog/3_7_4.html) (2010\-12\-07\), 
WAL databases can be created, read, and
written even if shared memory is unavailable as long as the
[locking\_mode](pragma.html#pragma_locking_mode) is set to EXCLUSIVE before the first attempted access.
In other words, a process can interact with
a WAL database without using shared memory if that
process is guaranteed to be the only process accessing the database.
This feature allows WAL databases to be created, read, and written
by legacy [VFSes](vfs.html) that lack the "version 2" shared\-memory
methods xShmMap, xShmLock, xShmBarrier, and xShmUnmap on the
[sqlite3\_io\_methods](c3ref/io_methods.html) object.


If [EXCLUSIVE locking mode](pragma.html#pragma_locking_mode)
is set prior to the first WAL\-mode 
database access, then SQLite never attempts to call any of the
shared\-memory methods and hence no shared\-memory
wal\-index is ever created.
In that case, the database connection remains in EXCLUSIVE mode
as long as the journal mode is WAL; attempts to change the locking
mode using "PRAGMA locking\_mode\=NORMAL;" are no\-ops.
The only way to change out of EXCLUSIVE locking mode is to first
change out of WAL journal mode.


If NORMAL locking mode is in effect for the first WAL\-mode database
access, then the shared\-memory wal\-index is created. This means that the
underlying VFS must support the "version 2" shared\-memory.
If the VFS does not support shared\-memory methods, then the attempt to
open a database that is already in WAL mode, or the attempt convert a
database into WAL mode, will fail.
As long as exactly one connection is using a shared\-memory wal\-index, 
the locking mode can be changed freely between NORMAL and EXCLUSIVE. 
It is only when the shared\-memory wal\-index is omitted, when the locking 
mode is EXCLUSIVE prior to the first WAL\-mode database access, that the 
locking mode is stuck in EXCLUSIVE.



