# 6\. Avoiding Excessively Large WAL Files


In normal cases, new content is appended to the WAL file until the
WAL file accumulates about 1000 pages (and is thus about 4MB 
in size) at which point a checkpoint is automatically run and the WAL file
is recycled. The checkpoint does not normally truncate the WAL file
(unless the [journal\_size\_limit pragma](pragma.html#pragma_journal_size_limit) is set). Instead, it merely
causes SQLite to start overwriting the WAL file from the beginning.
This is done because it is normally faster to overwrite an existing file
than to append. When the last connection to a database closes, that
connection does one last checkpoint and then deletes the WAL and its
associated shared\-memory file, to clean up the disk.



So in the vast majority of cases, applications need not worry about
the WAL file at all. SQLite will automatically take care of it. But
it is possible to get SQLite into a state where the WAL file will grow
without bound, causing excess disk space usage and slow queries speeds.
The following bullets enumerate some of the ways that this can happen
and how to avoid them.



* **Disabling the automatic checkpoint mechanism.**
In its default configuration, SQLite will checkpoint the WAL file at the
conclusion of any transaction when the WAL file is more than 1000 pages
long. However, compile\-time and run\-time options exist that can disable
or defer this automatic checkpoint. If an application disables the
automatic checkpoint, then there is nothing to prevent the WAL file
from growing excessively.
* **Checkpoint starvation.**
A checkpoint is only able to run to completion, and reset the WAL file,
if there are no other database connections using the WAL file. If another
connection has a read transaction open,
then the checkpoint cannot reset the WAL file because
doing so might delete content out from under the reader.
The checkpoint will do as much work as it can without upsetting the
reader, but it cannot run to completion.
The checkpoint will start up again where it left off after the next
write transaction. This repeats until some checkpoint is able to complete.



However, if a database has many concurrent overlapping readers
and there is always at least one active reader, then
no checkpoints will be able to complete
and hence the WAL file will grow without bound.



This scenario can be avoided by ensuring that there are "reader gaps":
times when no processes are reading from the 
database and that checkpoints are attempted during those times.
In applications with many concurrent readers, one might also consider 
running manual checkpoints with the [SQLITE\_CHECKPOINT\_RESTART](c3ref/c_checkpoint_full.html) or
[SQLITE\_CHECKPOINT\_TRUNCATE](c3ref/c_checkpoint_full.html) option which will ensure that the checkpoint
runs to completion before returning. The disadvantage of using
[SQLITE\_CHECKPOINT\_RESTART](c3ref/c_checkpoint_full.html) and [SQLITE\_CHECKPOINT\_TRUNCATE](c3ref/c_checkpoint_full.html) is that
readers might block while the checkpoint is running.
* **Very large write transactions.**
A checkpoint can only complete when no other transactions are running, 
which means the WAL file cannot be reset in the middle of a write
transaction. So a large change to a large database
might result in a large WAL file. The WAL file will be checkpointed
once the write transaction completes (assuming there are no other readers
blocking it) but in the meantime, the file can grow very big.



As of SQLite [version 3\.11\.0](releaselog/3_11_0.html) (2016\-02\-15\), 
the WAL file for a single transaction
should be proportional in size to the transaction itself. Pages that
are changed by the transaction should only be written into the WAL file
once. However, with older versions of SQLite, the same page might be
written into the WAL file multiple times if the transaction grows larger
than the page cache.


