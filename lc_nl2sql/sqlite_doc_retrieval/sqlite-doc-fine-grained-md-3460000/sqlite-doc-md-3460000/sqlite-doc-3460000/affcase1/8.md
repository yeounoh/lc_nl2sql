## And So Forth...



In the previous sections, we have seen how moving from a key/value
store implemented as a ZIP archive to a simple SQLite database
with just three tables can add significant capabilities to an application
file format.
We could continue to enhance the schema with new tables, with indexes
added for performance, with triggers and views for programming convenience,
and constraints to enforce consistency of content even in the face of
programming errors. Further enhancement ideas include:
* Store an [automated undo/redo stack](undoredo.html) in a database table so that
 Undo could go back into prior edit sessions.
* Add [full text search](fts3.html#fts4) capabilities to the slide deck, or across
 multiple slide decks.
* Decompose the "settings.xml" file into an SQL table that
 is more easily viewed and edited by separate applications.
* Break out the "Presentor Notes" from each slide into a separate
 table, for easier access from third\-party applications and/or scripts.
* Enhance the presentation concept beyond the simple linear sequence of
 slides to allow for side\-tracks and excursions to be taken depending on
 how the audience is responding.



An SQLite database has a lot of capability, which
this essay has only begun to touch upon. But hopefully this quick glimpse
has convinced some readers that using an SQL database as an application
file format is worth a second look.


Some readers might resist using SQLite as an application
file format due to prior exposure to enterprise SQL databases and
the caveats and limitations of those other systems. 
For example, many enterprise database
engines advise against storing large strings or BLOBs in the database
and instead suggest that large strings and BLOBs be stored as separate
files and the filename stored in the database. But SQLite 
is not like that. Any column of an SQLite database can hold
a string or BLOB up to about a gigabyte in size. And for strings and
BLOBs of 100 kilobytes or less, 
[I/O performance is better](intern-v-extern-blob.html) than using separate
files.


Some readers might be reluctant to consider SQLite as an application
file format because they have been inculcated with the idea that all
SQL database schemas must be factored into third normal form and store
only small primitive data types such as strings and integers. Certainly
relational theory is important and designers should strive to understand
it. But, as demonstrated above, it is often quite acceptable to store
complex information as XML or JSON in text fields of a database.
Do what works, not what your database professor said you ought to do.

