## Third Improvement: Versioning



Once one is comfortable with the concept of storing each slide separately,
it is a small step to support versioning of the presentation. Consider
the following schema:


> ```
> 
> CREATE TABLE slide(
>   slideId INTEGER PRIMARY KEY,
>   derivedFrom INTEGER REFERENCES slide,
>   content TEXT     -- XML or JSON or whatever
> );
> CREATE TABLE version(
>   versionId INTEGER PRIMARY KEY,
>   priorVersion INTEGER REFERENCES version,
>   checkinTime DATETIME,   -- When this version was saved
>   comment TEXT,           -- Description of this version
>   manifest TEXT           -- List of integer slideIds
> );
> 
> ```



In this schema, instead of each slide having a page number that determines
its order within the presentation, each slide has a unique
integer identifier that is unrelated to where it occurs in sequence.
The order of slides in the presentation is determined by a list of
slideIds, stored as a text string in the MANIFEST column of the VERSION
table.
Since multiple entries are allowed in the VERSION table, that means that
multiple presentations can be stored in the same document.


On startup, the application first decides which version it
wants to display. Since the versionId will naturally increase in time
and one would normally want to see the latest version, an appropriate
query might be:


> ```
> 
> SELECT manifest, versionId FROM version ORDER BY versionId DESC LIMIT 1;
> 
> ```



Or perhaps the application would rather use the
most recent checkinTime:


> ```
> 
> SELECT manifest, versionId, max(checkinTime) FROM version;
> 
> ```



Using a single query such as the above, the application obtains a list
of the slideIds for all slides in the presentation. The application then
queries for the content of the first slide, and parses and displays that
content, as before.

(Aside: Yes, that second query above that uses "max(checkinTime)"
really does work and really does return a well\-defined answer in SQLite.
Such a query either returns an undefined answer or generates an error
in many other SQL database engines, but in SQLite it does what you would 
expect: it returns the manifest and versionId of the entry that has the
maximum checkinTime.)

When the user does a "File/Save", instead of overwriting the modified
slides, the application can now make new entries in the SLIDE table for
just those slides that have been added or altered. Then it creates a
new entry in the VERSION table containing the revised manifest.

The VERSION table shown above has columns to record a check\-in comment
(presumably supplied by the user) and the time and date at which the File/Save
action occurred. It also records the parent version to record the history
of changes. Perhaps the manifest could be stored as a delta from the
parent version, though typically the manifest will be small enough that
storing a delta might be more trouble than it is worth. The SLIDE table
also contains a derivedFrom column which could be used for delta encoding
if it is determined that saving the slide content as a delta from its
previous version is a worthwhile optimization.

So with this simple change, the ODP file now stores not just the most
recent edit to the presentation, but a history of all historic edits. The
user would normally want to see just the most recent edition of the
presentation, but if desired, the user can now go backwards in time to 
see historical versions of the same presentation.

Or, multiple presentations could be stored within the same document.

With such a schema, the application would no longer need to make
periodic backups of the unsaved changes to a separate file to avoid lost
work in the event of a crash. Instead, a special "pending" version could
be allocated and unsaved changes could be written into the pending version.
Because only changes would need to be written, not the entire document,
saving the pending changes would only involve writing a few kilobytes of
content, not multiple megabytes, and would take milliseconds instead of
seconds, and so it could be done frequently and silently in the background.
Then when a crash occurs and the user reboots, all (or almost all)
of their work is retained. If the user decides to discard unsaved changes, 
they simply go back to the previous version.


There are details to fill in here.
Perhaps a screen can be provided that displays a history changes
(perhaps with a graph) allowing the user to select which version they
want to view or edit. Perhaps some facility can be provided to merge
forks that might occur in the version history. And perhaps the
application should provide a means to purge old and unwanted versions.
The key point is that using an SQLite database to store the content,
rather than a ZIP archive, makes all of these features much, much easier
to implement, which increases the possibility that they will eventually
get implemented.

