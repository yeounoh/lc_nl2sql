## Second Improvement: Split content into smaller pieces



A pile\-of\-files encourages content to be stored in a few large chunks.
In the case of ODP, there are just four XML files that define the layout
off all slides in a presentation. An SQLite database allows storing
information in a few large chunks, but SQLite is also adept and efficient
at storing information in numerous smaller pieces.


So then, instead of storing all content for all slides in a single
oversized XML file ("content.xml"), suppose there was a separate table
for storing the content of each slide separately. The table schema
might look something like this:


> ```
> 
> CREATE TABLE slide(
>   pageNumber INTEGER,   -- The slide page number
>   slideContent TEXT     -- Slide content as XML or JSON
> );
> CREATE INDEX slide_pgnum ON slide(pageNumber); -- Optional
> 
> ```


The content of each slide could still be stored as compressed XML.
But now each page is stored separately. So when opening a new document,
the application could simply run:


> ```
> 
> SELECT slideContent FROM slide WHERE pageNumber=1;
> 
> ```


This query will quickly and efficiently return the content of the first
slide, which could then be speedily parsed and displayed to the user.
Only one page needs to be read and parsed in order render the first screen,
which means that the first screen appears much faster and
there is no longer a need for an annoying progress bar.

If the application wanted
to keep all content in memory, it could continue reading and parsing the
other pages using a background thread after drawing the first page. Or,
since reading from SQLite is so efficient, the application might 
instead choose to reduce its memory footprint and only keep a single
slide in memory at a time. Or maybe it keeps the current slide and the
next slide in memory, to facility rapid transitions to the next slide.


Notice that dividing up the content into smaller pieces using an SQLite
table gives flexibility to the implementation. The application can choose
to read all content into memory at startup. Or it can read just a
few pages into memory and keep the rest on disk. Or it can read just
single page into memory at a time. And different versions of the application
can make different choices without having to make any changes to the
file format. Such options are not available when all content is in
a single big XML file in a ZIP archive.


Splitting content into smaller pieces also helps File/Save operations
to go faster. Instead of having to write back the content of all pages
when doing a File/Save, the application only has to write back those
pages that have actually changed.


One minor downside of splitting content into smaller pieces is that
compression does not work as well on shorter texts and so the size of
the document might increase. But as the bulk of the document space 
is used to store images, a small reduction in the compression efficiency 
of the text content will hardly be noticeable, and is a small price 
to pay for an improved user experience.

