## Inserting Records Into The Database


We begin with a problem that can be solved using a VDBE program
that is only a few instructions long. Suppose we have an SQL
table that was created like this:



> ```
> 
> CREATE TABLE examp(one text, two int);
> 
> ```


In words, we have a database table named "examp" that has two
columns of data named "one" and "two". Now suppose we want to insert a single
record into this table. Like this:



> ```
> 
> INSERT INTO examp VALUES('Hello, World!',99);
> 
> ```


We can see the VDBE program that SQLite uses to implement this
INSERT using the **sqlite** command\-line utility. First start
up **sqlite** on a new, empty database, then create the table.
Next change the output format of **sqlite** to a form that
is designed to work with VDBE program dumps by entering the
".explain" command.
Finally, enter the \[INSERT] statement shown above, but precede the
\[INSERT] with the special keyword \[EXPLAIN]. The \[EXPLAIN] keyword
will cause **sqlite** to print the VDBE program rather than 
execute it. We have:



> $ **sqlite test\_database\_1**  
> 
> sqlite\> **CREATE TABLE examp(one text, two int);**  
> 
> sqlite\> **.explain**  
> 
> sqlite\> **EXPLAIN INSERT INTO examp VALUES('Hello, World!',99\);**  
> 
> addr  opcode        p1     p2     p3                                        
> 
> \-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-  
> 
> 0     Transaction   0      0                                           
> 
> 1     VerifyCookie  0      81                                          
> 
> 2     Transaction   1      0                                           
> 
> 3     Integer       0      0                                           
> 
> 4     OpenWrite     0      3      examp                                
> 
> 5     NewRecno      0      0                                           
> 
> 6     String        0      0      Hello, World!                        
> 
> 7     Integer       99     0      99                                   
> 
> 8     MakeRecord    2      0                                           
> 
> 9     PutIntKey     0      1                                           
> 
> 10    Close         0      0                                           
> 
> 11    Commit        0      0                                           
> 
> 12    Halt          0      0

As you can see above, our simple insert statement is
implemented in 12 instructions. The first 3 and last 2 instructions are 
a standard prologue and epilogue, so the real work is done in the middle 
7 instructions. There are no jumps, so the program executes once through 
from top to bottom. Let's now look at each instruction in detail.

> 0     Transaction   0      0                                           
> 
> 1     VerifyCookie  0      81                                          
> 
> 2     Transaction   1      0


The instruction [Transaction](opcode.html#Transaction) 
begins a transaction. The transaction ends when a Commit or Rollback 
opcode is encountered. P1 is the index of the database file on which 
the transaction is started. Index 0 is the main database file. A write 
lock is obtained on the database file when a transaction is started. 
No other process can read or write the file while the transaction is 
underway. Starting a transaction also creates a rollback journal. A 
transaction must be started before any changes can be made to the 
database.


The instruction [VerifyCookie](opcode.html#VerifyCookie)
checks cookie 0 (the database schema version) to make sure it is equal 
to P2 (the value obtained when the database schema was last read). 
P1 is the database number (0 for the main database). This is done to 
make sure the database schema hasn't been changed by another thread, in 
which case it has to be reread.


 The second [Transaction](opcode.html#Transaction) 
instruction begins a transaction and starts a rollback journal for 
database 1, the database used for temporary tables.



> 3     Integer       0      0                                      
> 
> 4     OpenWrite     0      3      examp


 The instruction [Integer](opcode.html#Integer) pushes 
the integer value P1 (0\) onto the stack. Here 0 is the number of the 
database to use in the following OpenWrite instruction. If P3 is not 
NULL then it is a string representation of the same integer. Afterwards 
the stack looks like this:



> | (integer) 0 |
> | --- |


 The instruction [OpenWrite](opcode.html#OpenWrite) opens 
a new read/write cursor with handle P1 (0 in this case) on table "examp", 
whose root page is P2 (3, in this database file). Cursor handles can be 
any non\-negative integer. But the VDBE allocates cursors in an array 
with the size of the array being one more than the largest cursor. So 
to conserve memory, it is best to use handles beginning with zero and 
working upward consecutively. Here P3 ("examp") is the name of the 
table being opened, but this is unused, and only generated to make the 
code easier to read. This instruction pops the database number to use 
(0, the main database) from the top of the stack, so afterwards the 
stack is empty again.



> 5     NewRecno      0      0


 The instruction [NewRecno](opcode.html#NewRecno) creates 
a new integer record number for the table pointed to by cursor P1\. The 
record number is one not currently used as a key in the table. The new 
record number is pushed onto the stack. Afterwards the stack looks like 
this:



> | (integer) new record key |
> | --- |


> 6     String        0      0      Hello, World!


 The instruction [String](opcode.html#String) pushes its 
P3 operand onto the stack. Afterwards the stack looks like this:



> | (string) "Hello, World!" |
> | --- |
> | (integer) new record key |


> 7     Integer       99     0      99


 The instruction [Integer](opcode.html#Integer) pushes 
its P1 operand (99\) onto the stack. Afterwards the stack looks like 
this:



> | (integer) 99 |
> | --- |
> | (string) "Hello, World!" |
> | (integer) new record key |


> 8     MakeRecord    2      0


 The instruction [MakeRecord](opcode.html#MakeRecord) pops 
the top P1 elements off the stack (2 in this case) and converts them into 
the binary format used for storing records in a database file. 
(See the [file format](fileformat.html) description for 
details.) The new record generated by the MakeRecord instruction is 
pushed back onto the stack. Afterwards the stack looks like this:




> | (record) "Hello, World!", 99 |
> | --- |
> | (integer) new record key |


> 9     PutIntKey     0      1


 The instruction [PutIntKey](opcode.html#PutIntKey) uses 
the top 2 stack entries to write an entry into the table pointed to by 
cursor P1\. A new entry is created if it doesn't already exist or the 
data for an existing entry is overwritten. The record data is the top 
stack entry, and the key is the next entry down. The stack is popped 
twice by this instruction. Because operand P2 is 1 the row change count 
is incremented and the rowid is stored for subsequent return by the 
sqlite\_last\_insert\_rowid() function. If P2 is 0 the row change count is 
unmodified. This instruction is where the insert actually occurs.



> 10    Close         0      0


 The instruction [Close](opcode.html#Close) closes a 
cursor previously opened as P1 (0, the only open cursor). If P1 is not 
currently open, this instruction is a no\-op.



> 11    Commit        0      0


 The instruction [Commit](opcode.html#Commit) causes all 
modifications to the database that have been made since the last 
Transaction to actually take effect. No additional modifications are 
allowed until another transaction is started. The Commit instruction 
deletes the journal file and releases the write lock on the database. 
A read lock continues to be held if there are still cursors open.



> 12    Halt          0      0


 The instruction [Halt](opcode.html#Halt) causes the VDBE 
engine to exit immediately. All open cursors, Lists, Sorts, etc are 
closed automatically. P1 is the result code returned by sqlite\_exec(). 
For a normal halt, this should be SQLITE\_OK (0\). For errors, it can be 
some other value. The operand P2 is only used when there is an error. 
There is an implied "Halt 0 0 0" instruction at the end of every 
program, which the VDBE appends when it prepares a program to run.



