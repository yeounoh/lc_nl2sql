## Simple Queries


At this point, you should understand the basics of how the VDBE
writes to a database. Now let's look at how it does queries.
We will use the following simple SELECT statement as our example:



> ```
> 
> SELECT * FROM examp;
> 
> ```


The VDBE program generated for this SQL statement is as follows:



> sqlite\> **EXPLAIN SELECT \* FROM examp;**  
> 
> addr  opcode        p1     p2     p3                                   
> 
> \-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-  
> 
> 0     ColumnName    0      0      one                                  
> 
> 1     ColumnName    1      0      two                                  
> 
> 2     Integer       0      0                                           
> 
> 3     OpenRead      0      3      examp                                
> 
> 4     VerifyCookie  0      81                                          
> 
> 5     Rewind        0      10                                          
> 
> 6     Column        0      0                                           
> 
> 7     Column        0      1                                           
> 
> 8     Callback      2      0                                           
> 
> 9     Next          0      6                                           
> 
> 10    Close         0      0                                           
> 
> 11    Halt          0      0


Before we begin looking at this problem, let's briefly review
how queries work in SQLite so that we will know what we are trying
to accomplish. For each row in the result of a query,
SQLite will invoke a callback function with the following
prototype:



> ```
> 
> int Callback(void *pUserData, int nColumn, char *azData[], char *azColumnName[]);
> 
> ```


The SQLite library supplies the VDBE with a pointer to the callback function
and the **pUserData** pointer. (Both the callback and the user data were
originally passed in as arguments to the **sqlite\_exec()** API function.)
The job of the VDBE is to
come up with values for **nColumn**, **azData\[]**, 
and **azColumnName\[]**.
**nColumn** is the number of columns in the results, of course.
**azColumnName\[]** is an array of strings where each string is the name
of one of the result columns. **azData\[]** is an array of strings holding
the actual data.



> 0     ColumnName    0      0      one                                  
> 
> 1     ColumnName    1      0      two


The first two instructions in the VDBE program for our query are
concerned with setting up values for **azColumn**.
The [ColumnName](opcode.html#ColumnName) instructions tell 
the VDBE what values to fill in for each element of the **azColumnName\[]** 
array. Every query will begin with one ColumnName instruction for each 
column in the result, and there will be a matching Column instruction for 
each one later in the query.




> 2     Integer       0      0                                           
> 
> 3     OpenRead      0      3      examp                                
> 
> 4     VerifyCookie  0      81


Instructions 2 and 3 open a read cursor on the database table that is 
to be queried. This works the same as the OpenWrite instruction in the 
INSERT example except that the cursor is opened for reading this time 
instead of for writing. Instruction 4 verifies the database schema as 
in the INSERT example.



> 5     Rewind        0      10


 The [Rewind](opcode.html#Rewind) instruction initializes 
a loop that iterates over the "examp" table. It rewinds the cursor P1 
to the first entry in its table. This is required by the Column and 
Next instructions, which use the cursor to iterate through the table. 
If the table is empty, then jump to P2 (10\), which is the instruction just 
past the loop. If the table is not empty, fall through to the following 
instruction at 6, which is the beginning of the loop body.



> 6     Column        0      0                                           
> 
> 7     Column        0      1                                           
> 
> 8     Callback      2      0


 The instructions 6 through 8 form the body of the loop that will 
execute once for each record in the database file. 

The [Column](opcode.html#Column) instructions at addresses 6 
and 7 each take the P2\-th column from the P1\-th cursor and push it onto 
the stack. In this example, the first Column instruction is pushing the 
value for the column "one" onto the stack and the second Column 
instruction is pushing the value for column "two". 

The [Callback](opcode.html#Callback) instruction at address 8 
invokes the callback() function. The P1 operand to Callback becomes the 
value for **nColumn**. The Callback instruction pops P1 values from
the stack and uses them to fill the **azData\[]** array.



> 9     Next          0      6


The instruction at address 9 implements the branching part of the 
loop. Together with the Rewind at address 5 it forms the loop logic. 
This is a key concept that you should pay close attention to. 
The [Next](opcode.html#Next) instruction advances the cursor 
P1 to the next record. If the cursor advance was successful, then jump 
immediately to P2 (6, the beginning of the loop body). If the cursor 
was at the end, then fall through to the following instruction, which 
ends the loop.



> 10    Close         0      0                                           
> 
> 11    Halt          0      0


The Close instruction at the end of the program closes the
cursor that points into the table "examp". It is not really necessary
to call Close here since all cursors will be automatically closed
by the VDBE when the program halts. But we needed an instruction
for the Rewind to jump to so we might as well go ahead and have that
instruction do something useful.
The Halt instruction ends the VDBE program.


Note that the program for this SELECT query didn't contain the 
Transaction and Commit instructions used in the INSERT example. Because 
the SELECT is a read operation that doesn't alter the database, it 
doesn't require a transaction.



