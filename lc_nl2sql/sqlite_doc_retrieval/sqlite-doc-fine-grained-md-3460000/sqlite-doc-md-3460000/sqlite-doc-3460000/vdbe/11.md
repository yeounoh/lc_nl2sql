## Joins


In a join, two or more tables are combined to generate a single
result. The result table consists of every possible combination
of rows from the tables being joined. The easiest and most natural
way to implement this is with nested loops.


Recall the query template discussed above where there was a
single loop that searched through every record of the table.
In a join we have basically the same thing except that there
are nested loops. For example, to join two tables, the query
template might look something like this:



1. Initialize the **azColumnName\[]** array for the callback.
2. Open two cursors, one to each of the two tables being queried.
3. For each record in the first table, do:
	1. For each record in the second table do:
		1. If the WHERE clause evaluates to FALSE, then skip the steps that
		 follow and continue to the next record.
		2. Compute all columns for the current row of the result.
		3. Invoke the callback function for the current row of the result.- Close both cursors.





This template will work, but it is likely to be slow since we
are now dealing with an O(N2) loop. But it often works
out that the WHERE clause can be factored into terms and that one or
more of those terms will involve only columns in the first table.
When this happens, we can factor part of the WHERE clause test out of
the inner loop and gain a lot of efficiency. So a better template
would be something like this:



1. Initialize the **azColumnName\[]** array for the callback.
2. Open two cursors, one to each of the two tables being queried.
3. For each record in the first table, do:
	1. Evaluate terms of the WHERE clause that only involve columns from
	 the first table. If any term is false (meaning that the whole
	 WHERE clause must be false) then skip the rest of this loop and
	 continue to the next record.
	2. For each record in the second table do:
		1. If the WHERE clause evaluates to FALSE, then skip the steps that
		 follow and continue to the next record.
		2. Compute all columns for the current row of the result.
		3. Invoke the callback function for the current row of the result.- Close both cursors.





Additional speed\-up can occur if an index can be used to speed
the search of either or the two loops.


SQLite always constructs the loops in the same order as the
tables appear in the FROM clause of the SELECT statement. The
left\-most table becomes the outer loop and the right\-most table
becomes the inner loop. It is possible, in theory, to reorder
the loops in some circumstances to speed the evaluation of the
join. But SQLite does not attempt this optimization.


You can see how SQLite constructs nested loops in the following
example:



> ```
> 
> CREATE TABLE examp2(three int, four int);
> SELECT * FROM examp, examp2 WHERE two<50 AND four==two;
> 
> ```



> addr  opcode        p1     p2     p3                                        
> 
> \-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-  
> 
> 0     ColumnName    0      0      examp.one                            
> 
> 1     ColumnName    1      0      examp.two                            
> 
> 2     ColumnName    2      0      examp2\.three                         
> 
> 3     ColumnName    3      0      examp2\.four                          
> 
> 4     Integer       0      0                                           
> 
> 5     OpenRead      0      3      examp                                
> 
> 6     VerifyCookie  0      909                                              
> 
> 7     Integer       0      0                                           
> 
> 8     OpenRead      1      5      examp2                               
> 
> 9     Rewind        0      24                                               
> 
> 10    Column        0      1                                           
> 
> 11    Integer       50     0      50                                   
> 
> 12    Ge            1      23                                               
> 
> 13    Rewind        1      23                                               
> 
> 14    Column        1      1                                           
> 
> 15    Column        0      1                                           
> 
> 16    Ne            1      22                                          
> 
> 17    Column        0      0                                           
> 
> 18    Column        0      1                                           
> 
> 19    Column        1      0                                           
> 
> 20    Column        1      1                                           
> 
> 21    Callback      4      0                                           
> 
> 22    Next          1      14                                               
> 
> 23    Next          0      10                                          
> 
> 24    Close         0      0                                           
> 
> 25    Close         1      0                                           
> 
> 26    Halt          0      0


The outer loop over table examp is implement by instructions
7 through 23\. The inner loop is instructions 13 through 22\.
Notice that the "two\<50" term of the WHERE expression involves
only columns from the first table and can be factored out of
the inner loop. SQLite does this and implements the "two\<50"
test in instructions 10 through 12\. The "four\=\=two" test is
implement by instructions 14 through 16 in the inner loop.


SQLite does not impose any arbitrary limits on the tables in
a join. It also allows a table to be joined with itself.


