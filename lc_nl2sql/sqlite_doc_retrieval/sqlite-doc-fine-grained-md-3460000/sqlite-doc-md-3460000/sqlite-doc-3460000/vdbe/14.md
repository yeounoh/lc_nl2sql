## Using SELECT Statements As Terms In An Expression


The very name "Structured Query Language" tells us that SQL should
support nested queries. And, in fact, two different kinds of nesting
are supported. Any SELECT statement that returns a single\-row, single\-column
result can be used as a term in an expression of another SELECT statement.
And, a SELECT statement that returns a single\-column, multi\-row result
can be used as the right\-hand operand of the IN and NOT IN operators.
We will begin this section with an example of the first kind of nesting,
where a single\-row, single\-column SELECT is used as a term in an expression
of another SELECT. Here is our example:



> ```
> 
> SELECT * FROM examp
> WHERE two!=(SELECT three FROM examp2
>             WHERE four=5);
> 
> ```


The way SQLite deals with this is to first run the inner SELECT
(the one against examp2\) and store its result in a private memory
cell. SQLite then substitutes the value of this private memory
cell for the inner SELECT when it evaluates the outer SELECT.
The code looks like this:



> addr  opcode        p1     p2     p3                                        
> 
> \-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-  
> 
> 0     String        0      0                                           
> 
> 1     MemStore      0      1                                           
> 
> 2     Integer       0      0                                           
> 
> 3     OpenRead      1      5      examp2                               
> 
> 4     VerifyCookie  0      909                                              
> 
> 5     Rewind        1      13                                               
> 
> 6     Column        1      1                                           
> 
> 7     Integer       5      0      5                                    
> 
> 8     Ne            1      12                                          
> 
> 9     Column        1      0                                           
> 
> 10    MemStore      0      1                                           
> 
> 11    Goto          0      13                                               
> 
> 12    Next          1      6                                                
> 
> 13    Close         1      0                                           
> 
> 14    ColumnName    0      0      one                                  
> 
> 15    ColumnName    1      0      two                                  
> 
> 16    Integer       0      0                                           
> 
> 17    OpenRead      0      3      examp                                
> 
> 18    Rewind        0      26                                               
> 
> 19    Column        0      1                                           
> 
> 20    MemLoad       0      0                                           
> 
> 21    Eq            1      25                                               
> 
> 22    Column        0      0                                           
> 
> 23    Column        0      1                                           
> 
> 24    Callback      2      0                                           
> 
> 25    Next          0      19                                               
> 
> 26    Close         0      0                                           
> 
> 27    Halt          0      0


The private memory cell is initialized to NULL by the first
two instructions. Instructions 2 through 13 implement the inner
SELECT statement against the examp2 table. Notice that instead of
sending the result to a callback or storing the result on a sorter,
the result of the query is pushed into the memory cell by instruction
10 and the loop is abandoned by the jump at instruction 11\. 
The jump at instruction at 11 is vestigial and never executes.


The outer SELECT is implemented by instructions 14 through 25\.
In particular, the WHERE clause that contains the nested select
is implemented by instructions 19 through 21\. You can see that
the result of the inner select is loaded onto the stack by instruction
20 and used by the conditional jump at 21\.


When the result of a sub\-select is a scalar, a single private memory
cell can be used, as shown in the previous
example. But when the result of a sub\-select is a vector, such
as when the sub\-select is the right\-hand operand of IN or NOT IN,
a different approach is needed. In this case, 
the result of the sub\-select is
stored in a transient table and the contents of that table
are tested using the Found or NotFound operators. Consider this
example:



> ```
> 
> SELECT * FROM examp
> WHERE two IN (SELECT three FROM examp2);
> 
> ```


The code generated to implement this last query is as follows:



> addr  opcode        p1     p2     p3                                        
> 
> \-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-  
> 
> 0     OpenTemp      1      1                                           
> 
> 1     Integer       0      0                                           
> 
> 2     OpenRead      2      5      examp2                               
> 
> 3     VerifyCookie  0      909                                              
> 
> 4     Rewind        2      10                                          
> 
> 5     Column        2      0                                           
> 
> 6     IsNull        \-1     9                                                
> 
> 7     String        0      0                                           
> 
> 8     PutStrKey     1      0                                           
> 
> 9     Next          2      5                                                
> 
> 10    Close         2      0                                           
> 
> 11    ColumnName    0      0      one                                  
> 
> 12    ColumnName    1      0      two                                  
> 
> 13    Integer       0      0                                           
> 
> 14    OpenRead      0      3      examp                                
> 
> 15    Rewind        0      25                                               
> 
> 16    Column        0      1                                           
> 
> 17    NotNull       \-1     20                                          
> 
> 18    Pop           1      0                                           
> 
> 19    Goto          0      24                                               
> 
> 20    NotFound      1      24                                               
> 
> 21    Column        0      0                                           
> 
> 22    Column        0      1                                           
> 
> 23    Callback      2      0                                           
> 
> 24    Next          0      16                                               
> 
> 25    Close         0      0                                           
> 
> 26    Halt          0      0


The transient table in which the results of the inner SELECT are
stored is created by the [OpenTemp](opcode.html#OpenTemp) 
instruction at 0\. This opcode is used for tables that exist for the 
duration of a single SQL statement only. The transient cursor is always 
opened read/write even if the main database is read\-only. The transient 
table is deleted automatically when the cursor is closed. The P2 value 
of 1 means the cursor points to a BTree index, which has no data but can 
have an arbitrary key.


The inner SELECT statement is implemented by instructions 1 through 10\.
All this code does is make an entry in the temporary table for each
row of the examp2 table with a non\-NULL value for the "three" column. 
The key for each temporary table entry is the "three" column of examp2 
and the data is an empty string since it is never used.


The outer SELECT is implemented by instructions 11 through 25\. In
particular, the WHERE clause containing the IN operator is implemented
by instructions at 16, 17, and 20\. Instruction 16 pushes the value of
the "two" column for the current row onto the stack and instruction 17
checks to see that it is non\-NULL. If this is successful, execution 
jumps to 20, where it tests to see if top of the stack matches any key 
in the temporary table. The rest of the code is the same as what has 
been shown before.


