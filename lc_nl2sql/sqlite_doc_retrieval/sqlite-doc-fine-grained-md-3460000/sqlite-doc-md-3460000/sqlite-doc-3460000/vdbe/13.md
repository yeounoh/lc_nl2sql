## Aggregate Functions And The GROUP BY and HAVING Clauses


To compute aggregate functions, the VDBE implements a special 
data structure and instructions for controlling that data structure.
The data structure is an unordered set of buckets, where each bucket
has a key and one or more memory locations. Within the query
loop, the GROUP BY clause is used to construct a key and the bucket
with that key is brought into focus. A new bucket is created with
the key if one did not previously exist. Once the bucket is in
focus, the memory locations of the bucket are used to accumulate
the values of the various aggregate functions. After the query
loop terminates, each bucket is visited once to generate a
single row of the results.


An example will help to clarify this concept. Consider the
following query:



> ```
> 
> SELECT three, min(three+four)+avg(four) 
> FROM examp2
> GROUP BY three;
> 
> ```


The VDBE code generated for this query is as follows:



> addr  opcode        p1     p2     p3                                        
> 
> \-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-  
> 
> 0     ColumnName    0      0      three                                
> 
> 1     ColumnName    1      0      min(three\+four)\+avg(four)            
> 
> 2     AggReset      0      3                                                
> 
> 3     AggInit       0      1      ptr(0x7903a0\)                        
> 
> 4     AggInit       0      2      ptr(0x790700\)                        
> 
> 5     Integer       0      0                                           
> 
> 6     OpenRead      0      5      examp2                               
> 
> 7     VerifyCookie  0      909                                              
> 
> 8     Rewind        0      23                                               
> 
> 9     Column        0      0                                           
> 
> 10    MakeKey       1      0      n                                    
> 
> 11    AggFocus      0      14                                               
> 
> 12    Column        0      0                                           
> 
> 13    AggSet        0      0                                           
> 
> 14    Column        0      0                                           
> 
> 15    Column        0      1                                           
> 
> 16    Add           0      0                                           
> 
> 17    Integer       1      0                                           
> 
> 18    AggFunc       0      1      ptr(0x7903a0\)                        
> 
> 19    Column        0      1                                           
> 
> 20    Integer       2      0                                           
> 
> 21    AggFunc       0      1      ptr(0x790700\)                        
> 
> 22    Next          0      9                                                
> 
> 23    Close         0      0                                                
> 
> 24    AggNext       0      31                                          
> 
> 25    AggGet        0      0                                                
> 
> 26    AggGet        0      1                                                
> 
> 27    AggGet        0      2                                           
> 
> 28    Add           0      0                                           
> 
> 29    Callback      2      0                                           
> 
> 30    Goto          0      24                                               
> 
> 31    Noop          0      0                                           
> 
> 32    Halt          0      0


The first instruction of interest is the 
[AggReset](opcode.html#AggReset) at 2\.
The AggReset instruction initializes the set of buckets to be the
empty set and specifies the number of memory slots available in each
bucket as P2\. In this example, each bucket will hold 3 memory slots.
It is not obvious, but if you look closely at the rest of the program
you can figure out what each of these slots is intended for.



> | Memory Slot | Intended Use Of This Memory Slot |
> | --- | --- |
> | 0 | The "three" column \-\- the key to the bucket |
> | 1 | The minimum "three\+four" value |
> | 2 | The sum of all "four" values. This is used to compute   "avg(four)". |


The query loop is implemented by instructions 8 through 22\.
The aggregate key specified by the GROUP BY clause is computed
by instructions 9 and 10\. Instruction 11 causes the appropriate
bucket to come into focus. If a bucket with the given key does
not already exists, a new bucket is created and control falls
through to instructions 12 and 13 which initialize the bucket.
If the bucket does already exist, then a jump is made to instruction
14\. The values of aggregate functions are updated by the instructions
between 11 and 21\. Instructions 14 through 18 update memory
slot 1 to hold the next value "min(three\+four)". Then the sum of the 
"four" column is updated by instructions 19 through 21\.


After the query loop is finished, the table "examp2" is closed at
instruction 23 so that its lock will be released and it can be
used by other threads or processes. The next step is to loop
over all aggregate buckets and output one row of the result for
each bucket. This is done by the loop at instructions 24
through 30\. The AggNext instruction at 24 brings the next bucket
into focus, or jumps to the end of the loop if all buckets have
been examined already. The 3 columns of the result are fetched from 
the aggregator bucket in order at instructions 25 through 27\.
Finally, the callback is invoked at instruction 29\.


In summary then, any query with aggregate functions is implemented
by two loops. The first loop scans the input table and computes
aggregate information into buckets and the second loop scans through
all the buckets to compute the final result.


The realization that an aggregate query is really two consecutive
loops makes it much easier to understand the difference between
a WHERE clause and a HAVING clause in SQL query statement. The
WHERE clause is a restriction on the first loop and the HAVING
clause is a restriction on the second loop. You can see this
by adding both a WHERE and a HAVING clause to our example query:



> ```
> 
> SELECT three, min(three+four)+avg(four) 
> FROM examp2
> WHERE three>four
> GROUP BY three
> HAVING avg(four)<10;
> 
> ```



> addr  opcode        p1     p2     p3                                        
> 
> \-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-  
> 
> 0     ColumnName    0      0      three                                
> 
> 1     ColumnName    1      0      min(three\+four)\+avg(four)            
> 
> 2     AggReset      0      3                                                
> 
> 3     AggInit       0      1      ptr(0x7903a0\)                        
> 
> 4     AggInit       0      2      ptr(0x790700\)                        
> 
> 5     Integer       0      0                                           
> 
> 6     OpenRead      0      5      examp2                               
> 
> 7     VerifyCookie  0      909                                              
> 
> 8     Rewind        0      26                                               
> 
> 9     Column        0      0                                           
> 
> 10    Column        0      1                                           
> 
> 11    Le            1      25                                               
> 
> 12    Column        0      0                                           
> 
> 13    MakeKey       1      0      n                                    
> 
> 14    AggFocus      0      17                                               
> 
> 15    Column        0      0                                           
> 
> 16    AggSet        0      0                                           
> 
> 17    Column        0      0                                           
> 
> 18    Column        0      1                                           
> 
> 19    Add           0      0                                           
> 
> 20    Integer       1      0                                           
> 
> 21    AggFunc       0      1      ptr(0x7903a0\)                        
> 
> 22    Column        0      1                                           
> 
> 23    Integer       2      0                                           
> 
> 24    AggFunc       0      1      ptr(0x790700\)                        
> 
> 25    Next          0      9                                                
> 
> 26    Close         0      0                                                
> 
> 27    AggNext       0      37                                               
> 
> 28    AggGet        0      2                                           
> 
> 29    Integer       10     0      10                                   
> 
> 30    Ge            1      27                                               
> 
> 31    AggGet        0      0                                           
> 
> 32    AggGet        0      1                                           
> 
> 33    AggGet        0      2                                           
> 
> 34    Add           0      0                                           
> 
> 35    Callback      2      0                                           
> 
> 36    Goto          0      27                                               
> 
> 37    Noop          0      0                                           
> 
> 38    Halt          0      0


The code generated in this last example is the same as the
previous except for the addition of two conditional jumps used
to implement the extra WHERE and HAVING clauses. The WHERE
clause is implemented by instructions 9 through 11 in the query
loop. The HAVING clause is implemented by instruction 28 through
30 in the output loop.


