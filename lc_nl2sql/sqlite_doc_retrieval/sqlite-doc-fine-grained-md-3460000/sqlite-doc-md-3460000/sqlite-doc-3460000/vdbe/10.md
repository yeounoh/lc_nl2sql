## Using Indexes To Speed Searching


In the example queries above, every row of the table being
queried must be loaded off of the disk and examined, even if only
a small percentage of the rows end up in the result. This can
take a long time on a big table. To speed things up, SQLite
can use an index.


An SQLite file associates a key with some data. For an SQLite
table, the database file is set up so that the key is an integer
and the data is the information for one row of the table.
Indices in SQLite reverse this arrangement. The index key
is (some of) the information being stored and the index data 
is an integer.
To access a table row that has some particular
content, we first look up the content in the index table to find
its integer index, then we use that integer to look up the
complete record in the table.


Note that SQLite uses b\-trees, which are a sorted data structure, 
so indices can be used when the WHERE clause of the SELECT statement
contains tests for equality or inequality. Queries like the following 
can use an index if it is available:



> ```
> 
> SELECT * FROM examp WHERE two==50;
> SELECT * FROM examp WHERE two<50;
> SELECT * FROM examp WHERE two IN (50, 100);
> 
> ```


If there exists an index that maps the "two" column of the "examp"
table into integers, then SQLite will use that index to find the integer
keys of all rows in examp that have a value of 50 for column two, or 
all rows that are less than 50, etc.
But the following queries cannot use the index:



> ```
> 
> SELECT * FROM examp WHERE two%50 == 10;
> SELECT * FROM examp WHERE two&127 == 3;
> 
> ```


Note that the SQLite parser will not always generate code to use an 
index, even if it is possible to do so. The following queries will not 
currently use the index:



> ```
> 
> SELECT * FROM examp WHERE two+10 == 50;
> SELECT * FROM examp WHERE two==50 OR two==100;
> 
> ```


To understand better how indices work, lets first look at how
they are created. Let's go ahead and put an index on the two
column of the examp table. We have:



> ```
> 
> CREATE INDEX examp_idx1 ON examp(two);
> 
> ```


The VDBE code generated by the above statement looks like the
following:



> addr  opcode        p1     p2     p3                                        
> 
> \-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-  
> 
> 0     Transaction   1      0                                           
> 
> 1     Transaction   0      0                                           
> 
> 2     VerifyCookie  0      178                                              
> 
> 3     Integer       0      0                                           
> 
> 4     OpenWrite     0      2                                           
> 
> 5     NewRecno      0      0                                           
> 
> 6     String        0      0      index                                
> 
> 7     String        0      0      examp\_idx1                           
> 
> 8     String        0      0      examp                                
> 
> 9     CreateIndex   0      0      ptr(0x791380\)                        
> 
> 10    Dup           0      0                                           
> 
> 11    Integer       0      0                                           
> 
> 12    OpenWrite     1      0                                           
> 
> 13    String        0      0      CREATE INDEX examp\_idx1 ON examp(tw  
> 
> 14    MakeRecord    5      0                                           
> 
> 15    PutIntKey     0      0                                           
> 
> 16    Integer       0      0                                           
> 
> 17    OpenRead      2      3      examp                                
> 
> 18    Rewind        2      24                                               
> 
> 19    Recno         2      0                                           
> 
> 20    Column        2      1                                           
> 
> 21    MakeIdxKey    1      0      n                                    
> 
> 22    IdxPut        1      0      indexed columns are not unique       
> 
> 23    Next          2      19                                               
> 
> 24    Close         2      0                                           
> 
> 25    Close         1      0                                           
> 
> 26    Integer       333    0                                           
> 
> 27    SetCookie     0      0                                           
> 
> 28    Close         0      0                                           
> 
> 29    Commit        0      0                                           
> 
> 30    Halt          0      0


Remember that every table (except sqlite\_master) and every named
index has an entry in the sqlite\_master table. Since we are creating
a new index, we have to add a new entry to sqlite\_master. This is
handled by instructions 3 through 15\. Adding an entry to sqlite\_master
works just like any other INSERT statement so we will not say any more
about it here. In this example, we want to focus on populating the
new index with valid data, which happens on instructions 16 through 
23\.



> 16    Integer       0      0                                           
> 
> 17    OpenRead      2      3      examp


The first thing that happens is that we open the table being
indexed for reading. In order to construct an index for a table,
we have to know what is in that table. The index has already been 
opened for writing using cursor 0 by instructions 3 and 4\.



> 18    Rewind        2      24                                               
> 
> 19    Recno         2      0                                           
> 
> 20    Column        2      1                                           
> 
> 21    MakeIdxKey    1      0      n                                    
> 
> 22    IdxPut        1      0      indexed columns are not unique       
> 
> 23    Next          2      19


Instructions 18 through 23 implement a loop over every row of the 
table being indexed. For each table row, we first extract the integer 
key for that row using Recno in instruction 19, then get the value of 
the "two" column using Column in instruction 20\. 
The [MakeIdxKey](opcode.html#MakeIdxKey) instruction at 21 
converts data from the "two" column (which is on the top of the stack) 
into a valid index key. For an index on a single column, this is 
basically a no\-op. But if the P1 operand to MakeIdxKey had been 
greater than one multiple entries would have been popped from the stack 
and converted into a single index key. 
The [IdxPut](opcode.html#IdxPut) instruction at 22 is what 
actually creates the index entry. IdxPut pops two elements from the 
stack. The top of the stack is used as a key to fetch an entry from the 
index table. Then the integer which was second on stack is added to the 
set of integers for that index and the new record is written back to the 
database file. Note
that the same index entry can store multiple integers if there
are two or more table entries with the same value for the two
column.



Now let's look at how this index will be used. Consider the
following query:



> ```
> 
> SELECT * FROM examp WHERE two==50;
> 
> ```


SQLite generates the following VDBE code to handle this query:



> addr  opcode        p1     p2     p3                                        
> 
> \-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-  
> 
> 0     ColumnName    0      0      one                                  
> 
> 1     ColumnName    1      0      two                                  
> 
> 2     Integer       0      0                                           
> 
> 3     OpenRead      0      3      examp                                
> 
> 4     VerifyCookie  0      256                                              
> 
> 5     Integer       0      0                                           
> 
> 6     OpenRead      1      4      examp\_idx1                           
> 
> 7     Integer       50     0      50                              
> 
> 8     MakeKey       1      0      n                                    
> 
> 9     MemStore      0      0                                           
> 
> 10    MoveTo        1      19                                               
> 
> 11    MemLoad       0      0                                           
> 
> 12    IdxGT         1      19                                               
> 
> 13    IdxRecno      1      0                                           
> 
> 14    MoveTo        0      0                                           
> 
> 15    Column        0      0                                           
> 
> 16    Column        0      1                                           
> 
> 17    Callback      2      0                                           
> 
> 18    Next          1      11                                          
> 
> 19    Close         0      0                                           
> 
> 20    Close         1      0                                           
> 
> 21    Halt          0      0


The SELECT begins in a familiar fashion. First the column
names are initialized and the table being queried is opened.
Things become different beginning with instructions 5 and 6 where
the index file is also opened. Instructions 7 and 8 make
a key with the value of 50\. 
The [MemStore](opcode.html#MemStore) instruction at 9 stores 
the index key in VDBE memory location 0\. The VDBE memory is used to 
avoid having to fetch a value from deep in the stack, which can be done,
but makes the program harder to generate. The following instruction 
[MoveTo](opcode.html#MoveTo) at address 10 pops the key off 
the stack and moves the index cursor to the first row of the index with 
that key. This initializes the cursor for use in the following loop.


Instructions 11 through 18 implement a loop over all index records 
with the key that was fetched by instruction 8\. All of the index 
records with this key will be contiguous in the index table, so we walk 
through them and fetch the corresponding table key from the index. 
This table key is then used to move the cursor to that row in the table. 
The rest of the loop is the same as the loop for the non\-indexed SELECT 
query.


The loop begins with the [MemLoad](opcode.html#MemLoad) 
instruction at 11 which pushes a copy of the index key back onto the 
stack. The instruction [IdxGT](opcode.html#IdxGT) at 12 
compares the key to the key in the current index record pointed to by 
cursor P1\. If the index key at the current cursor location is greater 
than the index we are looking for, then jump out of the loop.


The instruction [IdxRecno](opcode.html#IdxRecno) at 13 
pushes onto the stack the table record number from the index. The 
following MoveTo pops it and moves the table cursor to that row. The 
next 3 instructions select the column data the same way as in the non\-
indexed case. The Column instructions fetch the column data and the 
callback function is invoked. The final Next instruction advances the 
index cursor, not the table cursor, to the next row, and then branches 
back to the start of the loop if there are any index records left.


Since the index is used to look up values in the table,
it is important that the index and table be kept consistent.
Now that there is an index on the examp table, we will have
to update that index whenever data is inserted, deleted, or
changed in the examp table. Remember the first example above
where we were able to insert a new row into the "examp" table using
12 VDBE instructions. Now that this table is indexed, 19
instructions are required. The SQL statement is this:



> ```
> 
> INSERT INTO examp VALUES('Hello, World!',99);
> 
> ```


And the generated code looks like this:



> addr  opcode        p1     p2     p3                                        
> 
> \-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-  
> 
> 0     Transaction   1      0                                           
> 
> 1     Transaction   0      0                                           
> 
> 2     VerifyCookie  0      256                                              
> 
> 3     Integer       0      0                                           
> 
> 4     OpenWrite     0      3      examp                                
> 
> 5     Integer       0      0                                           
> 
> 6     OpenWrite     1      4      examp\_idx1                           
> 
> 7     NewRecno      0      0                                           
> 
> 8     String        0      0      Hello, World!                        
> 
> 9     Integer       99     0      99                                   
> 
> 10    Dup           2      1                                           
> 
> 11    Dup           1      1                                           
> 
> 12    MakeIdxKey    1      0      n                                    
> 
> 13    IdxPut        1      0                                           
> 
> 14    MakeRecord    2      0                                           
> 
> 15    PutIntKey     0      1                                           
> 
> 16    Close         0      0                                           
> 
> 17    Close         1      0                                           
> 
> 18    Commit        0      0                                           
> 
> 19    Halt          0      0


At this point, you should understand the VDBE well enough to
figure out on your own how the above program works. So we will
not discuss it further in this text.


