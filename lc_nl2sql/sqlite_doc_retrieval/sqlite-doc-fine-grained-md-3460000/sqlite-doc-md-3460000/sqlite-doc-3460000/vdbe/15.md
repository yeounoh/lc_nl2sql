## Compound SELECT Statements


SQLite also allows two or more SELECT statements to be joined as
peers using operators UNION, UNION ALL, INTERSECT, and EXCEPT. These
compound select statements are implemented using transient tables.
The implementation is slightly different for each operator, but the
basic ideas are the same. For an example we will use the EXCEPT
operator.



> ```
> 
> SELECT two FROM examp
> EXCEPT
> SELECT four FROM examp2;
> 
> ```


The result of this last example should be every unique value
of the "two" column in the examp table, except any value that is
in the "four" column of examp2 is removed. The code to implement
this query is as follows:



> addr  opcode        p1     p2     p3                                        
> 
> \-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-  
> 
> 0     OpenTemp      0      1                                           
> 
> 1     KeyAsData     0      1                                                
> 
> 2     Integer       0      0                                           
> 
> 3     OpenRead      1      3      examp                                
> 
> 4     VerifyCookie  0      909                                              
> 
> 5     Rewind        1      11                                          
> 
> 6     Column        1      1                                           
> 
> 7     MakeRecord    1      0                                           
> 
> 8     String        0      0                                           
> 
> 9     PutStrKey     0      0                                           
> 
> 10    Next          1      6                                                
> 
> 11    Close         1      0                                           
> 
> 12    Integer       0      0                                           
> 
> 13    OpenRead      2      5      examp2                               
> 
> 14    Rewind        2      20                                          
> 
> 15    Column        2      1                                           
> 
> 16    MakeRecord    1      0                                           
> 
> 17    NotFound      0      19                                               
> 
> 18    Delete        0      0                                           
> 
> 19    Next          2      15                                               
> 
> 20    Close         2      0                                           
> 
> 21    ColumnName    0      0      four                                 
> 
> 22    Rewind        0      26                                               
> 
> 23    Column        0      0                                           
> 
> 24    Callback      1      0                                           
> 
> 25    Next          0      23                                               
> 
> 26    Close         0      0                                           
> 
> 27    Halt          0      0


The transient table in which the result is built is created by
instruction 0\. Three loops then follow. The loop at instructions
5 through 10 implements the first SELECT statement. The second
SELECT statement is implemented by the loop at instructions 14 through
19\. Finally, a loop at instructions 22 through 25 reads the transient
table and invokes the callback once for each row in the result.


Instruction 1 is of particular importance in this example. Normally,
the Column instruction extracts the value of a column from a larger
record in the data of an SQLite file entry. Instruction 1 sets a flag on
the transient table so that Column will instead treat the key of the
SQLite file entry as if it were data and extract column information from
the key.


Here is what is going to happen: The first SELECT statement
will construct rows of the result and save each row as the key of
an entry in the transient table. The data for each entry in the
transient table is a never used so we fill it in with an empty string.
The second SELECT statement also constructs rows, but the rows
constructed by the second SELECT are removed from the transient table.
That is why we want the rows to be stored in the key of the SQLite file
instead of in the data \-\- so they can be easily located and deleted.


Let's look more closely at what is happening here. The first
SELECT is implemented by the loop at instructions 5 through 10\.
Instruction 5 initializes the loop by rewinding its cursor.
Instruction 6 extracts the value of the "two" column from "examp"
and instruction 7 converts this into a row. Instruction 8 pushes
an empty string onto the stack. Finally, instruction 9 writes the
row into the temporary table. But remember, the PutStrKey opcode uses
the top of the stack as the record data and the next on stack as the
key. For an INSERT statement, the row generated by the
MakeRecord opcode is the record data and the record key is an integer
created by the NewRecno opcode. But here the roles are reversed and
the row created by MakeRecord is the record key and the record data is
just an empty string.


The second SELECT is implemented by instructions 14 through 19\.
Instruction 14 initializes the loop by rewinding its cursor.
A new result row is created from the "four" column of table "examp2"
by instructions 15 and 16\. But instead of using PutStrKey to write this
new row into the temporary table, we instead call Delete to remove
it from the temporary table if it exists.


The result of the compound select is sent to the callback routine
by the loop at instructions 22 through 25\. There is nothing new
or remarkable about this loop, except for the fact that the Column 
instruction at 23 will be extracting a column out of the record key
rather than the record data.


