## UPDATE And DELETE Statements


The UPDATE and DELETE statements are coded using a template
that is very similar to the SELECT statement template. The main
difference, of course, is that the end action is to modify the
database rather than invoke a callback function. Because it modifies 
the database it will also use transactions. Let's begin
by looking at a DELETE statement:



> ```
> 
> DELETE FROM examp WHERE two<50;
> 
> ```


This DELETE statement will remove every record from the "examp"
table where the "two" column is less than 50\.
The code generated to do this is as follows:



> addr  opcode        p1     p2     p3                                        
> 
> \-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-  
> 
> 0     Transaction   1      0  
> 
> 1     Transaction   0      0  
> 
> 2     VerifyCookie  0      178  
> 
> 3     Integer       0      0  
> 
> 4     OpenRead      0      3      examp  
> 
> 5     Rewind        0      12  
> 
> 6     Column        0      1  
> 
> 7     Integer       50     0      50  
> 
> 8     Ge            1      11  
> 
> 9     Recno         0      0  
> 
> 10    ListWrite     0      0  
> 
> 11    Next          0      6  
> 
> 12    Close         0      0  
> 
> 13    ListRewind    0      0  
> 
> 14    Integer       0      0  
> 
> 15    OpenWrite     0      3  
> 
> 16    ListRead      0      20  
> 
> 17    NotExists     0      19  
> 
> 18    Delete        0      1  
> 
> 19    Goto          0      16  
> 
> 20    ListReset     0      0  
> 
> 21    Close         0      0  
> 
> 22    Commit        0      0  
> 
> 23    Halt          0      0


Here is what the program must do. First it has to locate all of
the records in the table "examp" that are to be deleted. This is
done using a loop very much like the loop used in the SELECT examples
above. Once all records have been located, then we can go back through
and delete them one by one. Note that we cannot delete each record
as soon as we find it. We have to locate all records first, then
go back and delete them. This is because the SQLite database
backend might change the scan order after a delete operation.
And if the scan
order changes in the middle of the scan, some records might be
visited more than once and other records might not be visited at all.


So the implementation of DELETE is really in two loops. The first loop 
(instructions 5 through 11\) locates the records that are to be deleted 
and saves their keys onto a temporary list, and the second loop 
(instructions 16 through 19\) uses the key list to delete the records one 
by one. 



> 0     Transaction   1      0  
> 
> 1     Transaction   0      0  
> 
> 2     VerifyCookie  0      178  
> 
> 3     Integer       0      0  
> 
> 4     OpenRead      0      3      examp


Instructions 0 though 4 are as in the INSERT example. They start 
transactions for the main and temporary databases, verify the database 
schema for the main database, and open a read cursor on the table 
"examp". Notice that the cursor is opened for reading, not writing. At 
this stage of the program we are only going to be scanning the table, 
not changing it. We will reopen the same table for writing later, at 
instruction 15\.



> 5     Rewind        0      12


As in the SELECT example, the [Rewind](opcode.html#Rewind) 
instruction rewinds the cursor to the beginning of the table, readying 
it for use in the loop body.



> 6     Column        0      1  
> 
> 7     Integer       50     0      50  
> 
> 8     Ge            1      11


The WHERE clause is implemented by instructions 6 through 8\.
The job of the where clause is to skip the ListWrite if the WHERE
condition is false. To this end, it jumps ahead to the Next instruction
if the "two" column (extracted by the Column instruction) is
greater than or equal to 50\.


As before, the Column instruction uses cursor P1 and pushes the data 
record in column P2 (1, column "two") onto the stack. The Integer 
instruction pushes the value 50 onto the top of the stack. After these 
two instructions the stack looks like:



> | (integer) 50 |
> | --- |
> | (record) current record for column "two" |


The [Ge](opcode.html#Ge) operator compares the top two 
elements on the stack, pops them, and then branches based on the result 
of the comparison. If the second element is \>\= the top element, then 
jump to address P2 (the Next instruction at the end of the loop). 
Because P1 is true, if either operand is NULL (and thus the result is 
NULL) then take the jump. If we don't jump, just advance to the next 
instruction.



> 9     Recno         0      0  
> 
> 10    ListWrite     0      0


The [Recno](opcode.html#Recno) instruction pushes onto the 
stack an integer which is the first 4 bytes of the key to the current 
entry in a sequential scan of the table pointed to by cursor P1\.
The [ListWrite](opcode.html#ListWrite) instruction writes the 
integer on the top of the stack into a temporary storage list and pops 
the top element. This is the important work of this loop, to store the 
keys of the records to be deleted so we can delete them in the second 
loop. After this ListWrite instruction the stack is empty again.



> 11    Next          0      6  
> 
> 12    Close         0      0


 The Next instruction increments the cursor to point to the next 
element in the table pointed to by cursor P0, and if it was successful 
branches to P2 (6, the beginning of the loop body). The Close 
instruction closes cursor P1\. It doesn't affect the temporary storage 
list because it isn't associated with cursor P1; it is instead a global 
working list (which can be saved with ListPush).



> 13    ListRewind    0      0


 The [ListRewind](opcode.html#ListRewind) instruction 
rewinds the temporary storage list to the beginning. This prepares it 
for use in the second loop.



> 14    Integer       0      0  
> 
> 15    OpenWrite     0      3


 As in the INSERT example, we push the database number P1 (0, the main 
database) onto the stack and use OpenWrite to open the cursor P1 on table 
P2 (base page 3, "examp") for modification.



> 16    ListRead      0      20  
> 
> 17    NotExists     0      19  
> 
> 18    Delete        0      1  
> 
> 19    Goto          0      16


This loop does the actual deleting. It is organized differently from 
the one in the UPDATE example. The ListRead instruction plays the role 
that the Next did in the INSERT loop, but because it jumps to P2 on 
failure, and Next jumps on success, we put it at the start of the loop 
instead of the end. This means that we have to put a Goto at the end of 
the loop to jump back to the loop test at the beginning. So this 
loop has the form of a C while(){...} loop, while the loop in the INSERT 
example had the form of a do{...}while() loop. The Delete instruction 
fills the role that the callback function did in the preceding examples.



The [ListRead](opcode.html#ListRead) instruction reads an 
element from the temporary storage list and pushes it onto the stack. 
If this was successful, it continues to the next instruction. If this 
fails because the list is empty, it branches to P2, which is the 
instruction just after the loop. Afterwards the stack looks like:



> | (integer) key for current record |
> | --- |


Notice the similarity between the ListRead and Next instructions. 
Both operations work according to this rule:




> Push the next "thing" onto the stack and fall through OR jump to P2, 
> depending on whether or not there is a next "thing" to push.


One difference between Next and ListRead is their idea of a "thing". 
The "things" for the Next instruction are records in a database file. 
"Things" for ListRead are integer keys in a list. Another difference 
is whether to jump or fall through if there is no next "thing". In this 
case, Next falls through, and ListRead jumps. Later on, we will see 
other looping instructions (NextIdx and SortNext) that operate using the 
same principle.


The [NotExists](opcode.html#NotExists) instruction pops 
the top stack element and uses it as an integer key. If a record with 
that key does not exist in table P1, then jump to P2\. If a record does 
exist, then fall through to the next instruction. In this case P2 takes 
us to the Goto at the end of the loop, which jumps back to the ListRead 
at the beginning. This could have been coded to have P2 be 16, the 
ListRead at the start of the loop, but the SQLite parser which generated 
this code didn't make that optimization.


The [Delete](opcode.html#Delete) does the work of this 
loop; it pops an integer key off the stack (placed there by the 
preceding ListRead) and deletes the record of cursor P1 that has that key. 
Because P2 is true, the row change counter is incremented.


The [Goto](opcode.html#Goto) jumps back to the beginning 
of the loop. This is the end of the loop.



> 20    ListReset     0      0  
> 
> 21    Close         0      0  
> 
> 22    Commit        0      0  
> 
> 23    Halt          0      0


This block of instruction cleans up the VDBE program. Three of these 
instructions aren't really required, but are generated by the SQLite 
parser from its code templates, which are designed to handle more 
complicated cases.


The [ListReset](opcode.html#ListReset) instruction empties 
the temporary storage list. This list is emptied automatically when the 
VDBE program terminates, so it isn't necessary in this case. The Close 
instruction closes the cursor P1\. Again, this is done by the VDBE 
engine when it is finished running this program. The Commit ends the 
current transaction successfully, and causes all changes that occurred 
in this transaction to be saved to the database. The final Halt is also 
unnecessary, since it is added to every VDBE program when it is 
prepared to run.


UPDATE statements work very much like DELETE statements except
that instead of deleting the record they replace it with a new one.
Consider this example:




> ```
> 
> UPDATE examp SET one= '(' || one || ')' WHERE two < 50;
> 
> ```


Instead of deleting records where the "two" column is less than
50, this statement just puts the "one" column in parentheses
The VDBE program to implement this statement follows:



> addr  opcode        p1     p2     p3                                        
> 
> \-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-  
> 
> 0     Transaction   1      0                                           
> 
> 1     Transaction   0      0                                           
> 
> 2     VerifyCookie  0      178                                              
> 
> 3     Integer       0      0                                           
> 
> 4     OpenRead      0      3      examp                                
> 
> 5     Rewind        0      12                                          
> 
> 6     Column        0      1                                           
> 
> 7     Integer       50     0      50                                   
> 
> 8     Ge            1      11                                          
> 
> 9     Recno         0      0                                           
> 
> 10    ListWrite     0      0                                           
> 
> 11    Next          0      6                                                
> 
> 12    Close         0      0                                           
> 
> 13    Integer       0      0                                           
> 
> 14    OpenWrite     0      3                                                
> 
> 15    ListRewind    0      0                                           
> 
> 16    ListRead      0      28                                               
> 
> 17    Dup           0      0                                           
> 
> 18    NotExists     0      16                                               
> 
> 19    String        0      0      (                                    
> 
> 20    Column        0      0                                           
> 
> 21    Concat        2      0                                           
> 
> 22    String        0      0      )                                    
> 
> 23    Concat        2      0                                           
> 
> 24    Column        0      1                                           
> 
> 25    MakeRecord    2      0                                           
> 
> 26    PutIntKey     0      1                                           
> 
> 27    Goto          0      16                                               
> 
> 28    ListReset     0      0                                           
> 
> 29    Close         0      0                                           
> 
> 30    Commit        0      0                                           
> 
> 31    Halt          0      0


This program is essentially the same as the DELETE program except 
that the body of the second loop has been replace by a sequence of 
instructions (at addresses 17 through 26\) that update the record rather 
than delete it. Most of this instruction sequence should already be 
familiar to you, but there are a couple of minor twists so we will go 
over it briefly. Also note that the order of some of the instructions 
before and after the 2nd loop has changed. This is just the way the 
SQLite parser chose to output the code using a different template.


As we enter the interior of the second loop (at instruction 17\)
the stack contains a single integer which is the key of the
record we want to modify. We are going to need to use this
key twice: once to fetch the old value of the record and
a second time to write back the revised record. So the first instruction
is a Dup to make a duplicate of the key on the top of the stack. The
Dup instruction will duplicate any element of the stack, not just the top
element. You specify which element to duplication using the
P1 operand. When P1 is 0, the top of the stack is duplicated.
When P1 is 1, the next element down on the stack duplication.
And so forth.


After duplicating the key, the next instruction, NotExists,
pops the stack once and uses the value popped as a key to
check the existence of a record in the database file. If there is no record 
for this key, it jumps back to the ListRead to get another key.


Instructions 19 through 25 construct a new database record
that will be used to replace the existing record. This is
the same kind of code that we saw 
in the description of INSERT and will not be described further.
After instruction 25 executes, the stack looks like this:



> | (record) new data record |
> | --- |
> | (integer) key |


The PutIntKey instruction (also described
during the discussion about INSERT) writes an entry into the
database file whose data is the top of the stack and whose key
is the next on the stack, and then pops the stack twice. The
PutIntKey instruction will overwrite the data of an existing record
with the same key, which is what we want here. Overwriting was not
an issue with INSERT because with INSERT the key was generated
by the NewRecno instruction which is guaranteed to provide a key
that has not been used before.


