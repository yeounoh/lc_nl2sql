## A Slightly More Complex Query


The key points of the previous example were the use of the Callback
instruction to invoke the callback function, and the use of the Next
instruction to implement a loop over all records of the database file.
This example attempts to drive home those ideas by demonstrating a
slightly more complex query that involves more columns of
output, some of which are computed values, and a WHERE clause that
limits which records actually make it to the callback function.
Consider this query:



> ```
> 
> SELECT one, two, one || two AS 'both'
> FROM examp
> WHERE one LIKE 'H%'
> 
> ```


This query is perhaps a bit contrived, but it does serve to
illustrate our points. The result will have three column with
names "one", "two", and "both". The first two columns are direct
copies of the two columns in the table and the third result
column is a string formed by concatenating the first and
second columns of the table.
Finally, the
WHERE clause says that we will only chose rows for the 
results where the "one" column begins with an "H".
Here is what the VDBE program looks like for this query:



> addr  opcode        p1     p2     p3                                        
> 
> \-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-  
> 
> 0     ColumnName    0      0      one  
> 
> 1     ColumnName    1      0      two  
> 
> 2     ColumnName    2      0      both  
> 
> 3     Integer       0      0  
> 
> 4     OpenRead      0      3      examp  
> 
> 5     VerifyCookie  0      81  
> 
> 6     Rewind        0      18  
> 
> 7     String        0      0      H%                                        
> 
> 8     Column        0      0  
> 
> 9     Function      2      0      ptr(0x7f1ac0\)  
> 
> 10    IfNot         1      17  
> 
> 11    Column        0      0  
> 
> 12    Column        0      1  
> 
> 13    Column        0      0  
> 
> 14    Column        0      1  
> 
> 15    Concat        2      0  
> 
> 16    Callback      3      0  
> 
> 17    Next          0      7  
> 
> 18    Close         0      0  
> 
> 19    Halt          0      0


Except for the WHERE clause, the structure of the program for
this example is very much like the prior example, just with an
extra column. There are now 3 columns, instead of 2 as before,
and there are three ColumnName instructions.
A cursor is opened using the OpenRead instruction, just like in the
prior example. The Rewind instruction at address 6 and the
Next at address 17 form a loop over all records of the table. 
The Close instruction at the end is there to give the
Rewind instruction something to jump to when it is done. All of
this is just like in the first query demonstration.


The Callback instruction in this example has to generate
data for three result columns instead of two, but is otherwise
the same as in the first query. When the Callback instruction
is invoked, the left\-most column of the result should be
the lowest in the stack and the right\-most result column should
be the top of the stack. We can see the stack being set up 
this way at addresses 11 through 15\. The Column instructions at
11 and 12 push the values for the first two columns in the result.
The two Column instructions at 13 and 14 pull in the values needed
to compute the third result column and the Concat instruction at
15 joins them together into a single entry on the stack.


The only thing that is really new about the current example
is the WHERE clause which is implemented by instructions at
addresses 7 through 10\. Instructions at address 7 and 8 push
onto the stack the value of the "one" column from the table
and the literal string "H%". 
The [Function](opcode.html#Function) instruction at address 9 
pops these two values from the stack and pushes the result of the LIKE() 
function back onto the stack. 
The [IfNot](opcode.html#IfNot) instruction pops the top stack 
value and causes an immediate jump forward to the Next instruction if the 
top value was false (*not* not like the literal string "H%"). 
Taking this jump effectively skips the callback, which is the whole point
of the WHERE clause. If the result
of the comparison is true, the jump is not taken and control
falls through to the Callback instruction below.


Notice how the LIKE operator is implemented. It is a user\-defined 
function in SQLite, so the address of its function definition is 
specified in P3\. The operand P1 is the number of function arguments for 
it to take from the stack. In this case the LIKE() function takes 2 
arguments. The arguments are taken off the stack in reverse order 
(right\-to\-left), so the pattern to match is the top stack element, and 
the next element is the data to compare. The return value is pushed 
onto the stack.



