## 3\.5\. Other Example VFSes



The following are other VFS implementations available in the public
SQLite source tree:



* [appendvfs.c](https://www.sqlite.org/src/file/ext/misc/appendvfs.c) \-
This VFS allows an SQLite database to be appended to the end of some
other file. This can be used, for example, to append an SQLite database
onto the end of an executable such that, when run, it can easily
locate the appended database. The [command\-line shell](cli.html) will use this
VFS if launched with the \-\-append option, and its .archive command
will use it given the \-\-append flag.
* [test\_demovfs.c](https://www.sqlite.org/src/doc/trunk/src/test_demovfs.c) \- 
This file implements a very simple VFS named "demo" that uses POSIX 
functions such as
open(), read(), write(), fsync(), close(), fsync(), sleep(), time(),
and so forth. This VFS only works on unix systems. But it is not
intended as a replacement for the standard "unix" VFS used by default
on unix platforms. The "demo" VFS is deliberately kept very simple
so that it can be used as a learning aid or as template for building
other VFSes or for porting SQLite to new operating systems.
* [test\_quota.c](https://www.sqlite.org/src/doc/trunk/src/test_quota.c) \- 
This file implements a shim called "quota" that enforces cumulative
file size limits on a collection of database files. An auxiliary
interface is used to define "quota groups". A quota group is a
set of files (database files, journals, and temporary files) whose
names all match a [GLOB](lang_expr.html#glob) pattern. The sum of the sizes of all files
in each quota group is tracked, and if that sum exceeds a threshold
defined for the quota group, a callback function is invoked. That
callback can either increase the threshold or cause the operation
that would have exceeded the quota to fail with an 
[SQLITE\_FULL](rescode.html#full) error. One of the uses of this shim is used to enforce 
resource limits on application databases in Firefox.
* [test\_multiplex.c](https://www.sqlite.org/src/doc/trunk/src/test_multiplex.c) \- 
This file implements a shim that allows database files to exceed the
maximum file size of the underlying filesystem. This shim presents
an interface to the upper six layers of SQLite that makes it look like
very large files are being used, when in reality each such large file
is split up into many smaller files on the underlying system.
This shim has been used, for example, to allow databases to grow
larger than 2 gibibytes on FAT16 filesystems.
* [test\_onefile.c](https://www.sqlite.org/src/doc/trunk/src/test_onefile.c) \- 
This file implements a demonstration VFS named "fs" that shows how SQLite 
can be used on an embedded device that lacks a filesystem. Content is
written directly to the underlying media. A VFS derived from this
demonstration code could be used by a gadget with a limited amount of
flash memory to make SQLite behave as the filesystem for the flash memory
on the device.
* [test\_journal.c](https://www.sqlite.org/src/doc/trunk/src/test_journal.c) \- 
This file implements a shim used during SQLite testing that verifies that
the database and rollback journal are written in the correct order and
are "synced" at appropriate times in order to guarantee that the database
can recover from a power loss or hard reset at any time. The shim
checks several invariants on the operation of databases and rollback
journals and raises exceptions if any of those invariants are violated.
These invariants, in turn, assure that the database is always recoverable.
Running a large suite of test cases using this shim provides added
assurance that SQLite databases will not be damaged by unexpected
power failures or device resets.
* [test\_vfs.c](https://www.sqlite.org/src/doc/trunk/src/test_vfs.c) \- 
This file implements a shim that can be used to simulate filesystem faults.
This shim is used during testing to verify that SQLite responses sanely
to hardware malfunctions or to other error conditions such as running out
of filesystem space that are difficult to test on a real system.



There are other VFS implementations both in the core SQLite source code
library and in available extensions. The list above is not meant to be
exhaustive but merely representative of the kinds of features that can
be realized using the VFS interface.



