## 4\.6\. The Detail Option


 For each term in a document, the FTS index maintained by FTS5
stores the rowid of the document, the column number of the column that contains
the term and the offset of the term within the column value. The "detail"
option may be used to omit some of this information. This reduces the space
that the index consumes within the database file, but also reduces the
capability and efficiency of the system.



 The detail option may be set to "full" (the default value), "column" or
"none". For example:




```
-- The following two lines are equivalent (because the default value
-- of "detail" is "full". 
CREATE VIRTUAL TABLE ft1 USING fts5(a, b, c);
CREATE VIRTUAL TABLE ft1 USING fts5(a, b, c, detail=full);

CREATE VIRTUAL TABLE ft2 USING fts5(a, b, c, detail=column);
CREATE VIRTUAL TABLE ft3 USING fts5(a, b, c, detail=none);

```

If the detail option is set to **column**, then for each term the FTS
index records the rowid and column number only, omitting the term offset
information. This results in the following restrictions:



* NEAR queries are not available.
* Phrase queries are not available.
* Assuming the table is not also a
 [contentless table](fts5.html#contentless_tables), the
 [xInstCount](#xInstCount), [xInst](#xInst),
 [xPhraseFirst](#xPhraseFirst) and [xPhraseNext](#xPhraseNext)
 are slower than usual. This is because instead of reading the required data
 directly from the FTS index they have to load and tokenize the document text
 on demand.
* If the table is also a contentless table, the xInstCount, xInst,
 xPhraseFirst and xPhraseNext APIs behave as if the current row contains no
 phrase matches at all (i.e. xInstCount() returns 0\).


If the detail option is set to **none**, then for each term the FTS
index records just the rowid is stored. Both column and offset information
are omitted. As well as the restrictions itemized above for detail\=column
mode, this imposes the following extra limitations:



* Column filter queries are not available.
* Assuming the table is not also a contentless table, the
 [xPhraseFirstColumn](#xPhraseFirstColumn) and
 [xPhraseNextColumn](#xPhraseNextColumn) are slower than usual.
* If the table is also a contentless table, the xPhraseFirstColumn and
 xPhraseNextColumn APIs behave as if the current row contains no phrase
 matches at all (i.e. xPhraseFirstColumn() sets the iterator to EOF).


 In one test that indexed a large set of emails (1636 MiB on disk), the FTS
index was 743 MiB on disk with detail\=full, 340 MiB with detail\=column and 134
MiB with detail\=none.




