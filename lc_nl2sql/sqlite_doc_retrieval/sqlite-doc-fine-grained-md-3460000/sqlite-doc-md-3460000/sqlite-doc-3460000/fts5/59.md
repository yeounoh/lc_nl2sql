### 7\.2\.2\. Custom Auxiliary Functions API Reference



```
struct Fts5ExtensionApi {
  int iVersion;                   /* Currently always set to 3 */

  void *(*[xUserData](#xUserData))(Fts5Context*);

  int (*[xColumnCount](#xColumnCount))(Fts5Context*);
  int (*[xRowCount](#xRowCount))(Fts5Context*, sqlite3_int64 *pnRow);
  int (*[xColumnTotalSize](#xColumnTotalSize))(Fts5Context*, int iCol, sqlite3_int64 *pnToken);

  int (*[xTokenize](#xTokenize))(Fts5Context*, 
    const char *pText, int nText, /* Text to tokenize */
    void *pCtx,                   /* Context passed to xToken() */
    int (*xToken)(void*, int, const char*, int, int, int)       /* Callback */
  );

  int (*[xPhraseCount](#xPhraseCount))(Fts5Context*);
  int (*[xPhraseSize](#xPhraseSize))(Fts5Context*, int iPhrase);

  int (*[xInstCount](#xInstCount))(Fts5Context*, int *pnInst);
  int (*[xInst](#xInst))(Fts5Context*, int iIdx, int *piPhrase, int *piCol, int *piOff);

  sqlite3_int64 (*[xRowid](#xRowid))(Fts5Context*);
  int (*[xColumnText](#xColumnText))(Fts5Context*, int iCol, const char **pz, int *pn);
  int (*[xColumnSize](#xColumnSize))(Fts5Context*, int iCol, int *pnToken);

  int (*[xQueryPhrase](#xQueryPhrase))(Fts5Context*, int iPhrase, void *pUserData,
    int(*)(const Fts5ExtensionApi*,Fts5Context*,void*)
  );
  int (*[xSetAuxdata](#xSetAuxdata))(Fts5Context*, void *pAux, void(*xDelete)(void*));
  void *(*[xGetAuxdata](#xGetAuxdata))(Fts5Context*, int bClear);

  int (*[xPhraseFirst](#xPhraseFirst))(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*, int*);
  void (*[xPhraseNext](#xPhraseNext))(Fts5Context*, Fts5PhraseIter*, int *piCol, int *piOff);

  int (*[xPhraseFirstColumn](#xPhraseFirstColumn))(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*);
  void (*[xPhraseNextColumn](#xPhraseNextColumn))(Fts5Context*, Fts5PhraseIter*, int *piCol);

  /* Below this point are iVersion>=3 only */
  int (*[xQueryToken](#xQueryToken))(Fts5Context*, 
      int iPhrase, int iToken, 
      const char **ppToken, int *pnToken
  );
  int (*[xInstToken](#xInstToken))(Fts5Context*, int iIdx, int iToken, const char**, int*);
};

```



**void \*(\*xUserData)(Fts5Context\*)**

Return a copy of the pUserData pointer passed to the xCreateFunction()
 API when the extension function was registered.





**int (\*xColumnTotalSize)(Fts5Context\*, int iCol, sqlite3\_int64 \*pnToken)**

If parameter iCol is less than zero, set output variable \*pnToken
 to the total number of tokens in the FTS5 table. Or, if iCol is
 non\-negative but less than the number of columns in the table, return
 the total number of tokens in column iCol, considering all rows in 
 the FTS5 table.




 If parameter iCol is greater than or equal to the number of columns
 in the table, SQLITE\_RANGE is returned. Or, if an error occurs (e.g.
 an OOM condition or IO error), an appropriate SQLite error code is 
 returned.





**int (\*xColumnCount)(Fts5Context\*)**

Return the number of columns in the table.





**int (\*xColumnSize)(Fts5Context\*, int iCol, int \*pnToken)**

If parameter iCol is less than zero, set output variable \*pnToken
 to the total number of tokens in the current row. Or, if iCol is
 non\-negative but less than the number of columns in the table, set
 \*pnToken to the number of tokens in column iCol of the current row.




 If parameter iCol is greater than or equal to the number of columns
 in the table, SQLITE\_RANGE is returned. Or, if an error occurs (e.g.
 an OOM condition or IO error), an appropriate SQLite error code is 
 returned.




 This function may be quite inefficient if used with an FTS5 table
 created with the "columnsize\=0" option.





**int (\*xColumnText)(Fts5Context\*, int iCol, const char \*\*pz, int \*pn)**

If parameter iCol is less than zero, or greater than or equal to the
 number of columns in the table, SQLITE\_RANGE is returned. 




 Otherwise, this function attempts to retrieve the text of column iCol of
 the current document. If successful, (\*pz) is set to point to a buffer
 containing the text in utf\-8 encoding, (\*pn) is set to the size in bytes
 (not characters) of the buffer and SQLITE\_OK is returned. Otherwise,
 if an error occurs, an SQLite error code is returned and the final values
 of (\*pz) and (\*pn) are undefined.





**int (\*xPhraseCount)(Fts5Context\*)**

Returns the number of phrases in the current query expression.





**int (\*xPhraseSize)(Fts5Context\*, int iPhrase)**

If parameter iCol is less than zero, or greater than or equal to the
 number of phrases in the current query, as returned by xPhraseCount, 
 0 is returned. Otherwise, this function returns the number of tokens in
 phrase iPhrase of the query. Phrases are numbered starting from zero.





**int (\*xInstCount)(Fts5Context\*, int \*pnInst)**

Set \*pnInst to the total number of occurrences of all phrases within
 the query within the current row. Return SQLITE\_OK if successful, or
 an error code (i.e. SQLITE\_NOMEM) if an error occurs.




 This API can be quite slow if used with an FTS5 table created with the
 "detail\=none" or "detail\=column" option. If the FTS5 table is created 
 with either "detail\=none" or "detail\=column" and "content\=" option 
 (i.e. if it is a contentless table), then this API always returns 0\.





**int (\*xInst)(Fts5Context\*, int iIdx, int \*piPhrase, int \*piCol, int \*piOff)**

Query for the details of phrase match iIdx within the current row.
 Phrase matches are numbered starting from zero, so the iIdx argument
 should be greater than or equal to zero and smaller than the value
 output by xInstCount(). If iIdx is less than zero or greater than
 or equal to the value returned by xInstCount(), SQLITE\_RANGE is returned.




 Otherwise, output parameter \*piPhrase is set to the phrase number, \*piCol
 to the column in which it occurs and \*piOff the token offset of the
 first token of the phrase. SQLITE\_OK is returned if successful, or an
 error code (i.e. SQLITE\_NOMEM) if an error occurs.




 This API can be quite slow if used with an FTS5 table created with the
 "detail\=none" or "detail\=column" option.





**sqlite3\_int64 (\*xRowid)(Fts5Context\*)**

Returns the rowid of the current row.





**int (\*xTokenize)(Fts5Context\*, 
 const char \*pText, int nText, 
 void \*pCtx, 
 int (\*xToken)(void\*, int, const char\*, int, int, int) 
)**

Tokenize text using the tokenizer belonging to the FTS5 table.





**int (\*xQueryPhrase)(Fts5Context\*, int iPhrase, void \*pUserData,
 int(\*)(const Fts5ExtensionApi\*,Fts5Context\*,void\*)
)**

This API function is used to query the FTS table for phrase iPhrase
 of the current query. Specifically, a query equivalent to:




```
... FROM ftstable WHERE ftstable MATCH $p ORDER BY rowid

```


 with $p set to a phrase equivalent to the phrase iPhrase of the
 current query is executed. Any column filter that applies to
 phrase iPhrase of the current query is included in $p. For each 
 row visited, the callback function passed as the fourth argument 
 is invoked. The context and API objects passed to the callback 
 function may be used to access the properties of each matched row.
 Invoking Api.xUserData() returns a copy of the pointer passed as 
 the third argument to pUserData.




 If parameter iPhrase is less than zero, or greater than or equal to
 the number of phrases in the query, as returned by xPhraseCount(),
 this function returns SQLITE\_RANGE.




 If the callback function returns any value other than SQLITE\_OK, the
 query is abandoned and the xQueryPhrase function returns immediately.
 If the returned value is SQLITE\_DONE, xQueryPhrase returns SQLITE\_OK.
 Otherwise, the error code is propagated upwards.




 If the query runs to completion without incident, SQLITE\_OK is returned.
 Or, if some error occurs before the query completes or is aborted by
 the callback, an SQLite error code is returned.





**int (\*xSetAuxdata)(Fts5Context\*, void \*pAux, void(\*xDelete)(void\*))**

Save the pointer passed as the second argument as the extension function's 
 "auxiliary data". The pointer may then be retrieved by the current or any
 future invocation of the same fts5 extension function made as part of
 the same MATCH query using the xGetAuxdata() API.




 Each extension function is allocated a single auxiliary data slot for
 each FTS query (MATCH expression). If the extension function is invoked 
 more than once for a single FTS query, then all invocations share a 
 single auxiliary data context.




 If there is already an auxiliary data pointer when this function is
 invoked, then it is replaced by the new pointer. If an xDelete callback
 was specified along with the original pointer, it is invoked at this
 point.




 The xDelete callback, if one is specified, is also invoked on the
 auxiliary data pointer after the FTS5 query has finished.




 If an error (e.g. an OOM condition) occurs within this function,
 the auxiliary data is set to NULL and an error code returned. If the
 xDelete parameter was not NULL, it is invoked on the auxiliary data
 pointer before returning.





**void \*(\*xGetAuxdata)(Fts5Context\*, int bClear)**

Returns the current auxiliary data pointer for the fts5 extension 
 function. See the xSetAuxdata() method for details.




 If the bClear argument is non\-zero, then the auxiliary data is cleared
 (set to NULL) before this function returns. In this case the xDelete,
 if any, is not invoked.





**int (\*xRowCount)(Fts5Context\*, sqlite3\_int64 \*pnRow)**

This function is used to retrieve the total number of rows in the table.
 In other words, the same value that would be returned by:




```
SELECT count(*) FROM ftstable;

```



**int (\*xPhraseFirst)(Fts5Context\*, int iPhrase, Fts5PhraseIter\*, int\*, int\*)**

This function is used, along with type Fts5PhraseIter and the xPhraseNext
 method, to iterate through all instances of a single query phrase within
 the current row. This is the same information as is accessible via the
 xInstCount/xInst APIs. While the xInstCount/xInst APIs are more convenient
 to use, this API may be faster under some circumstances. To iterate 
 through instances of phrase iPhrase, use the following code:




```
Fts5PhraseIter iter;
int iCol, iOff;
for(pApi->xPhraseFirst(pFts, iPhrase, &iter, &iCol, &iOff);
    iCol>=0;
    pApi->xPhraseNext(pFts, &iter, &iCol, &iOff)
){
  // An instance of phrase iPhrase at offset iOff of column iCol
}

```


 The Fts5PhraseIter structure is defined above. Applications should not
 modify this structure directly \- it should only be used as shown above
 with the xPhraseFirst() and xPhraseNext() API methods (and by
 xPhraseFirstColumn() and xPhraseNextColumn() as illustrated below).




 This API can be quite slow if used with an FTS5 table created with the
 "detail\=none" or "detail\=column" option. If the FTS5 table is created 
 with either "detail\=none" or "detail\=column" and "content\=" option 
 (i.e. if it is a contentless table), then this API always iterates
 through an empty set (all calls to xPhraseFirst() set iCol to \-1\).





**void (\*xPhraseNext)(Fts5Context\*, Fts5PhraseIter\*, int \*piCol, int \*piOff)**

See xPhraseFirst above.





**int (\*xPhraseFirstColumn)(Fts5Context\*, int iPhrase, Fts5PhraseIter\*, int\*)**

This function and xPhraseNextColumn() are similar to the xPhraseFirst()
 and xPhraseNext() APIs described above. The difference is that instead
 of iterating through all instances of a phrase in the current row, these
 APIs are used to iterate through the set of columns in the current row
 that contain one or more instances of a specified phrase. For example:




```
Fts5PhraseIter iter;
int iCol;
for(pApi->xPhraseFirstColumn(pFts, iPhrase, &iter, &iCol);
    iCol>=0;
    pApi->xPhraseNextColumn(pFts, &iter, &iCol)
){
  // Column iCol contains at least one instance of phrase iPhrase
}

```


 This API can be quite slow if used with an FTS5 table created with the
 "detail\=none" option. If the FTS5 table is created with either 
 "detail\=none" "content\=" option (i.e. if it is a contentless table), 
 then this API always iterates through an empty set (all calls to 
 xPhraseFirstColumn() set iCol to \-1\).




 The information accessed using this API and its companion
 xPhraseFirstColumn() may also be obtained using xPhraseFirst/xPhraseNext
 (or xInst/xInstCount). The chief advantage of this API is that it is
 significantly more efficient than those alternatives when used with
 "detail\=column" tables.





**void (\*xPhraseNextColumn)(Fts5Context\*, Fts5PhraseIter\*, int \*piCol)**

See xPhraseFirstColumn above.





**int (\*xQueryToken)(Fts5Context\*, 
 int iPhrase, int iToken, 
 const char \*\*ppToken, int \*pnToken
)**

This is used to access token iToken of phrase iPhrase of the current
 query. Before returning, output parameter \*ppToken is set to point
 to a buffer containing the requested token, and \*pnToken to the
 size of this buffer in bytes.




 If iPhrase or iToken are less than zero, or if iPhrase is greater than
 or equal to the number of phrases in the query as reported by 
 xPhraseCount(), or if iToken is equal to or greater than the number of
 tokens in the phrase, SQLITE\_RANGE is returned and \*ppToken and \*pnToken
 are both zeroed.




 The output text is not a copy of the query text that specified the
 token. It is the output of the tokenizer module. For tokendata\=1
 tables, this includes any embedded 0x00 and trailing data.





**int (\*xInstToken)(Fts5Context\*, int iIdx, int iToken, const char\*\*, int\*)**

This is used to access token iToken of phrase hit iIdx within the
 current row. If iIdx is less than zero or greater than or equal to the
 value returned by xInstCount(), SQLITE\_RANGE is returned. Otherwise,
 output variable (\*ppToken) is set to point to a buffer containing the
 matching document token, and (\*pnToken) to the size of that buffer in 
 bytes. This API is not available if the specified token matches a 
 prefix query term. In that case both output variables are always set 
 to 0\.




 The output text is not a copy of the document text that was tokenized.
 It is the output of the tokenizer module. For tokendata\=1 tables, this 
 includes any embedded 0x00 and trailing data.




 This API can be quite slow if used with an FTS5 table created with the
 "detail\=none" or "detail\=column" option.






