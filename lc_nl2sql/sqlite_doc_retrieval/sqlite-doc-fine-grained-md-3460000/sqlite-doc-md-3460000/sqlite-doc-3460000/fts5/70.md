#### 9\.2\.4\.3\. Segment Index Format


The result of formatting the contents of the segment b\-tree in the
key/doclist format and then splitting it into pages is something very
similar to the leaves of a b\+tree. Instead of creating a format for
the internal nodes of this b\+tree and storing them in the %\_data table
alongside the leaves, the keys that would have been stored on such nodes are
added to the %\_idx table, defined as:




```
CREATE TABLE %_idx(
  segid INTEGER,              -- segment id
  term TEXT,                  -- prefix of first key on page
  pgno INTEGER,               -- (2*pgno + bDoclistIndex)
  PRIMARY KEY(segid, term)
);

```

For each "leaf" page that contains at least one key, an entry is added
to the %\_idx table. Fields are set as follows:





| Column | Contents |
| --- | --- |
| segid | The integer segment id. |
| term | The smallest prefix of the first key on the page that  is larger than all keys on the previous page. For the  first page in a segment, this prefix is zero bytes in  size. |
| pgno | This field encodes both the page number (within the  segment \- starting from 1\) and the doclist index flag.  The doclist index flag is set if the final key on the  page has an [associated  doclist index](#doclist_index_format). The value of this field is:   ```         (pgno*2 + bDoclistIndexFlag)  ``` |


Then, to find the leaf for segment i that may contain term t, instead of
searching through internal nodes, FTS5 runs the query:




```
SELECT pgno FROM %_idx WHERE segid=$i AND term>=$t ORDER BY term LIMIT 1

```

