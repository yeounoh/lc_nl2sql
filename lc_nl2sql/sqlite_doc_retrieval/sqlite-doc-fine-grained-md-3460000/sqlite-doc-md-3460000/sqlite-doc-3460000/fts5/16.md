## 4\.3\. Tokenizers


 The CREATE VIRTUAL TABLE "tokenize" option is used to configure the
specific tokenizer used by the FTS5 table. The option argument must be either
an FTS5 bareword, or an SQL text literal. The text of the argument is itself
treated as a white\-space series of one or more FTS5 barewords or SQL text
literals. The first of these is the name of the tokenizer to use. The second
and subsequent list elements, if they exist, are arguments passed to the
tokenizer implementation.



 Unlike option values and column names, SQL text literals intended as
tokenizers must be quoted using single quote characters. For example:




```
-- The following are all equivalent
CREATE VIRTUAL TABLE t1 USING fts5(x, tokenize = 'porter ascii');
CREATE VIRTUAL TABLE t1 USING fts5(x, tokenize = "porter ascii");
CREATE VIRTUAL TABLE t1 USING fts5(x, tokenize = "'porter' 'ascii'");
CREATE VIRTUAL TABLE t1 USING fts5(x, tokenize = '''porter'' ''ascii''');

-- But this will fail:
CREATE VIRTUAL TABLE t1 USING fts5(x, tokenize = '"porter" "ascii"');

-- This will fail too:
CREATE VIRTUAL TABLE t1 USING fts5(x, tokenize = 'porter' 'ascii');

```


FTS5 features four built\-in tokenizer modules, described in subsequent
sections:



* The **unicode61** tokenizer, based on the Unicode 6\.1 standard. This
 is the default.
* The **ascii** tokenizer, which assumes all characters outside of
 the ASCII codepoint range (0\-127\) are to be treated as token characters.
* The **porter** tokenizer, which implements the
[porter stemming algorithm](https://tartarus.org/martin/PorterStemmer).
* The **trigram** tokenizer, which treats each contiguous sequence of
 three characters as a token, allowing FTS5 to support more general substring matching.


 It is also possible to create custom tokenizers for FTS5\. The API for doing so is [described here](fts5.html#custom_tokenizers).



