### 7\.2\.1\. Custom Auxiliary Functions API Overview


This section provides an overview of the capabilities of the auxiliary
function API. It does not describe every function. Refer to the [reference text](#custom_auxiliary_functions_api_reference) below for a
complete description.



When invoked, an auxiliary function implementation has access to APIs that
allow it to query FTS5 for various information. Some of these APIs return
information relating to the current row of the FTS5 table being visited,
some relating to the entire set of rows that will be visited by the FTS5
query, and some relating to the FTS5 table. Given an FTS5 table populated as
follows:




```
CREATE VIRTUAL TABLE ft USING fts5(a, b);
INSERT INTO ft(rowid, a, b) VALUES
        (1, 'ab cd', 'cd de one'),
        (2, 'de fg', 'fg gh'),
        (3, 'gh ij', 'ij ab three four');

```

and the query:




```
SELECT my_aux_function(ft) FROM ft('ab')

```

then the custom auxiliary function will be invoked for rows 1 and 3 (all
rows that contain the token "ab" and therefore match the query). 



**Number of rows/columns in table: xRowCount, xColumnCount**

The system may be queried for the total number of rows in the FTS5 table
using the [xRowCount](#xRowCount) API. This provides the total number
of rows in the table, not the number that match the current query.



Table columns are numbered from left to right starting from 0\. The
"rowid" column does not count \- only user declared columns \- so in the example
above column "a" is column 0 and column "b" is column 1\. From within an
auxiliary function implementation, the [xColumnCount](#xColumnCount)
API may be used to determine how many columns the table being queried has. If
the xColumnCount() API is invoked from within the implementation of the
auxiliary function my\_aux\_function in the example above, it returns 2\.



**Data From Current Row: xColumnText, xRowid**

The [xRowid](#xRowid) API may be used to find the rowid value
for the current row. The [xColumnText](#xColumnText) may be used
to obtain the text stored in a specified column of the current row.



**Token Counts: xColumnSize, xColumnTotalSize**

FTS5 divides documents inserted into an fts table into tokens. These are
usually just words, perhaps folded to either upper or lower case and with any
punctuation removed. For example, the default 
[unicode61 tokenizer](#unicode61_tokenizer) tokenizes the text "The
tokenizer is case\-insensitive" to a list of 5 tokens \- "the", "tokenizer", is",
"case" and "insensitive". Exactly how tokens are extracted from text is 
determined by the [tokenizer](#tokenizers).



The auxiliary functions API provides functions to query for both the number
of tokens in a specified column of the current row (the 
[xColumnSize](#xColumnSize) API), or for the number of tokens in a 
specified column of all rows of the table (the [xColumnTotalSize](#xColumnTotalSize) API). For the example at the
top of this section, when visiting row 1, xColumnSize returns 2 for column 0
and 3 for column 1\. xColumnTotalSize returns 6 for column 0 and 9 for column 1
regardless of the current row.



**The Current Full\-Text Query: xPhraseCount, xPhraseSize, xQueryToken**

An FTS5 query contains one or more [phrases](#fts5_phrases). The 
[xPhraseCount](#xPhraseCount), [xPhraseSize](#xPhraseSize)
and [xQueryToken](#xQueryToken) APIs allow an auxiliary function
implementation to query the system for details of the current query. The
xPhraseCount API returns the number of phrases in the current query. For
example, if an FTS5 table is queried as follows:




```
SELECT my_aux_function(ft) FROM ft('ab AND "cd ef gh" OR ij + kl')

```

and the xPhraseCount() API invoked from within the implementation of the
auxiliary function, it returns 3 (the three phrases being "ab", "ce ef gh" and
"ij kl"). 



Phrases are numbered in order of appearance within a query starting from 0\.
The xPhraseSize() API may be used to query for the number of tokens in a
specified phrase of the query. In the example above, phrase 0 contains 1 token,
phrase 1 contains 3 tokens, and phrase 2 contains 2\.



The xQueryToken API may be used to access the text of a specified token
within a specified phrase of the query. Tokens are numbered within their
phrases from left to right starting from 0\. For example, if the xQueryToken
API is used to request token 1 of phrase 2 in the example above, it returns
the text "kl". Token 0 of phrase 0 is "ab".



**Phrase Hits in the Current Row: xPhraseFirst, xPhraseNext**

These two API functions may be used to iterate through the matches for
a specified phrase of the query within the current row. Phrase matches are
identified by the column and token offset within the current row. For
example, say the following example table:




```
CREATE VIRTUAL TABLE ft2 USING fts5(x, y);
INSERT INTO ft2(rowid, x, y) VALUES
        (1, 'xxx one two xxx five xxx six', 'seven four'),
        (2, 'five four four xxx six', 'three four five six four five six');

```

is queried with:




```
SELECT my_aux_function(ft2) FROM ft2(
    '("one two" OR "three") AND y:four NEAR(five six, 2)'
);

```

The query above contains 5 phrases \- "one two", "three", "four", 
"five" and "six". It matches all rows of the table, so the auxiliary 
function is invoked for each row.



In row 1, for phrase 0, "one two", there is exactly one match to iterate
through \- at column 0 token offset 1\. The column number is 0 because the 
match appears in the left most column. The token offset is 1 because there 
is exactly one token ("xxx") before the phrase match in the column value.
For phrase 1, "three", there are no matches. Phrase 2, "four", has one
match, at column 1, token offset 0\. Phrase 3, "five", has one match at
column 0, token offset 4, and phrase 4, "six", has one match at column 0
token offset 6\.



The set of matches for each phrase in each row of the example is presented
in the table below. Each match is notated as (column\-number, token\-offset):





| Row | Phrase 0 | Phrase 1 | Phrase 2 | Phrase 3 | Phrase 4 |
| --- | --- | --- | --- | --- | --- |
| 1 | (0, 1\) |  | (1, 1\) | (0, 4\) | (0, 6\) |
| 2 |  | (1,0\) | (1, 1\), (1,4\) | (1, 2\), (1, 5\) | (1, 3\), (1, 6\) |


The second row is slightly more complicated. There were no occurrences of
phrase 0\. Phrase 1 ("three") appears once, at column 1 token offset 0\. Although
there are instances of phrase 2 ("four") in column 0, none of them are reported
by the API, as phrase 4 has a [column filter](#fts5_column_filters) \-
"y:". Matches that are filtered out by column filters do not count. Similarly,
although phrases 3 and 4 do occur in column "x" of row 2, they are filtered
out by the [NEAR filter](#fts5_near_queries). Matches that are
filtered out by NEAR filters do not count either.



**Phrase Hits in the Current Row (2\): xInstCount, xInst**

The [xInstCount](#xInstCount) and [xInst](#xInst) APIs
provide access to the same information as the xPhraseFirst and xPhraseNext
described above. The difference is that instead of iterating through the
matches for a single, specified phrase, the xInstCount/xInst APIs collate
all matches into a single flat array, sorted in order of occurrence within
the current row. Elements of this array may then be accessed randomly.



Each array element consists of three values:



* A phrase number,
* A column number, and
* A token offset


Using the same example data and query as for xPhraseFirst/xPhraseNext
above, the array accessible via xInstCount/xInst consists of the following
entries for each row:





| Row | xInstCount/xInst array |
| --- | --- |
| 1 | (0, 0, 1\), (3, 0, 4\), (4, 0, 6\), (2, 1, 1\) |
| 2 | (1, 1, 0\), (2, 1, 1\), (3, 1, 2\), (4, 1, 3\), (2, 1, 4\), (3, 1, 5\), (4, 1, 6\) |


Each entry of the array is called a phrase match. Phrase matches are
numbered in order, starting from 0\. So, in the example above, in row 2, phrase
match 3 is (4, 1, 3\) \- phrase 4 of the query matches at column 1, token offset
3\.




