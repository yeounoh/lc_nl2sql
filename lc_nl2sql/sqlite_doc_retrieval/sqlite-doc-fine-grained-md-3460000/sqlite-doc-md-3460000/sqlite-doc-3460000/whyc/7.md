# 3\. Why Isn't SQLite Coded In A "Safe" Language?



There has lately been a lot of interest in "safe" programming languages
like Rust or Go in which it is impossible, or is at least difficult, to make
common programming errors like memory leaks or array overruns. So the
question often arises as to why SQLite is not coded in a "safe" language.



1. None of the safe programming languages existed for the first 10 years
of SQLite's existence. SQLite could be recoded in Go or Rust, but doing
so would probably introduce far more bugs than would be fixed, and it
seems also likely to result in slower code.
2. Safe languages insert additional machine branches to do things like
verify that array accesses are in\-bounds. In correct code, those
branches are never taken. That means that the machine code cannot
be 100% branch tested, which is an important component of SQLite's
quality strategy.
3. Safe languages usually want to abort if they encounter an out\-of\-memory
(OOM) situation. SQLite is designed to recover gracefully from an OOM.
It is unclear how this could be accomplished in the current crop of
safe languages.
4. All of the existing safe languages are new. The developers of SQLite
applaud the efforts of computer language researchers in trying to
develop languages that are easier to program safely. We encourage these
efforts to continue. But we ourselves are more interested in old and
boring languages when it comes to implementing SQLite.



All that said, it is possible that SQLite might
one day be recoded in Rust. Recoding SQLite in Go is unlikely
since Go hates assert(). But Rust is a possibility. Some
preconditions that must occur before SQLite is recoded in Rust
include:






1. Rust needs to mature a little more, stop changing so fast, and
 move further toward being old and boring.
2. Rust needs to demonstrate that it can be used to create general\-purpose
 libraries that are callable from all other programming languages.
3. Rust needs to demonstrate that it can produce object code that
 works on obscure embedded devices, including devices that lack
 an operating system.
4. Rust needs to pick up the necessary tooling that enables one to
 do 100% branch coverage testing of the compiled binaries.
5. Rust needs a mechanism to recover gracefully from OOM errors.
6. Rust needs to demonstrate that it can do the kinds of work that
 C does in SQLite without a significant speed penalty.



If you are a "rustacean" and feel that Rust already meets the
preconditions listed above, and that SQLite should be recoded in
Rust, then you are welcomed and encouraged
to contact the SQLite developers privately
and argue your case.


*This page last modified on [2022\-07\-29 00:41:26](https://sqlite.org/docsrc/honeypot) UTC* 


