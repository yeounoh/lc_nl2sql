#### 3\.3 Querying into memory obtained from malloc()


The **sqlite\_get\_table** function is a wrapper around
**sqlite\_exec** that collects all the information from successive
callbacks and writes it into memory obtained from malloc(). This
is a convenience function that allows the application to get the
entire result of a database query with a single function call.


The main result from **sqlite\_get\_table** is an array of pointers
to strings. There is one element in this array for each column of
each row in the result. NULL results are represented by a NULL
pointer. In addition to the regular data, there is an added row at the 
beginning of the array that contains the name of each column of the
result.


As an example, consider the following query:



> SELECT employee\_name, login, host FROM users WHERE login LIKE 'd%';


This query will return the name, login and host computer name
for every employee whose login begins with the letter "d". If this
query is submitted to **sqlite\_get\_table** the result might
look like this:



> nrow \= 2  
> 
> ncolumn \= 3  
> 
> result\[0] \= "employee\_name"  
> 
> result\[1] \= "login"  
> 
> result\[2] \= "host"  
> 
> result\[3] \= "dummy"  
> 
> result\[4] \= "No such user"  
> 
> result\[5] \= 0  
> 
> result\[6] \= "D. Richard Hipp"  
> 
> result\[7] \= "drh"  
> 
> result\[8] \= "zadok"


Notice that the "host" value for the "dummy" record is NULL so
the result\[] array contains a NULL pointer at that slot.


If the result set of a query is empty, then by default
**sqlite\_get\_table** will set nrow to 0 and leave its
result parameter is set to NULL. But if the EMPTY\_RESULT\_CALLBACKS
pragma is ON then the result parameter is initialized to the names
of the columns only. For example, consider this query which has
an empty result set:



> SELECT employee\_name, login, host FROM users WHERE employee\_name IS NULL;



The default behavior gives this results:




> nrow \= 0  
> 
> ncolumn \= 0  
> 
> result \= 0



But if the EMPTY\_RESULT\_CALLBACKS pragma is ON, then the following
is returned:




> nrow \= 0  
> 
> ncolumn \= 3  
> 
> result\[0] \= "employee\_name"  
> 
> result\[1] \= "login"  
> 
> result\[2] \= "host"


Memory to hold the information returned by **sqlite\_get\_table**
is obtained from malloc(). But the calling function should not try
to free this information directly. Instead, pass the complete table
to **sqlite\_free\_table** when the table is no longer needed.
It is safe to call **sqlite\_free\_table** with a NULL pointer such
as would be returned if the result set is empty.


The **sqlite\_get\_table** routine returns the same integer
result code as **sqlite\_exec**.


