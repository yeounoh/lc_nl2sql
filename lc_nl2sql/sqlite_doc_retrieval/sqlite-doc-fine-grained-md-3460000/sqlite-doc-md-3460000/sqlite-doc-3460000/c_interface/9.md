#### 2\.2 Step\-By\-Step Execution Of An SQL Statement



After a virtual machine has been generated using **sqlite\_compile**
it is executed by one or more calls to **sqlite\_step**. Each
invocation of **sqlite\_step**, except the last one,
returns a single row of the result.
The number of columns in the result is stored in the integer that
the 2nd parameter points to.
The pointer specified by the 3rd parameter is made to point
to an array of pointers to column values.
The pointer in the 4th parameter is made to point to an array
of pointers to column names and datatypes.
The 2nd through 4th parameters to **sqlite\_step** convey the
same information as the 2nd through 4th parameters of the
**callback** routine when using
the **sqlite\_exec** interface. Except, with **sqlite\_step**
the column datatype information is always included in the in the
4th parameter regardless of whether or not the
[SHOW\_DATATYPES](pragma.html) pragma
is on or off.




Each invocation of **sqlite\_step** returns an integer code that
indicates what happened during that step. This code may be
SQLITE\_BUSY, SQLITE\_ROW, SQLITE\_DONE, SQLITE\_ERROR, or
SQLITE\_MISUSE.




If the virtual machine is unable to open the database file because
it is locked by another thread or process, **sqlite\_step**
will return SQLITE\_BUSY. The calling function should do some other
activity, or sleep, for a short amount of time to give the lock a
chance to clear, then invoke **sqlite\_step** again. This can
be repeated as many times as desired.




Whenever another row of result data is available,
**sqlite\_step** will return SQLITE\_ROW. The row data is
stored in an array of pointers to strings and the 2nd parameter
is made to point to this array.




When all processing is complete, **sqlite\_step** will return
either SQLITE\_DONE or SQLITE\_ERROR. SQLITE\_DONE indicates that the
statement completed successfully and SQLITE\_ERROR indicates that there
was a run\-time error. (The details of the error are obtained from
**sqlite\_finalize**.) It is a misuse of the library to attempt
to call **sqlite\_step** again after it has returned SQLITE\_DONE
or SQLITE\_ERROR.




When **sqlite\_step** returns SQLITE\_DONE or SQLITE\_ERROR,
the \*pN and \*pazColName values are set to the number of columns
in the result set and to the names of the columns, just as they
are for an SQLITE\_ROW return. This allows the calling code to
find the number of result columns and the column names and datatypes
even if the result set is empty. The \*pazValue parameter is always
set to NULL when the return codes is SQLITE\_DONE or SQLITE\_ERROR.
If the SQL being executed is a statement that does not
return a result (such as an INSERT or an UPDATE) then \*pN will
be set to zero and \*pazColName will be set to NULL.




If you abuse the library by trying to call **sqlite\_step**
inappropriately it will attempt return SQLITE\_MISUSE.
This can happen if you call sqlite\_step() on the same virtual machine
at the same
time from two or more threads or if you call sqlite\_step()
again after it returned SQLITE\_DONE or SQLITE\_ERROR or if you
pass in an invalid virtual machine pointer to sqlite\_step().
You should not depend on the SQLITE\_MISUSE return code to indicate
an error. It is possible that a misuse of the interface will go
undetected and result in a program crash. The SQLITE\_MISUSE is
intended as a debugging aid only \- to help you detect incorrect
usage prior to a mishap. The misuse detection logic is not guaranteed
to work in every case.



