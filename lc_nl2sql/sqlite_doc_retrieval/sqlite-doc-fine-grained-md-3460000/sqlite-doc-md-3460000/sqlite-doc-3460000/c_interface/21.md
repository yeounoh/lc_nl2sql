#### 3\.10 Performing background jobs during large queries
The **sqlite\_progress\_handler()** routine can be used to register a
callback routine with an SQLite database to be invoked periodically during long
running calls to **sqlite\_exec()**, **sqlite\_step()** and the various
wrapper functions.

The callback is invoked every N virtual machine operations, where N is
supplied as the second argument to **sqlite\_progress\_handler()**. The third
and fourth arguments to **sqlite\_progress\_handler()** are a pointer to the
routine to be invoked and a void pointer to be passed as the first argument to
it.

The time taken to execute each virtual machine operation can vary based on
many factors. A typical value for a 1 GHz PC is between half and three million
per second but may be much higher or lower, depending on the query. As such it
is difficult to schedule background operations based on virtual machine
operations. Instead, it is recommended that a callback be scheduled relatively
frequently (say every 1000 instructions) and external timer routines used to
determine whether or not background jobs need to be run. 


4\.0 Adding New SQL Functions
Beginning with version 2\.4\.0, SQLite allows the SQL language to be
extended with new functions implemented as C code. The following interface
is used:


```

typedef struct sqlite_func sqlite_func;

int sqlite_create_function(
  sqlite *db,
  const char *zName,
  int nArg,
  void (*xFunc)(sqlite_func*,int,const char**),
  void *pUserData
);
int sqlite_create_aggregate(
  sqlite *db,
  const char *zName,
  int nArg,
  void (*xStep)(sqlite_func*,int,const char**),
  void (*xFinalize)(sqlite_func*),
  void *pUserData
);

char *sqlite_set_result_string(sqlite_func*,const char*,int);
void sqlite_set_result_int(sqlite_func*,int);
void sqlite_set_result_double(sqlite_func*,double);
void sqlite_set_result_error(sqlite_func*,const char*,int);

void *sqlite_user_data(sqlite_func*);
void *sqlite_aggregate_context(sqlite_func*, int nBytes);
int sqlite_aggregate_count(sqlite_func*);

```


The **sqlite\_create\_function()** interface is used to create 
regular functions and **sqlite\_create\_aggregate()** is used to
create new aggregate functions. In both cases, the **db**
parameter is an open SQLite database on which the functions should
be registered, **zName** is the name of the new function,
**nArg** is the number of arguments, and **pUserData** is
a pointer which is passed through unchanged to the C implementation
of the function. Both routines return 0 on success and non\-zero
if there are any errors.


The length of a function name may not exceed 255 characters.
Any attempt to create a function whose name exceeds 255 characters
in length will result in an error.


For regular functions, the **xFunc** callback is invoked once
for each function call. The implementation of xFunc should call
one of the **sqlite\_set\_result\_...** interfaces to return its
result. The **sqlite\_user\_data()** routine can be used to
retrieve the **pUserData** pointer that was passed in when the
function was registered.


For aggregate functions, the **xStep** callback is invoked once
for each row in the result and then **xFinalize** is invoked at the
end to compute a final answer. The xStep routine can use the
**sqlite\_aggregate\_context()** interface to allocate memory that
will be unique to that particular instance of the SQL function.
This memory will be automatically deleted after xFinalize is called.
The **sqlite\_aggregate\_count()** routine can be used to find out
how many rows of data were passed to the aggregate. The xFinalize
callback should invoke one of the **sqlite\_set\_result\_...**
interfaces to set the final result of the aggregate.


SQLite now implements all of its built\-in functions using this
interface. For additional information and examples on how to create
new SQL functions, review the SQLite source code in the file
**func.c**.

5\.0 Multi\-Threading And SQLite

If SQLite is compiled with the THREADSAFE preprocessor macro set to 1,
then it is safe to use SQLite from two or more threads of the same process
at the same time. But each thread should have its own **sqlite\***
pointer returned from **sqlite\_open**. It is never safe for two
or more threads to access the same **sqlite\*** pointer at the same time.


In precompiled SQLite libraries available on the website, the Unix
versions are compiled with THREADSAFE turned off but the Windows
versions are compiled with THREADSAFE turned on. If you need something
different that this you will have to recompile.


Under Unix, an **sqlite\*** pointer should not be carried across a
**fork()** system call into the child process. The child process
should open its own copy of the database after the **fork()**.

6\.0 Usage Examples
For examples of how the SQLite C/C\+\+ interface can be used,
refer to the source code for the **sqlite** program in the
file [src/shell.c](https://sqlite.org/src/file/src/shell.c.in)
of the source tree.
Additional information about sqlite is available at
<cli.html>.
See also the sources to the Tcl interface for SQLite in
the source file 
[src/tclsqlite.c](https://sqlite.org/src/file/src/tclsqlite.c).
*This page last modified on [2023\-01\-06 00:45:39](https://sqlite.org/docsrc/honeypot) UTC*





