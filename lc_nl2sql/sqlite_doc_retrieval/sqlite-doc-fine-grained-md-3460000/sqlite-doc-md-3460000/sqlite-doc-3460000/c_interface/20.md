#### 3\.9 Using the \_printf() wrapper functions


The four utility functions



* **sqlite\_exec\_printf()**
* **sqlite\_exec\_vprintf()**
* **sqlite\_get\_table\_printf()**
* **sqlite\_get\_table\_vprintf()**





implement the same query functionality as **sqlite\_exec**
and **sqlite\_get\_table**. But instead of taking a complete
SQL statement as their second argument, the four **\_printf**
routines take a printf\-style format string. The SQL statement to
be executed is generated from this format string and from whatever
additional arguments are attached to the end of the function call.


There are two advantages to using the SQLite printf
functions instead of **sprintf**. First of all, with the
SQLite printf routines, there is never a danger of overflowing a
static buffer as there is with **sprintf**. The SQLite
printf routines automatically allocate (and later frees)
as much memory as is 
necessary to hold the SQL statements generated.


The second advantage the SQLite printf routines have over
**sprintf** are two new formatting options specifically designed
to support string literals in SQL. Within the format string,
the %q formatting option works very much like %s in that it
reads a null\-terminated string from the argument list and inserts
it into the result. But %q translates the inserted string by
making two copies of every single\-quote (') character in the
substituted string. This has the effect of escaping the end\-of\-string
meaning of single\-quote within a string literal. The %Q formatting
option works similar; it translates the single\-quotes like %q and
additionally encloses the resulting string in single\-quotes.
If the argument for the %Q formatting options is a NULL pointer,
the resulting string is NULL without single quotes.



Consider an example. Suppose you are trying to insert a string
value into a database table where the string value was obtained from
user input. Suppose the string to be inserted is stored in a variable
named zString. The code to do the insertion might look like this:



> ```
> 
> sqlite_exec_printf(db,
>   "INSERT INTO table1 VALUES('%s')",
>   0, 0, 0, zString);
> 
> ```


If the zString variable holds text like "Hello", then this statement
will work just fine. But suppose the user enters a string like 
"Hi y'all!". The SQL statement generated reads as follows:


> ```
> 
> INSERT INTO table1 VALUES('Hi y'all')
> 
> ```


This is not valid SQL because of the apostrophe in the word "y'all".
But if the %q formatting option is used instead of %s, like this:



> ```
> 
> sqlite_exec_printf(db,
>   "INSERT INTO table1 VALUES('%q')",
>   0, 0, 0, zString);
> 
> ```


Then the generated SQL will look like the following:



> ```
> 
> INSERT INTO table1 VALUES('Hi y''all')
> 
> ```


Here the apostrophe has been escaped and the SQL statement is well\-formed.
When generating SQL on\-the\-fly from data that might contain a
single\-quote character ('), it is always a good idea to use the
SQLite printf routines and the %q formatting option instead of **sprintf**.



If the %Q formatting option is used instead of %q, like this:



> ```
> 
> sqlite_exec_printf(db,
>   "INSERT INTO table1 VALUES(%Q)",
>   0, 0, 0, zString);
> 
> ```


Then the generated SQL will look like the following:



> ```
> 
> INSERT INTO table1 VALUES('Hi y''all')
> 
> ```


If the value of the zString variable is NULL, the generated SQL
will look like the following:



> ```
> 
> INSERT INTO table1 VALUES(NULL)
> 
> ```


All of the \_printf() routines above are built around the following
two functions:



> ```
> 
> char *sqlite_mprintf(const char *zFormat, ...);
> char *sqlite_vmprintf(const char *zFormat, va_list);
> 
> ```


The **sqlite\_mprintf()** routine works like the standard library
**sprintf()** except that it writes its results into memory obtained
from malloc() and returns a pointer to the malloced buffer. 
**sqlite\_mprintf()** also understands the %q and %Q extensions described
above. The **sqlite\_vmprintf()** is a varargs version of the same
routine. The string pointer that these routines return should be freed
by passing it to **sqlite\_freemem()**.



