# 3\. The Rollback Journal


The rollback journal is a file associated with each SQLite database
file that holds information used to restore the database file to its initial
state during the course of a transaction.
The rollback journal file is always located in the same 
directory as the database
file and has the same name as the database file but with the string
"\-journal" appended. There can only be a single rollback journal
associated with a give database and hence there can only be one write
transaction open against a single database at one time.


If a transaction is aborted due to an application crash, an operating
system crash, or a hardware power failure or crash, then the database may
be left in an inconsistent state. The next time SQLite attempts to open
the database file, the presence of the rollback journal file will be 
detected and the journal will be automatically played back to restore the
database to its state at the start of the incomplete transaction.


A rollback journal is only considered to be valid if it exists and
contains a valid header. Hence a transaction can be committed in one
of three ways:


1. The rollback journal file can be deleted,
2. The rollback journal file can be truncated to zero length, or
3. The header of the rollback journal can be overwritten with
invalid header text (for example, all zeros).



These three ways of committing a transaction correspond to the DELETE,
TRUNCATE, and PERSIST settings, respectively, of the [journal\_mode pragma](pragma.html#pragma_journal_mode).



A valid rollback journal begins with a header in the following format:



*Rollback Journal Header Format*  



| Offset | Size | Description |
| --- | --- | --- |
| 0 | 8 | Header string: 0xd9, 0xd5, 0x05, 0xf9, 0x20, 0xa1, 0x63, 0xd7 |
| 8 | 4 | The "Page Count" \- The number of pages in the next segment of the   journal, or \-1 to  mean all content to the end of the file |
| 12 | 4 | A random nonce for the checksum |
| 16 | 4 | Initial size of the database in pages |
| 20 | 4 | Size of a disk sector assumed by the process that wrote this  journal. |
| 24 | 4 | Size of pages in this journal. |



A rollback journal header is padded with zeros out to the size of a 
single sector (as defined by the sector size integer at offset 20\).
The header is in a sector by itself so that if a power loss occurs while
writing the sector, information that follows the header will be
(hopefully) undamaged.


After the header and zero padding are zero or more page records. Each
page record stores a copy of the content of a page from the database file
before it was changed. The same page may not appear more than once
within a single rollback journal.
To rollback an incomplete transaction, a process
has merely to read the rollback journal from beginning to end and
write pages found in the journal back into the database file at the
appropriate location.


Let the database page size (the value of the integer at offset 24 
in the journal header) be N.
Then the format of a page record is as follows:



*Rollback Journal Page Record Format*  



| Offset | Size | Description |
| --- | --- | --- |
| 0 | 4 | The page number in the database file |
| 4 | N | Original content of the page prior to the start of the transaction |
| N\+4 | 4 | Checksum |



The checksum is an unsigned 32\-bit integer computed as follows:


1. Initialize the checksum to the checksum nonce value found in the
journal header at offset 12\.
2. Initialize index X to be N\-200 (where N is the size of a database page
in bytes.
3. Interpret the byte at offset X into the page as an 8\-bit unsigned integer
 and add the value of that integer to the checksum.
4. Subtract 200 from X.
5. If X is greater than or equal to zero, go back to step 3\.


The checksum value is used to guard against incomplete writes of
a journal page record following a power failure. A different random nonce
is used each time a transaction is started in order to minimize the risk
that unwritten sectors might by chance contain data from the same page
that was a part of prior journals. By changing the nonce for each
transaction, stale data on disk will still generate an incorrect checksum
and be detected with high probability. The checksum only uses a sparse sample
of 32\-bit words from the data record for performance reasons \- design studies 
during the planning phases of SQLite 3\.0\.0 showed
a significant performance hit in checksumming the entire page.


Let the page count value at offset 8 in the journal header be M.
If M is greater than zero then after M page records the journal file
may be zero padded out to the next multiple of the sector size and another
journal header may be inserted. All journal headers within the same
journal must contain the same database page size and sector size.


If M is \-1 in the initial journal header, then the number of page records
that follow is computed by computing how many page records will fit in
the available space of the remainder of the journal file.



