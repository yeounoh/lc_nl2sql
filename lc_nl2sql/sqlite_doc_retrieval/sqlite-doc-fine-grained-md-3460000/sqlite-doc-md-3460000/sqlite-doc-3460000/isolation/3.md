## Isolation And Concurrency



SQLite implements isolation and concurrency control (and atomicity) using
transient journal files that appear in the same directory as the database file.
There are two major "journal modes".
The older "rollback mode" corresponds to using the "DELETE", "PERSIST",
or "TRUNCATE" options to the [journal\_mode pragma](pragma.html#pragma_journal_mode). In rollback mode,
changes are written directly into the database file, while simultaneously
a separate rollback journal file is constructed that is able to restore
the database to its original state if the transaction rolls back.
Rollback mode (specifically DELETE mode, meaning that the rollback journal
is deleted from disk at the conclusion of each transaction) is the current
default behavior.



Since [version 3\.7\.0](releaselog/3_7_0.html) (2010\-07\-21\), 
SQLite also supports "[WAL mode](wal.html)". In WAL mode,
changes are not written to the original database file. Instead, changes
go into a separate "write\-ahead log" or "WAL" file. 
Later, after the transaction
commits, those changes will be moved from the WAL file back into the
original database in an operation called "checkpoint". WAL mode is
enabled by running "[PRAGMA journal\_mode\=WAL](pragma.html#pragma_journal_mode)".




In rollback mode, SQLite implements isolation by locking the database
file and preventing any reads by other database connections
while each write transaction is underway.
Readers can be active at the beginning of a write, before any content
is flushed to disk and while all changes are still held in the writer's
private memory space. But before any changes are made to the database file
on disk, all readers must be (temporarily) expelled in order to give the writer
exclusive access to the database file. 
Hence, readers are prohibited from seeing incomplete
transactions by virtue of being locked out of the database while the
transaction is being written to disk. Only after the transaction is
completely written and synced to disk and committed are the readers allowed
back into the database. Hence readers never get a chance to see partially
written changes.




WAL mode permits simultaneous readers and writers. It can do this because
changes do not overwrite the original database file, but rather go
into the separate write\-ahead log file. That means that readers can continue
to read the old, original, unaltered content from the original database file
at the same time that the writer is appending to the write\-ahead log.
In [WAL mode](wal.html), SQLite exhibits "snapshot isolation". When a read transaction
starts, that reader continues to see an unchanging "snapshot" of the database
file as it existed at the moment in time when the read transaction started.
Any write transactions that commit while the read transaction is
active are still invisible to the read transaction, because the reader is
seeing a snapshot of database file from a prior moment in time.




An example: Suppose there are two database connections X and Y. X starts
a read transaction using [BEGIN](lang_transaction.html) followed by one or more [SELECT](lang_select.html) statements.
Then Y comes along and runs an [UPDATE](lang_update.html) statement to modify the database.
X can subsequently do a [SELECT](lang_select.html) against the records that Y modified but
X will see the older unmodified entries because Y's changes are all
invisible to X while X is holding a read transaction. If X wants to see
the changes that Y made, then X must end its read transaction and
start a new one (by running [COMMIT](lang_transaction.html) followed by another [BEGIN](lang_transaction.html).)




Another example: X starts a read transaction using [BEGIN](lang_transaction.html) and [SELECT](lang_select.html), then
Y makes a changes to the database using [UPDATE](lang_update.html). Then X tries to make a
change to the database using [UPDATE](lang_update.html). The attempt by X to escalate its
transaction from a read transaction to a write transaction fails with an
[SQLITE\_BUSY\_SNAPSHOT](rescode.html#busy_snapshot) error because the snapshot of the database being
viewed by X is no longer the latest version of the database. If X were
allowed to write, it would fork the history of the database file, which is
something SQLite does not support. In order for X to write to the database,
it must first release its snapshot (using [ROLLBACK](lang_transaction.html) for example) then
start a new transaction with a subsequent [BEGIN](lang_transaction.html).




If X starts a transaction that will initially only read but X knows it
will eventually want to write and does not want to be troubled with
possible SQLITE\_BUSY\_SNAPSHOT errors that arise because another connection
jumped ahead of it in line, then X can issue [BEGIN IMMEDIATE](lang_transaction.html#immediate) to start
its transaction instead of just an ordinary BEGIN. The [BEGIN IMMEDIATE](lang_transaction.html#immediate)
command goes ahead and starts a write transaction, and thus blocks all
other writers. If the [BEGIN IMMEDIATE](lang_transaction.html#immediate) operation succeeds, then no
subsequent operations in that transaction will ever fail with an
[SQLITE\_BUSY](rescode.html#busy) error.



