## No Isolation Between Operations On The Same Database Connection


SQLite provides isolation between operations in separate database
connections. However, there is no isolation between operations that
occur within the same database connection.


In other words, if X begins a write transaction using [BEGIN IMMEDIATE](lang_transaction.html#immediate)
then issues one or more [UPDATE](lang_update.html), [DELETE](lang_delete.html), and/or [INSERT](lang_insert.html)
statements, then those changes are visible to subsequent [SELECT](lang_select.html) statements
that are evaluated in database connection X. [SELECT](lang_select.html) statements on
a different database connection Y will show no changes until the X
transaction commits. But [SELECT](lang_select.html) statements in X will show the changes
prior to the commit.


Within a single database connection X, a SELECT statement always sees all
changes to the database that are completed prior to the start of the SELECT
statement, whether committed or uncommitted. And the SELECT statement
obviously does not see any changes that occur after the SELECT statement
completes. But what about changes that occur while the SELECT statement
is running? What if a SELECT statement is started and the [sqlite3\_step()](c3ref/step.html)
interface steps through roughly half of its output, then some [UPDATE](lang_update.html)
statements are run by the application that modify the table that the
SELECT statement is reading, then more calls to [sqlite3\_step()](c3ref/step.html) are made
to finish out the SELECT statement? Will the later steps of the SELECT
statement see the changes made by the UPDATE or not? The answer is that
this behavior is undefined. In particular, whether or not the SELECT statement
sees the concurrent changes depends on which release of SQLite is
running, the schema of the database file, whether or not [ANALYZE](lang_analyze.html) has
been run, and the details of the query. In some cases, it might depend
on the content of the database file, too. There is no good way to know whether
or not a SELECT statement will see changes that were made to the database
by the same database connection after the SELECT statement was started.
And hence, developers should diligently avoid writing applications
that make assumptions about what will occur in that circumstance.



If an application issues a SELECT statement on a single table like
"*SELECT rowid, \* FROM table WHERE ...*" and starts stepping through 
the output of that statement using [sqlite3\_step()](c3ref/step.html) and examining each
row, then it is safe for the application to delete the current row or
any prior row using "DELETE FROM table WHERE rowid\=?". It is also safe
(in the sense that it will not harm the database) for the application to
delete a row that expected to appear later in the query but has not
appeared yet. If a future row is deleted, however, it might happen that
the row turns up after a subsequent sqlite3\_step(), even after it has
allegedly been deleted. Or it might not. That behavior is undefined.
The application can 
also INSERT new rows into the table while the SELECT statement is 
running, but whether or not the new rows appear
in subsequent sqlite3\_step()s of the query is undefined. And the application
can UPDATE the current row or any prior row, though doing so might cause 
that row to reappear in a subsequent sqlite3\_step(). As long as the 
application is prepared to deal with these ambiguities, the operations 
themselves are safe and will not harm the database file.



For the purposes of the previous two paragraphs, two database connections
that have the same [shared cache](sharedcache.html) and which have enabled
[PRAGMA read\_uncommitted](pragma.html#pragma_read_uncommitted) are considered to be the same database connection.



