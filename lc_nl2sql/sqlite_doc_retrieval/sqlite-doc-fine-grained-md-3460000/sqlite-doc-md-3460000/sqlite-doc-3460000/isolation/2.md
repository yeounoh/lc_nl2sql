## Isolation Between Database Connections



If the same database is being read and written using two different
[database connections](c3ref/sqlite3.html) (two different [sqlite3](c3ref/sqlite3.html) objects returned by
separate calls to [sqlite3\_open()](c3ref/open.html)) and the two database connections
do not have a [shared cache](sharedcache.html), then the reader is only able to
see complete committed transactions from the writer. Partial changes
by the writer that have not been committed are invisible to the reader.
This is true regardless of whether the two database connections are in
the same thread, in different threads of the same process, or in
different processes. This
is the usual and expected behavior for SQL database systems.




The previous paragraph is also true (separate database connections are
isolated from one another) in [shared cache mode](sharedcache.html) as long as the
[read\_uncommitted pragma](pragma.html#pragma_read_uncommitted) remains turned off. The [read\_uncommitted pragma](pragma.html#pragma_read_uncommitted)
is off by default and so if the application does nothing to turn it on, 
it will remain off. Hence, unless the [read\_uncommitted pragma](pragma.html#pragma_read_uncommitted) is used
to change the default behavior, changes made by one database connection
are invisible to readers on a different database connection sharing the
same cache until the writer commits its transaction.




If two database connections share the same cache and the reader has 
enabled the [read\_uncommitted pragma](pragma.html#pragma_read_uncommitted), then the reader will be able to
see changes made by the writer before the writer transaction commits.
The combined use of [shared cache mode](sharedcache.html) and the [read\_uncommitted pragma](pragma.html#pragma_read_uncommitted) 
is the only way that one database connection can see uncommitted changes
on a different database connection. In all other circumstances, separate
database connections are completely isolated from one another.



Except in the case of [shared cache](sharedcache.html) database connections with
[PRAGMA read\_uncommitted](pragma.html#pragma_read_uncommitted) turned on, all transactions in SQLite show
"serializable" isolation. SQLite implements serializable transactions
by actually serializing the writes. There can only be a single writer
at a time to an SQLite database. There can be multiple database connections
open at the same time, and all of those database connections can write
to the database file, but they have to take turns. SQLite uses locks
to serialize the writes automatically; this is not something that
the applications using SQLite need to worry about.


