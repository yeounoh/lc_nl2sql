# 6\. Statically Linking A Run\-Time Loadable Extension


The exact same source code can be used for both a run\-time loadable
shared library or DLL and as a module that is statically linked with your
application. This provides flexibility and allows you to reuse the same
code in different ways.


To statically link your extension, simply add the \-DSQLITE\_CORE
compile\-time option. The SQLITE\_CORE macro causes the SQLITE\_EXTENSION\_INIT1
and SQLITE\_EXTENSION\_INIT2 macros to become no\-ops. Then modify your
application to invoke the entry point directly, passing in a NULL pointer
as the third "pApi" parameter.


It is particularly important to use an entry point name that is
based on the extension filename, rather than the generic
"sqlite3\_extension\_init" entry point name, if you will be statically
linking two or more extensions. If you use the generic name, there
will be multiple definitions of the same symbol and the link will fail.


If you will be opening multiple database connections in your application,
rather than invoking the extension entry points for each database
connection separately, you might want to consider using the
[sqlite3\_auto\_extension()](c3ref/auto_extension.html) interface to register your extensions and
to cause them to be automatically started as each database connection
is opened. You only have to register each extension once, and you can
do so near the beginning of your main() routine. Using the
[sqlite3\_auto\_extension()](c3ref/auto_extension.html) interface to register your extensions makes
your extensions work as if they were built into the core SQLite \- they
automatically exist whenever you open a new database connection
without needing to be initialized. Just be sure to complete any
configuration you need to accomplish using [sqlite3\_config()](c3ref/config.html) before
registering your extensions, since the [sqlite3\_auto\_extension()](c3ref/auto_extension.html)
interface implicitly calls [sqlite3\_initialize()](c3ref/initialize.html).


