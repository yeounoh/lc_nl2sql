## 7\.0 Transaction Control At The SQL Level



The changes to locking and concurrency control in SQLite version 3 also
introduce some subtle changes in the way transactions work at the SQL
language level.
By default, SQLite version 3 operates in *autocommit* mode.
In autocommit mode,
all changes to the database are committed as soon as all operations associated
with the current database connection complete.


The SQL command "BEGIN TRANSACTION" (the TRANSACTION keyword
is optional) is used to take SQLite out of autocommit mode.
Note that the BEGIN command does not acquire any locks on the database.
After a BEGIN command, a SHARED lock will be acquired when the first
SELECT statement is executed. A RESERVED lock will be acquired when
the first INSERT, UPDATE, or DELETE statement is executed. No EXCLUSIVE
lock is acquired until either the memory cache fills up and must
be spilled to disk or until the transaction commits. In this way,
the system delays blocking read access to the file until the
last possible moment.



The SQL command "COMMIT" does not actually commit the changes to
disk. It just turns autocommit back on. Then, at the conclusion of
the command, the regular autocommit logic takes over and causes the
actual commit to disk to occur.
The SQL command "ROLLBACK" also operates by turning autocommit back on,
but it also sets a flag that tells the autocommit logic to rollback rather
than commit.


If the SQL COMMIT command turns autocommit on and the autocommit logic
then tries to commit change but fails because some other process is holding
a SHARED lock, then autocommit is turned back off automatically. This
allows the user to retry the COMMIT at a later time after the SHARED lock
has had an opportunity to clear.


*This page last modified on [2024\-04\-08 14:35:46](https://sqlite.org/docsrc/honeypot) UTC* 


