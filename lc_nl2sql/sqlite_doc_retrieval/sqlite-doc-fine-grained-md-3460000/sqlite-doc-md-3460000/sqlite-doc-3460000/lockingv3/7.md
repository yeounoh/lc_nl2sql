## 5\.0 Writing to a database file


To write to a database, a process must first acquire a SHARED lock
as described above (possibly rolling back incomplete changes if there
is a hot journal). 
After a SHARED lock is obtained, a RESERVED lock must be acquired.
The RESERVED lock signals that the process intends to write to the
database at some point in the future. Only one process at a time
can hold a RESERVED lock. But other processes can continue to read
the database while the RESERVED lock is held.



If the process that wants to write is unable to obtain a RESERVED
lock, it must mean that another process already has a RESERVED lock.
In that case, the write attempt fails and returns SQLITE\_BUSY.


After obtaining a RESERVED lock, the process that wants to write
creates a rollback journal. The header of the journal is initialized
with the original size of the database file. Space in the journal header
is also reserved for a super\-journal name, though the super\-journal
name is initially empty.


Before making changes to any page of the database, the process writes
the original content of that page into the rollback journal. Changes
to pages are held in memory at first and are not written to the disk.
The original database file remains unaltered, which means that other
processes can continue to read the database.


Eventually, the writing process will want to update the database
file, either because its memory cache has filled up or because it is
ready to commit its changes. Before this happens, the writer must
make sure no other process is reading the database and that the rollback
journal data is safely on the disk surface so that it can be used to
rollback incomplete changes in the event of a power failure.
The steps are as follows:


1. Make sure all rollback journal data has actually been written to
 the surface of the disk (and is not just being held in the operating
 system's or disk controllers cache) so that if a power failure occurs
 the data will still be there after power is restored.
2. Obtain a PENDING lock and then an EXCLUSIVE lock on the database file.
 If other processes still have SHARED locks, the writer might have
 to wait until those SHARED locks clear before it is able to obtain
 an EXCLUSIVE lock.
3. Write all page modifications currently held in memory out to the
 original database disk file.



If the reason for writing to the database file is because the memory
cache was full, then the writer will not commit right away. Instead,
the writer might continue to make changes to other pages. Before 
subsequent changes are written to the database file, the rollback
journal must be flushed to disk again. Note also that the EXCLUSIVE
lock that the writer obtained in order to write to the database initially
must be held until all changes are committed. That means that no other
processes are able to access the database from the
time the memory cache first spills to disk until the transaction
commits.




When a writer is ready to commit its changes, it executes the following
steps:



1. Obtain an EXCLUSIVE lock on the database file and
 make sure all memory changes have been written to the database file
 using the algorithm of steps 1\-3 above.
2. Flush all database file changes to the disk. Wait for those changes
 to actually be written onto the disk surface.
3. Delete the journal file. (Or if the [PRAGMA journal\_mode](pragma.html#pragma_journal_mode) is TRUNCATE or
 PERSIST, truncate the journal file or zero the header of the journal file,
 respectively.) This is the instant when the changes are
 committed. Prior to deleting the journal file, if a power failure
 or crash occurs, the next process to open the database will see that
 it has a hot journal and will roll the changes back.
 After the journal is deleted, there will no longer be a hot journal
 and the changes will persist.
4. Drop the EXCLUSIVE and PENDING locks from the database file.


As soon as the PENDING lock is released from the database file, other
processes can begin reading the database again. In the current implementation,
the RESERVED lock is also released, but that is not essential for
correct operation.


If a transaction involves multiple databases, then a more complex
commit sequence is used, as follows:


1. Make sure all individual database files have an EXCLUSIVE lock and a
 valid journal.
- Create a super\-journal. The name of the super\-journal is arbitrary.
 (The current implementation appends random suffixes to the name of the
 main database file until it finds a name that does not previously exist.)
 Fill the super\-journal with the names of all the individual journals
 and flush its contents to disk.
- Write the name of the super\-journal into
 all individual journals (in space set aside for that purpose in the
 headers of the individual journals) and flush the contents of the
 individual journals to disk and wait for those changes to reach the
 disk surface.
- Flush all database file changes to the disk. Wait for those changes
 to actually be written onto the disk surface.
- Delete the super\-journal file. This is the instant when the changes are
 committed. Prior to deleting the super\-journal file, if a power failure
 or crash occurs, the individual file journals will be considered hot
 and will be rolled back by the next process that
 attempts to read them. After the super\-journal has been deleted,
 the file journals will no longer be considered hot and the changes
 will persist.
- Delete all individual journal files.
- Drop the EXCLUSIVE and PENDING locks from all database files.



