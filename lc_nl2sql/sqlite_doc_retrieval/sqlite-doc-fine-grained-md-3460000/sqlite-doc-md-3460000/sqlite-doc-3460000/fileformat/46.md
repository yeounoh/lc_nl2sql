## 4\.2\. Checksum Algorithm


The checksum is computed by interpreting the input as
an even number of unsigned 32\-bit integers: x(0\) through x(N).
The 32\-bit integers are big\-endian if the
magic number in the first 4 bytes of the WAL header is 0x377f0683 and
the integers are little\-endian if the magic number is 0x377f0682\.
The checksum values are always stored in the frame header in a
big\-endian format regardless of which byte order is used to compute
the checksum.


The checksum algorithm only works for content which is a multiple of
8 bytes in length. In other words, if the inputs are x(0\) through x(N)
then N must be odd.
The checksum algorithm is as follows:




> ```
>  
> s0 = s1 = 0
> for i from 0 to n-1 step 2:
>    s0 += x(i) + s1;
>    s1 += x(i+1) + s0;
> endfor
> # result in s0 and s1
> 
> ```


The outputs s0 and s1 are both weighted checksums using Fibonacci weights
in reverse order. (The largest Fibonacci weight occurs on the first element
of the sequence being summed.) The s1 value spans all 32\-bit integer
terms of the sequence whereas s0 omits the final term.


