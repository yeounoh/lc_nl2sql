## 1\.6\. B\-tree Pages


The b\-tree algorithm provides key/data storage with unique and
ordered keys on page\-oriented storage devices.
For background information on b\-trees, see
Knuth, The Art Of Computer Programming, Volume 3 "Sorting
and Searching", pages 471\-479\. Two variants of b\-trees are used by
SQLite. "Table b\-trees" use a 64\-bit signed integer key and store
all data in the leaves. "Index b\-trees" use arbitrary keys and store no
data at all.



A b\-tree page is either an interior page or a leaf page.
A leaf page contains keys and in the case of a table b\-tree each
key has associated data. An interior page contains
K keys together with K\+1 pointers to child b\-tree pages.
A "pointer" in an interior b\-tree page is just the 32\-bit 
unsigned integer page number of the child page.




The number of keys on an interior b\-tree page, K,
is almost always at least 2 and is usually much more than 2\.
The only exception is when page 1 is an interior b\-tree page.
Page 1 has 100 fewer bytes of storage space available,
due to the presence of the database header at the beginning of that page,
and so sometimes (rarely) if page 1 is an interior b\-tree page, it can
end up holding just a single key. In all other cases, K is 2 or more.
The upper bound on K is as many keys as will fit on the page. Large keys
on index b\-trees are split up into [overflow pages](fileformat2.html#ovflpgs) so that no single key
uses more than one fourth of the available storage space on the page
and hence every internal page is able to store at least 4 keys.
The integer keys of table b\-trees are never large enough to
require overflow, so key overflow only occurs on index b\-trees.


Define the depth
of a leaf b\-tree to be 1 and the depth of any interior b\-tree to be one
more than the maximum depth of any of its children. In a well\-formed
database, all children of an interior b\-tree have the same depth.


In an interior b\-tree page, the pointers and keys logically alternate 
with a pointer on both ends. (The previous sentence is to be understood
conceptually \- the actual layout of the keys and
pointers within the page is more complicated and will be described in
the sequel.) All keys within the same page are unique and are logically
organized in ascending order from left to right. (Again, this ordering
is logical, not physical. The actual location of keys within the page
is arbitrary.) For any key X, pointers to the left
of a X refer to b\-tree pages on which all keys are less than or equal to X.
Pointers to the right of X refer to pages where all keys are 
greater than X.


Within an interior b\-tree page, each key and the pointer to its
immediate left are combined into a structure called a "cell". The
right\-most pointer is held separately. A leaf b\-tree page has no
pointers, but it still uses the cell structure to hold keys for
index b\-trees or keys and content for table b\-trees. Data is also
contained in the cell.



Every b\-tree page has at most one parent b\-tree page.
A b\-tree page without a parent is called a root page. A root b\-tree page
together with the closure of its children form a complete b\-tree.
It is possible (and in fact rather common) to have a complete b\-tree
that consists of a single page that is both a leaf and the root.
Because there are pointers from parents to children, every page of a
complete b\-tree can be located if only the root page is known. Hence,
b\-trees are identified by their root page number.



A b\-tree page is either a table b\-tree page or an index b\-tree page.
All pages within each complete b\-tree are of the same type: either table
or index. There is one table b\-trees in the database file
for each rowid table in the database schema, including system tables
such as [sqlite\_schema](schematab.html). There is one index b\-tree
in the database file for each index in the schema, including implied indexes
created by uniqueness constraints. There are no b\-trees associated with
[virtual tables](vtab.html). Specific virtual table implementations might make use
of [shadow tables](vtab.html#xshadowname) for storage, but those shadow tables will have separate
entries in the database schema. [WITHOUT ROWID](withoutrowid.html) tables use index b\-trees
rather than a table b\-trees, so there is one
index b\-tree in the database file for each [WITHOUT ROWID](withoutrowid.html) table.
The b\-tree corresponding to the sqlite\_schema table is always a table
b\-tree and always has a root page of 1\.
The sqlite\_schema table contains the root page number for every other 
table and index in the database file.


Each entry in a table b\-tree consists of a 64\-bit signed integer key
and up to 2147483647 bytes of arbitrary data. (The key of a table b\-tree
corresponds to the [rowid](lang_createtable.html#rowid) of the SQL table that the b\-tree implements.)
Interior table b\-trees hold only keys and pointers to children.
All data is contained in the table b\-tree leaves.


Each entry in an index b\-tree consists of an arbitrary key of up
to 2147483647 bytes in length and no data.



Define the "payload" of a cell to be the arbitrary length section
of the cell. For an index b\-tree, the key is always arbitrary in length
and hence the payload is the key. There are no arbitrary length elements
in the cells of interior table b\-tree pages and so those cells have no
payload. Table b\-tree leaf pages contain arbitrary length content and
so for cells on those pages the payload is the content.


When the size of payload for a cell exceeds a certain threshold (to
be defined later) then only the first few bytes of the payload
are stored on the b\-tree page and the balance is stored in a linked list
of content overflow pages.


A b\-tree page is divided into regions in the following order:



1. The 100\-byte database file header (found on page 1 only)
2. The 8 or 12 byte b\-tree page header
3. The cell pointer array
4. Unallocated space
5. The cell content area
6. The reserved region.


The 100\-byte database file header is found only on page 1, which is
always a table b\-tree page. All other b\-tree pages in the database file
omit this 100\-byte header.


The reserved region is an area of unused space at the end of every
page (except the locking page) that extensions can use to hold per\-page
information. The size of the reserved region is determined by the one\-byte
unsigned integer found at an offset of 20 into the database file header.
The size of the reserved region is usually zero.


The b\-tree page header is 8 bytes in size for leaf pages and 12
bytes for interior pages. All multibyte values in the page header
are big\-endian.
The b\-tree page header is composed of the following fields:



*B\-tree Page Header Format*  



| Offset | Size | Description |
| --- | --- | --- |
| 0 | 1 | The one\-byte flag at offset 0 indicating the b\-tree page type.* A value of 2 (0x02\) means the page is an interior index b\-tree page. * A value of 5 (0x05\) means the page is an interior table b\-tree page. * A value of 10 (0x0a) means the page is a leaf index b\-tree page. * A value of 13 (0x0d) means the page is a leaf table b\-tree page.   Any other value for the b\-tree page type is an error. |
| 1 | 2 | The two\-byte integer at offset 1 gives the start of the first freeblock on the page, or is zero if there are no freeblocks. |
| 3 | 2 | The two\-byte integer at offset 3 gives the number of cells on the page. |
| 5 | 2 | The two\-byte integer at offset 5 designates the start of the cell content area. A zero value for this integer is interpreted as 65536\. |
| 7 | 1 | The one\-byte integer at offset 7 gives the number of fragmented free bytes within the cell content area. |
| 8 | 4 | The four\-byte page number at offset 8 is the right\-most pointer. This value appears in the header of interior b\-tree pages only and is omitted from all other pages. |


The cell pointer array of a b\-tree page immediately follows the b\-tree
page header. Let K be the number of cells on the btree. The cell pointer
array consists of K 2\-byte integer offsets to the cell contents. The
cell pointers are arranged in key order with left\-most cell (the cell with the
smallest key) first and the right\-most cell (the cell with the largest
key) last.


Cell content is stored in the cell content region of the b\-tree page.
SQLite strives to place cells as far toward the end of the b\-tree page as
it can, in order to leave space for future growth of the cell pointer array.
The area in between the last cell pointer array entry and the beginning of
the first cell is the unallocated region.



If a page contains no cells (which is only possible for a root page
of a table that contains no rows) then the offset to the
cell content area will equal the page size minus the bytes of reserved space.
If the database uses a 65536\-byte page size and the reserved space is zero
(the usual value for reserved space) then the cell content offset of an
empty page wants to be 65536\. 
However, that integer is too large to be stored in a
2\-byte unsigned integer, so a value of 0 is used in its place.



A freeblock is a structure used to identify unallocated space within
a b\-tree page. Freeblocks are organized as a chain. The first 2 bytes of
a freeblock are a big\-endian integer which is the offset in the b\-tree page
of the next freeblock in the chain, or zero if the freeblock is the last on
the chain. The third and fourth bytes of each freeblock form
a big\-endian integer which is the size of the freeblock in bytes, including
the 4\-byte header. Freeblocks are always connected in order 
of increasing offset. The second field of the b\-tree page header is the
offset of the first freeblock, or zero if there are no freeblocks on the
page. In a well\-formed b\-tree page, there will always be at least one cell
before the first freeblock.


A freeblock requires at least 4 bytes of space. If there is an isolated
group of 1, 2, or 3 unused bytes within the cell content area, those bytes
comprise a fragment. The total number of bytes in all fragments is stored
in the fifth field of the b\-tree page header. In a well\-formed b\-tree page,
the total number of bytes in fragments may not exceed 60\.


The total amount of free space on a b\-tree page consists of the size
of the unallocated region plus the total size of all freeblocks plus the
number of fragmented free bytes. SQLite may from time to time reorganize
a b\-tree page so that there are no freeblocks or fragment bytes, all
unused bytes are contained in the unallocated space region, and all
cells are packed tightly at the end of the page. This is called 
"defragmenting" the b\-tree page.



A variable\-length integer or "varint" is a static Huffman encoding
of 64\-bit twos\-complement integers that uses less space for small positive 
values. 
A varint is between 1 and 9 bytes in length. The varint consists of either
zero or more bytes which have the high\-order bit set followed by a single byte
with the high\-order bit clear, or nine bytes, whichever is shorter.
The lower seven bits of each of the first eight bytes and all 8 bits of
the ninth byte are used to reconstruct the 64\-bit twos\-complement integer.
Varints are big\-endian: bits taken from the earlier byte of the varint
are more significant than bits taken from the later bytes. 


The format of a cell depends on which kind of b\-tree page the cell
appears on. The following table shows the elements of a cell, in
order of appearance, for the various b\-tree page types.




Table B\-Tree Leaf Cell (header 0x0d):


* A varint which is the total number of bytes of payload, including any
overflow
* A varint which is the integer key, a.k.a. "[rowid](lang_createtable.html#rowid)"
* The initial portion of the payload that does not spill to overflow
pages.
* A 4\-byte big\-endian integer page number for the first page of the
overflow page list \- omitted if all payload fits on the b\-tree page.

Table B\-Tree Interior Cell (header 0x05\):


* A 4\-byte big\-endian page number which is the left child pointer.
* A varint which is the integer key

Index B\-Tree Leaf Cell (header 0x0a):


* A varint which is the total number of bytes of key payload, including any
overflow
* The initial portion of the payload that does not spill to overflow
pages.
* A 4\-byte big\-endian integer page number for the first page of the
overflow page list \- omitted if all payload fits on the b\-tree page.

Index B\-Tree Interior Cell (header 0x02\):


* A 4\-byte big\-endian page number which is the left child pointer.
* A varint which is the total number of bytes of key payload, including any
overflow
* The initial portion of the payload that does not spill to overflow
pages.
* A 4\-byte big\-endian integer page number for the first page of the
overflow page list \- omitted if all payload fits on the b\-tree page.


The information above can be recast into a table format as follows:




*B\-tree Cell Format*


| Datatype | Appears in... | | | | Description |
| --- | --- | --- | --- | --- | --- |
| Table Leaf (0x0d) | Table Interior (0x05\) | Index Leaf (0x0a) | Index Interior (0x02\) |
| 4\-byte integer |  | ✔ |  | ✔ | Page number of left child |
| varint | ✔ |  | ✔ | ✔ | Number of bytes of payload |
| varint | ✔ | ✔ |  |  | Rowid |
| byte array | ✔ |  | ✔ | ✔ | Payload |
| 4\-byte integer | ✔ |  | ✔ | ✔ | Page number of first overflow page |


The amount of payload that spills onto overflow pages also depends on
the page type. For the following computations, let U be the usable size
of a database page, the total page size less the reserved space at the
end of each page. And let P be the payload size. In the following,
symbol X represents the maximum amount of payload that can be stored directly
on the b\-tree page without spilling onto an overflow page and symbol M
represents the minimum amount of payload that must be stored on the btree
page before spilling is allowed.




Table B\-Tree Leaf Cell:



Let X be U\-35\. If the payload size P is less than or equal to X then
the entire payload is stored on the b\-tree leaf page.
Let M be ((U\-12\)\*32/255\)\-23 and let K be M\+((P\-M)%(U\-4\)).
If P is greater than X
then the number of bytes stored on the table b\-tree leaf page is K
if K is less or equal to X or M otherwise.
The number of bytes stored on the leaf page is never less than M.



Table B\-Tree Interior Cell:



Interior pages of table b\-trees have no payload and so there is never
any payload to spill.



Index B\-Tree Leaf Or Interior Cell:



Let X be ((U\-12\)\*64/255\)\-23\. If the payload size P is less than
or equal to X then the entire payload is stored on the b\-tree page.
Let M be ((U\-12\)\*32/255\)\-23 and let K be M\+((P\-M)%(U\-4\)).
If P is greater than X then the number
of bytes stored on the index b\-tree page is K if K is less than or
equal to X or M otherwise.
The number of bytes stored on the index page is never less than M.




Here is an alternative description of the same computation:



* X is U\-35 for table btree leaf pages or
 ((U\-12\)\*64/255\)\-23 for index pages.
* M is always ((U\-12\)\*32/255\)\-23\.
* Let K be M\+((P\-M)%(U\-4\)).
* If P\<\=X then all P bytes of payload are stored directly on the 
 btree page without overflow.
* If P\>X and K\<\=X then the first K bytes of P are stored on the 
 btree page and the remaining P\-K bytes are stored on overflow pages.
* If P\>X and K\>X then the first M bytes of P are stored on the
 btree page and the remaining P\-M bytes are stored on overflow pages.


The overflow thresholds are designed to give a minimum fanout of
4 for index b\-trees and to make sure enough of the payload
is on the b\-tree page that the record header can usually be accessed
without consulting an overflow page. In hindsight, the designer of
the SQLite b\-tree logic realized that these thresholds could have been
made much simpler. However, the computations cannot be changed
without resulting in an incompatible file format. And the current computations
work well, even if they are a little complex.



