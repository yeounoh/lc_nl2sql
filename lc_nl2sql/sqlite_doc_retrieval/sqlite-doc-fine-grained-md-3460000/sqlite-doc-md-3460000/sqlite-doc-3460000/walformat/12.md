## 2\.2\. WAL\-Index Hash Tables


The hash tables in the shm file are designed to answer the
following question quickly:




> *FindFrame(P,M):
> Given a page number P and a maximum WAL frame index M,
> return the largest WAL frame index for page P that does not exceed M, 
> or return NULL if there are no frames for page P that do not exceed M.*



Let the datatypes "u8", "u16", and "u32" mean unsigned integers of
length 8, 16, and 32 bits, respectively. Then, the first 32768\-byte unit
of the shm file is organized as follows:




> ```
> 
> u8 aWalIndexHeader[136];
> u32 aPgno[4062];
> u16 aHash[8192];
> 
> ```


The second and all subsequent 32768\-byte units of the shm file are
like this:




> ```
> 
> u32 aPgno[4096];
> u16 aHash[8192];
> 
> ```


Collectively, the aPgno entries record the database page number stored
in all frames of the WAL file. The aPgno\[0] entry on the first hash table
records the database page number stored in the very first frame in the WAL 
file. The aPgno\[i] entry from the first hash table is the database page number
for the i\-th frame in the WAL file. The aPgno\[k] entry for the second
hash table is the database page number for the (k\+4062\)\-th frame in the
WAL file. The aPgno\[k] entry for the n\-th 32768\-byte hash table in the
shm file (for n\>1\) holds the database page number stored in the
(k\+4062\+4096\*(n\-2\))\-th frame of the WAL file.



Here is a slightly different way to describe the aPgno values:
If you think of all aPgno values as a contiguous array, then
the database page number stored in the i\-th frame of the WAL file
is stored in aPgno\[i]. Of course, aPgno is not a contiguous array.
The first 4062 entries are on the first 32768\-byte unit of the shm
file and subsequent values are in 4096 entry chunks in later units
of the shm file.



One way to compute FindFrame(P,M) would be to scan the aPgno
array starting with the M\-th entry and working backwards towards
the beginning and return J where aPgno\[J]\=\=P. Such an algorithm would
work, and it would be faster than searching the whole WAL file for
the latest frame with page number P. But the search can be made
much faster still by using the aHash structure.



A database page number P is mapped into a hash value
using the following hash function:




> h \= (P \* 383\)%8192


This function maps every page number into an integer between 0
and 8191 inclusive. The aHash field of each 32768\-byte shm file unit
maps P values into indexes of the aPgno field of the same unit as
follows:



1. Compute the hash value: h \= P \* 383
2. Let X be the largest set of consecutive integers {h, h\+1, h\+2, ..., h\+N}
 such that for every j in X, aPgno\[j%8192]!\=0\. The X set will be empty
 if aPgno\[h%8192]\=\=0\. The X set is easily computed by starting with
 the value h%8192, and adding h%8192 to X and incrementing h until
 encountering the first aPgno\[h%8192] entry that is zero.
3. The set X contains the index in aPgno of every entry in the current
 32768\-byte unit of the shm file that might possible be a solution
 to the FindFrame(P,M) function. Each of these entries must be
 checked separately to ensure that the aPgno value is P and that the
 frame number does not exceed M. The largest frame number that passes
 those two tests is the answer.


Each entry in the aPgno array has a single corresponding entry
in the aHash array. There are more available slots in aHash than
there are in aPgno. The unused slots in aHash are filled with zero.
And since there are guaranteed to be unused slots in aHash, that means
the loop that computes X is guaranteed to terminate. The expected size
of X is less than 2\. The worst case is that X will be the same as the
number of entries in aPgno, in which case the algorithm runs at about
the same speed as a linear scan of aPgno. But that worst case performance
is exceedingly rare. Usually, the size of X will be small and the use
of the aHash array allows one to compute FindFrame(P,M) much faster.



Here is an alternative way of describing the hash look\-up algorithm:
Start with h \= (P \* 383\)%8192 and look at aHash\[h] and subsequent entries,
wrapping around to zero when h reaches 8192, until finding an entry with
aHash\[h]\=\=0\. All aPgno entries having a page number of P will have an
index that is one of the aHash\[h] values thusly computed.
But not all the computed aHash\[h] values will
meet the matching criteria, so you must check them independently. The
speed advantage comes about because normally this set of h values is
very small.



Note that each 32768\-byte unit of the shm file has its own aHash and
aPgno arrays. The aHash array for a single unit is only helpful in finding
aPgno entries in that same unit. The overall FindFrame(P,M) function
needs to do hash lookups beginning with the latest unit and working
backwards to the oldest unit until it finds an answer.



