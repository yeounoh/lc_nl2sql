### 2\.3\.2\. Operations that require locks and which locks those operations use


* **Transition into and out of WAL\-mode**


The SQLITE\_LOCK\_EXCLUSIVE lock must be held by a connection that wants
to transition into our out of WAL mode.
Transitioning into WAL mode is, therefore, just like any other write
transaction, since every write transaction in rollback mode requires
the SQLITE\_LOCK\_EXCLUSIVE lock.
If the database file is already in WAL mode (hence if the desire it to change
it back into rollback mode) and if there are two
or more connections to the database, then each of these connections will
be holding an SQLITE\_LOCK\_SHARED lock. That means that the
SQLITE\_LOCK\_EXCLUSIVE cannot be obtained, and the transition out of
WAL mode will not be allowed. This prevents one connection from deleting
WAL mode out from under another. It also means that the only way to move
a database from WAL mode into rollback mode is to close all but one
connection to the database.
* **Close a connection to a WAL mode database**


When a database connection closes (via [sqlite3\_close()](c3ref/close.html) or
[sqlite3\_close\_v2()](c3ref/close.html)), an attempt is made to acquire
SQLITE\_LOCK\_EXCLUSIVE. If this attempt is successful, that means
the connection that is closing is the last connection to the database.
In that case, it is desirable to clean up the WAL and WAL\-index files,
so the closing connection runs a [checkpoint](wal.html#ckpt) (while holding
SQLITE\_LOCK\_EXCLUSIVE) and the deletes both the WAL and WAL\-index files.
The SQLITE\_LOCK\_EXCLUSIVE is not released until after both the
WAL and WAL\-index files have been deleted.



If the application invokes
[sqlite3\_file\_control](c3ref/file_control.html)([SQLITE\_FCNTL\_PERSIST\_WAL](c3ref/c_fcntl_begin_atomic_write.html#sqlitefcntlpersistwal)) on the database
connection prior to closing, then the final checkpoint is still
run but the WAL and WAL\-index files are
not deleted as they normally would be.
This leaves the database in a state that allows other processes
without write permission on the database, WAL, or WAL\-index files
to open the database read\-only.
If the WAL and WAL\-index files are missing, then a process that
lacks permission to create and initialize those files will not be
able to open the database, unless the database is designated
as immutable using the [immutable query parameter](uri.html#uriimmutable).
* **Reconstruct the global shared WAL\-index during [recovery](walformat.html#recovery)**


All of the WAL\-index locks, except for WAL\_READ\_LOCK(0\),
are held exclusively while reconstructing the global shared WAL\-index
during [recovery](walformat.html#recovery).
* **Append a new transaction to the end of the WAL**


An exclusive lock is held on WAL\_WRITE\_LOCK while adding new
frame onto the end of a WAL file.
* **Read content from the database and WAL as part of a transaction**
* **Run a checkpoint**
* **Reset the WAL file**


A [WAL reset](fileformat2.html#walreset) means to rewind the WAL and start adding new frames
at the beginning. This occurs while appending new frames to a WAL
that has [mxFrame](walformat.html#mxframe) equal to [nBackfill](walformat.html#nbackfill) and which has no locks on
WAL\_READ\_LOCK(1\) through WAL\_READ\_LOCK(4\). The WAL\_WRITE\_LOCK is
held.



