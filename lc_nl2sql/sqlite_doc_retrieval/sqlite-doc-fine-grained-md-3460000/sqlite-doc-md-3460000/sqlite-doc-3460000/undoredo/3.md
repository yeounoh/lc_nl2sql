## Capture Changes Using Triggers



The core idea is to create a special table (named "UNDOLOG" in the example)
that holds information needed to undo/redo changes to the database. 
For each class (table) in the database that wants to participate in 
the undo/redo, triggers are created that cause entries to be made in 
the UNDOLOG table for each DELETE, INSERT, and UPDATE of the participating
class.
The UNDOLOG entries consist of ordinary SQL statements the can be
played back to reverse the changes.


For example, suppose you wanted undo/redo on a class (table)
that looks like this:


> ```
> 
> CREATE TABLE ex1(a,b,c);
> 
> ```



Triggers to record changes to table EX1 might look like this:


> ```
> 
> CREATE TEMP TRIGGER ex1_it AFTER INSERT ON ex1 BEGIN
>   INSERT INTO undolog VALUES(NULL,'DELETE FROM ex1 WHERE rowid='||new.rowid);
> END;
> CREATE TEMP TRIGGER ex1_ut AFTER UPDATE ON ex1 BEGIN
>   INSERT INTO undolog VALUES(NULL,'UPDATE ex1
>      SET a='||quote(old.a)||',b='||quote(old.b)||',c='||quote(old.c)||'
>    WHERE rowid='||old.rowid);
> END;
> CREATE TEMP TRIGGER ex1_dt BEFORE DELETE ON ex1 BEGIN
>   INSERT INTO undolog VALUES(NULL,'INSERT INTO ex1(rowid,a,b,c)
>     VALUES('||old.rowid||','||quote(old.a)||','||quote(old.b)||
>            ','||quote(old.c)||')');
> END;
> 
> ```



After each INSERT on ex1, the ex1\_it trigger constructs text of a 
DELETE statement that will undo the INSERT. The ex1\_ut trigger constructs 
an UPDATE statement that will undo the effects of an UPDATE. 
And the ex1\_dt trigger constructs a statement that will undo the 
effects of a DELETE.


Note the use of the [quote() SQL function](lang_corefunc.html#quote) in these triggers.
The quote() function converts its argument into a form 
that is appropriate for inclusion in an SQL statement. Numeric values 
come through unchanged. Single quotes are added before and after 
strings and any internal single quotes are escaped. BLOB values
are rendered using SQL\-standard hexadecimal BLOB notation. The
use of the quote() function ensures that the SQL statements used to
undo and redo are always safe from SQL injection.

