## 1\.7\.  Covering Indexes



The "price of California oranges" query was made more efficient through
the use of a two\-column index. But SQLite can do even better with a
three\-column index that also includes the "price" column:





| ```  CREATE INDEX Idx4 ON FruitsForSale(fruit, state, price);  ``` |
| --- |




![figure 13](images/qp/idx4.gif)  

Figure 13: A Covering Index




This new index contains all the columns of the original FruitsForSale table that
are used by the query \- both the search terms and the output. We call
this a "covering index". Because all of the information needed is in
the covering index, SQLite never needs to consult the original table
in order to find the price.





| ```  SELECT price FROM fruitsforsale WHERE fruit='Orange' AND state='CA';  ``` |
| --- |




![figure 14](images/qp/idx4lu1.gif)  

Figure 14: Query Using A Covering Index




Hence, by adding extra "output" columns onto the end of an index, one
can avoid having to reference the original table and thereby
cut the number of binary searches for a query in half. This is a
constant\-factor improvement in performance (roughly a doubling of
the speed). But on the other hand, it is also just a refinement;
A two\-fold performance increase is not nearly as dramatic as the
one\-million\-fold increase seen when the table was first indexed.
And for most queries, the difference between 1 microsecond and
2 microseconds is unlikely to be noticed.




