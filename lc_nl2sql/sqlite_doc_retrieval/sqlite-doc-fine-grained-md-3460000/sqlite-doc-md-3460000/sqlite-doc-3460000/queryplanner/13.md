## 2\.2\.  Sorting By Index



Of course, ordering the output of a query by rowid is seldom useful.
Usually one wants to order the output by some other column.




If an index is available on the ORDER BY column, that index can be used
for sorting. Consider the request for all items sorted by "fruit":





| ```  SELECT * FROM fruitsforsale ORDER BY fruit;  ``` |
| --- |




![figure 18](images/qp/obfruitidx1.gif)  

Figure 18: Sorting With An Index




The Idx1 index is scanned from top to bottom (or from bottom to top if
"ORDER BY fruit DESC" is used) in order to find the rowids for each item
in order by fruit. Then for each rowid, a binary search is done to lookup
and output that row. In this way, the output appears in the requested order
without the need to gather the entire output and sort it using a separate step.




But does this really save time? The number of steps in the 
[original indexless sort](#fig16) is proportional to NlogN since
that is how much time it takes to sort N rows. But when we use Idx1 as
shown here, we have to do N rowid lookups which take logN time each, so
the total time of NlogN is the same!




SQLite uses a cost\-based query planner. When there are two or more ways
of solving the same query, SQLite tries to estimate the total amount of
time needed to run the query using each plan, and then uses the plan with
the lowest estimated cost. A cost is computed mostly from the estimated
time, and so this case could go either way depending on the table size and
what WHERE clause constraints were available, and so forth. But generally
speaking, the indexed sort would probably be chosen, if for no other
reason, because it does not need to accumulate the entire result set in
temporary storage before sorting and thus uses much less temporary storage.



