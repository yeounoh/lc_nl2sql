## 1\.4\.  Multiple Result Rows



In the previous query the fruit\='Peach' constraint narrowed the result
down to a single row. But the same technique works even if multiple
rows are obtained. Suppose we looked up the price of Oranges instead of
Peaches:





| ```  SELECT price FROM fruitsforsale WHERE fruit='Orange'  ``` |
| --- |




![figure 6](images/qp/idx1lu2.gif)  

Figure 6: Indexed Lookup For The Price Of Oranges




In this case, SQLite still does a single binary search to find the first
entry of the index where fruit\='Orange'. Then it extracts the rowid from
the index and uses that rowid to lookup the original table entry via
binary search and output the price from the original table. But instead
of quitting, the database engine then advances to the next row of index
to repeat the process for next fruit\='Orange' entry. Advancing to the
next row of an index (or table) is much less costly than doing a binary
search since the next row is often located on the same database page as
the current row. In fact, the cost of advancing to the next row is so
cheap in comparison to a binary search that we usually ignore it. So
our estimate for the total cost of this query is 3 binary searches.
If the number of rows of output is K and the number of rows in the table
is N, then in general the cost of doing the query is proportional
to (K\+1\)\*logN.



