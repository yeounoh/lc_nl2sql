## 3\.3\.  Partial Sorting Using An Index (a.k.a. Block Sorting)



Sometimes only part of an ORDER BY clause can be satisfied using indexes.
Consider, for example, the following query:





| ```  SELECT * FROM fruitforsale ORDER BY fruit, price  ``` |
| --- |



If the covering index is used for the scan, the "fruit" column will appear
naturally in the correct order, but when there are two or more rows with
the same fruit, the price might be out of order. When this occurs, SQLite
does many small sorts, one sort for each distinct value of fruit, rather
than one large sort. Figure 22 below illustrates the concept.





![figure 22](images/qp/partial-sort.gif)  

Figure 22: Partial Sort By Index




In the example, instead of a single sort of 7 elements, there
are 5 sorts of one\-element each and 1 sort of 2 elements for the
case of fruit\=\='Orange'.




The advantages of doing many smaller sorts instead of a single large sort
are:


1. Multiple small sorts collectively use fewer CPU cycles than a single
 large sort.
2. Each small sort is run independently, meaning that much less information
 needs to be kept in temporary storage at any one time.
3. Those columns of the ORDER BY that are already in the correct order
 due to indexes can be omitted from the sort key, further reducing
 storage requirements and CPU time.
4. Output rows can be returned to the application as each small sort
 completes, and well before the table scan is complete.
5. If a LIMIT clause is present, it might be possible to avoid scanning
 the entire table.


Because of these advantages, SQLite always tries to do a partial sort using an
index even if a complete sort by index is not possible.


