## 1\.6\.  Multi\-Column Indices



To get the maximum performance out of a query with multiple AND\-connected
terms in the WHERE clause, you really want a multi\-column index with
columns for each of the AND terms. In this case we create a new index
on the "fruit" and "state" columns of FruitsForSale:





| ```  CREATE INDEX Idx3 ON FruitsForSale(fruit, state);  ``` |
| --- |




![figure 1](images/qp/idx3.gif)  

Figure 1: A Two\-Column Index




A multi\-column index follows the same pattern as a single\-column index;
the indexed columns are added in front of the rowid. The only difference
is that now multiple columns are added. The left\-most column is the
primary key used for ordering the rows in the index. The second column is
used to break ties in the left\-most column. If there were a third column,
it would be used to break ties for the first two columns. And so forth for
all columns in the index. Because rowid is guaranteed
to be unique, every row of the index will be unique even if all of the
content columns for two rows are the same. That case does not happen
in our sample data, but there is one case (fruit\='Orange') where there
is a tie on the first column which must be broken by the second column.




Given the new multi\-column Idx3 index, it is now possible for SQLite
to find the price of California oranges using only 2 binary searches:





| ```  SELECT price FROM fruitsforsale WHERE fruit='Orange' AND state='CA'  ``` |
| --- |




![figure 11](images/qp/idx3lu1.gif)  

Figure 11: Lookup Using A Two\-Column Index




With the Idx3 index on both columns that are constrained by the WHERE clause,
SQLite can do a single binary search against Idx3 to find the one rowid
for California oranges, then do a single binary search to find the price
for that item in the original table. There are no dead\-ends and no
wasted binary searches. This is a more efficient query.




Note that Idx3 contains all the same information as the original 
[Idx1](#fig3). And so if we have Idx3, we do not really need Idx1
any more. The "price of peaches" query can be satisfied using Idx3
by simply ignoring the "state" column of Idx3:





| ```  SELECT price FROM fruitsforsale WHERE fruit='Peach'  ``` |
| --- |




![figure 12](images/qp/idx3lu2.gif)  

Figure 12: Single\-Column Lookup On A Multi\-Column Index




Hence, a good rule of thumb is that your database schema should never
contain two indices where one index is a prefix of the other. Drop the
index with fewer columns. SQLite will still be able to do efficient
lookups with the longer index.




