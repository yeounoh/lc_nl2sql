## 1\.3\.  Lookup By Index



The problem with looking up information by rowid is that you probably
do not care what the price of "item 4" is \- you want to know the price
of peaches. And so a rowid lookup is not helpful.




To make the original query more efficient, we can add an index on the
"fruit" column of the "fruitsforsale" table like this:





| ```  CREATE INDEX Idx1 ON fruitsforsale(fruit);  ``` |
| --- |



An index is another table similar to the original "fruitsforsale" table
but with the content (the fruit column in this case) stored in front of the
rowid and with all rows in content order.
[Figure 4](#fig4) gives a logical view of the Idx1 index.
The "fruit" column is the primary key used to order the elements of the
table and the "rowid" is the secondary key used to break the tie when
two or more rows have the same "fruit". In the example, the rowid
has to be used as a tie\-breaker for the "Orange" rows.
Notice that since the rowid
is always unique over all elements of the original table, the composite key
of "fruit" followed by "rowid" will be unique over all elements of the index.





![figure 4](images/qp/idx1.gif)  

Figure 4: An Index On The Fruit Column




This new index can be used to implement a faster algorithm for the
original "Price of Peaches" query.





| ```  SELECT price FROM fruitsforsale WHERE fruit='Peach';  ``` |
| --- |



The query starts by doing a binary search on the Idx1 index for entries
that have fruit\='Peach'. SQLite can do this binary search on the Idx1 index
but not on the original FruitsForSale table because the rows in Idx1 are sorted
by the "fruit" column. Having found a row in the Idx1 index that has
fruit\='Peach', the database engine can extract the rowid for that row.
Then the database engines does a second binary search
on the original FruitsForSale table to find the
original row that contains fruit\='Peach'. 
From the row in the FruitsForSale table,
SQLite can then extract the value of the price column.
This procedure is illustrated by [figure 5](#fig5).





![figure 5](images/qp/idx1lu1.gif)  

Figure 5: Indexed Lookup For The Price Of Peaches




SQLite has to do two binary searches to find the price of peaches using
the method show above. But for a table with a large number of rows, this
is still much faster than doing a full table scan.



