## 1\.5\.  Multiple AND\-Connected WHERE\-Clause Terms



Next, suppose that you want to look up the price of not just any orange,
but specifically California\-grown oranges. The appropriate query would
be as follows:





| ```  SELECT price FROM fruitsforsale WHERE fruit='Orange' AND state='CA'  ``` |
| --- |




![figure 7](images/qp/idx1lu3.gif)  

Figure 7: Indexed Lookup Of California Oranges




One approach to this query is to use the fruit\='Orange' term of the WHERE
clause to find all rows dealing with oranges, then filter those rows
by rejecting any that are from states other than California. This
process is shown by [figure 7](#fig7) above. This is a perfectly
reasonable approach in most cases. Yes, the database engine did have
to do an extra binary search for the Florida orange row that was
later rejected, so it was not as efficient as we might hope, though
for many applications it is efficient enough. 




Suppose that in addition to the index on "fruit" there was also
an index on "state".





| ```  CREATE INDEX Idx2 ON fruitsforsale(state);  ``` |
| --- |




![figure 8](images/qp/idx2.gif)  

Figure 8: Index On The State Column




The "state" index works just like the "fruit" index in that it is a
new table with an extra column in front of the rowid and sorted by
that extra column as the primary key. The only difference is that
in Idx2, the first column is "state" instead of "fruit" as it is with
Idx1\. In our example data set, there is more redundancy in the "state"
column and so they are more duplicate entries. The ties are still
resolved using the rowid.




Using the new Idx2 index on "state", SQLite has another option for
lookup up the price of California oranges: it can look up every row
that contains fruit from California and filter out those rows that
are not oranges.





![figure 9](images/qp/idx2lu1.gif)  

Figure 9: Indexed Lookup Of California Oranges




Using Idx2 instead of Idx1 causes SQLite to examine a different set of
rows, but it gets the same answer in the end (which is very important \-
remember that indices should never change the answer, only help SQLite to
get to the answer more quickly) and it does the same amount of work.
So the Idx2 index did not help performance in this case.




The last two queries take the same amount of time, in our example.
So which index, Idx1 or Idx2, will SQLite choose? If the
[ANALYZE](lang_analyze.html) command has been run on the database, so that SQLite has
had an opportunity to gather statistics about the available indices,
then SQLite will know that the Idx1 index usually narrows the search
down to a single item (our example of fruit\='Orange' is the exception
to this rule) whereas the Idx2 index will normally only narrow the 
search down to two rows. So, if all else is equal, SQLite will
choose Idx1 with the hope of narrowing the search to as small
a number of rows as possible. This choice is only possible because
of the statistics provided by [ANALYZE](lang_analyze.html). If [ANALYZE](lang_analyze.html) has not been
run then the choice of which index to use is arbitrary.



