# 1\. Background



SQLite is a [software library](https://en.wikipedia.org/wiki/Library_(computing))
that translates high\-level disk I/O requests generated by an application
into low\-level I/O operations that
can be carried out by the operating system. The application constructs 
high\-level I/O requests using the
[SQL language](https://en.wikipedia.org/wiki/SQL).
SQLite translates each high\-level SQL statement into a sequence of
many low\-level I/O requests (open a file, read a few bytes from a file,
write a few bytes into a file, etc.) that do the work requested by
the SQL.





An application program could do all its disk I/O by direct calls to
operating system I/O routines
or by using a key/value storage engine like 
[Berkeley DB](https://en.wikipedia.org/wiki/Berkeley_DB) or
[RocksDB](https://en.wikipedia.org/wiki/RocksDB) (to name but two).
But there are advantages to using a higher\-level interface based
on the SQL language.



1. SQL is a very high\-level language.
A few lines of SQL can replace hundreds or thousands of lines of
procedural code. SQL thus reduces
the amount of work needed to develop and maintain the application,
and thereby helps to reduce the number of bugs in the application.
2. SQL and SQLite are 
[transactional](https://en.wikipedia.org/wiki/Database_transaction).
The use of a transactional storage system makes it much easier to
reason about the behavior of the application, and to write applications
that are robust, even in the face of software bugs, hardware faults,
or power losses.
3. SQLite is often
[faster than direct low\-level I/O](fasterthanfs.html).
This is counterintuitive. One would expect that a
high\-level interface such as SQLite would impose a run\-time penalty.
And, theoretically, that is correct. But in practice, SQL\-based
systems such as SQLite do so many behind\-the\-scenes optimizations
that an application developer would never have time to create and
maintain, that the SQL\-based systems end up providing
a net performance gain.


