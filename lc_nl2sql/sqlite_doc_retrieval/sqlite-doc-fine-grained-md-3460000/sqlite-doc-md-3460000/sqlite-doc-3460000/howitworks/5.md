## 2\.2\. Compiling SQLite Programs



When an SQL program is submitted to SQLite, the first step is
to split the source text into "tokens". A token might be:



* A language keyword like "SELECT" or "UPDATE".
* An identifier for a table or column or variable.
* Punctuation characters like "," or "\=\=" or ";".
* Literal values: numeric or string constants.
* Whitespace or comments.



Whitespace and comment tokens are discarded. All other tokens
are fed into an
[LALR(1\) Parser](https://en.wikipedia.org/wiki/LALR_parser)
that analyzes the structure of the input program and generates an
[Abstract Syntax Tree (AST)](https://en.wikipedia.org/wiki/Abstract_syntax_tree)
for the input program.




The parser forwards the AST on to the code generator.
The code generator is the heart of SQLite, and is where most of
the magic happens.
The code generator resolves symbolic names in the AST \- matching
the names of columns and tables in the input SQL into actual
columns and tables of the database. The code generator also does
various transformations on the AST to "optimize" it. Finally
the code generator chooses appropriate algorithms to implement
the operations requested by the AST and constructs bytecode to
carry out those operations.




The bytecode generated by the code generator is called a
"[prepared statement](c3ref/stmt.html)". Translating SQL source text into a
prepared statement is analogous to converting a C\+\+ program
into machine code by invoking gcc or clang. Human\-readable
source text (SQL or C\+\+) goes in, and a machine readable executable
(bytecode or machine code) comes out.



