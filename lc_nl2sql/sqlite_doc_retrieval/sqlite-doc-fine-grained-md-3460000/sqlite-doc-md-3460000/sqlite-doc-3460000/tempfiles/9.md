## 2\.7\. Materializations Of Views And Subqueries


Queries that contain subqueries must sometime evaluate
the subqueries separately and store the results in a temporary
table, then use the content of the temporary table to evaluate
the outer query.
We call this "materializing" the subquery.
The query optimizer in SQLite attempts to avoid materializing,
but sometimes it is not easily avoidable.
The temporary tables created by materialization are each stored
in their own separate temporary file, which is automatically
deleted at the conclusion of the query.
The size of these temporary tables depends on the amount of
data in the materialization of the subquery, of course.




A subquery on the right\-hand side of IN operator must often
be materialized. For example:




> ```
> 
> SELECT * FROM ex1 WHERE ex1.a IN (SELECT b FROM ex2);
> 
> ```



In the query above, the subquery "SELECT b FROM ex2" is evaluated
and its results are stored in a temporary table (actually a temporary
index) that allows one to determine whether or not a value ex2\.b
exists using a simple binary search. Once this table is constructed,
the outer query is run and for each prospective result row a check
is made to see if ex1\.a is contained within the temporary table.
The row is output only if the check is true.




To avoid creating the temporary table, the query might be rewritten
as follows:




> ```
> 
> SELECT * FROM ex1 WHERE EXISTS(SELECT 1 FROM ex2 WHERE ex2.b=ex1.a);
> 
> ```



Recent versions of SQLite ([version 3\.5\.4](releaselog/3_5_4.html) 2007\-12\-14\) and later)
will do this rewrite automatically
if an index exists on the column ex2\.b.




If the right\-hand side of an IN operator can be list of values
as in the following:




> ```
> 
> SELECT * FROM ex1 WHERE a IN (1,2,3);
> 
> ```



List values on the right\-hand side of IN are treated as a 
subquery that must be materialized. In other words, the
previous statement acts as if it were:




> ```
> 
> SELECT * FROM ex1 WHERE a IN (SELECT 1 UNION ALL
>                               SELECT 2 UNION ALL
>                               SELECT 3);
> 
> ```



A temporary index is always used to hold the values of the
right\-hand side of an IN operator when that right\-hand side
is a list of values.




Subqueries might also need to be materialized when they appear
in the FROM clause of a SELECT statement. For example:




> ```
> 
> SELECT * FROM ex1 JOIN (SELECT b FROM ex2) AS t ON t.b=ex1.a;
> 
> ```



Depending on the query, SQLite might need to materialize the 
"(SELECT b FROM ex2\)" subquery into a temporary table, then
perform the join between ex1 and the temporary table. The
query optimizer tries to avoid this by "flattening" the
query. In the previous example the query can be flattened,
and SQLite will automatically transform the query into




> ```
> 
> SELECT ex1.*, ex2.b FROM ex1 JOIN ex2 ON ex2.b=ex1.a;
> 
> ```



More complex queries may or may not be able to employ query
flattening to avoid the temporary table. Whether or not
the query can be flattened depends on such factors as whether
or not the subquery or outer query contain aggregate functions,
ORDER BY or GROUP BY clauses, LIMIT clauses, and so forth.
The rules for when a query can and cannot be flattened are
very complex and are beyond the scope of this document.




