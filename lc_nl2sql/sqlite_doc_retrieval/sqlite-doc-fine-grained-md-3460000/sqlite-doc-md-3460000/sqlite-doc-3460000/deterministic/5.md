# 4\. Application\-defined deterministic functions



By default, [application\-defined SQL functions](appfunc.html) are considered to
be non\-deterministic. However, if the 4th parameter to
[sqlite3\_create\_function\_v2()](c3ref/create_function.html) is OR\-ed with 
[SQLITE\_DETERMINISTIC](c3ref/c_deterministic.html#sqlitedeterministic), then SQLite will treat that function as if it
were deterministic.




Note that if a non\-deterministic function is tagged with
[SQLITE\_DETERMINISTIC](c3ref/c_deterministic.html#sqlitedeterministic) and if that function ends up being used in
the WHERE clause of a [partial index](partialindex.html) or in an
[expression index](expridx.html), then when the function begins to return different
answers, the associated index may become corrupt. If an SQL function
is nearly deterministic (which is to say, if it only rarely changes,
like [sqlite\_version()](lang_corefunc.html#sqlite_version)) and it is used in an index that becomes
corrupt, the corruption can be fixed by running [REINDEX](lang_reindex.html).




The interfaces necessary to construct a function that is sometimes
deterministic and sometimes non\-deterministic depending on their
inputs, such as the built\-in date/time functions, are not published.
Generic [application\-defined SQL functions](appfunc.html) must
be always deterministic or always non\-deterministic.


*This page last modified on [2022\-01\-08 05:02:57](https://sqlite.org/docsrc/honeypot) UTC* 


