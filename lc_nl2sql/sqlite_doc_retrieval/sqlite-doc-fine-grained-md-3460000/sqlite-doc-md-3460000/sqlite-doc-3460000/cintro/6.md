# 6\. Binding Parameters and Reusing Prepared Statements



 In prior discussion, it was assumed that each SQL statement is prepared
 once, evaluated, then destroyed. However, SQLite allows the same
 [prepared statement](c3ref/stmt.html) to be evaluated multiple times. This is accomplished
 using the following routines:



* [sqlite3\_reset()](c3ref/reset.html)
* [sqlite3\_bind()](c3ref/bind_blob.html)



 After a [prepared statement](c3ref/stmt.html) has been evaluated by one or more calls to
 [sqlite3\_step()](c3ref/step.html), it can be reset in order to be evaluated again by a
 call to [sqlite3\_reset()](c3ref/reset.html).
 Think of [sqlite3\_reset()](c3ref/reset.html) as rewinding the [prepared statement](c3ref/stmt.html) program
 back to the beginning.
 Using [sqlite3\_reset()](c3ref/reset.html) on an existing [prepared statement](c3ref/stmt.html) rather than
 creating a new [prepared statement](c3ref/stmt.html) avoids unnecessary calls to
 [sqlite3\_prepare()](c3ref/prepare.html).
 For many SQL statements, the time needed
 to run [sqlite3\_prepare()](c3ref/prepare.html) equals or exceeds the time needed by
 [sqlite3\_step()](c3ref/step.html). So avoiding calls to [sqlite3\_prepare()](c3ref/prepare.html) can give
 a significant performance improvement.




 It is not commonly useful to evaluate the *exact* same SQL
 statement more than once. More often, one wants to evaluate similar
 statements. For example, you might want to evaluate an INSERT statement
 multiple times with different values. Or you might want to evaluate
 the same query multiple times using a different key in the WHERE clause.
 To accommodate
 this, SQLite allows SQL statements to contain [parameters](lang_expr.html#varparam)
 which are "bound" to values prior to being evaluated. These values can
 later be changed and the same [prepared statement](c3ref/stmt.html) can be evaluated
 a second time using the new values.




 SQLite allows a [parameter](lang_expr.html#varparam) wherever a string literal,
 blob literal, numeric constant, or NULL is allowed
 in queries or data modification statements. (DQL or DML)
 (Parameters may not be used for column or table names,
 or as values for constraints or default values. (DDL))
 A [parameter](lang_expr.html#varparam) takes one of the following forms:



* **?**
* **?***NNN*
* **:***AAA*
* **$***AAA*
* **@***AAA*



 In the examples above, *NNN* is an integer value and
 *AAA* is an identifier.
 A parameter initially has a value of NULL.
 Prior to calling [sqlite3\_step()](c3ref/step.html) for the first time or immediately
 after [sqlite3\_reset()](c3ref/reset.html), the application can invoke the
 [sqlite3\_bind()](c3ref/bind_blob.html) interfaces to attach values
 to the parameters. Each call to [sqlite3\_bind()](c3ref/bind_blob.html)
 overrides prior bindings on the same parameter.




 An application is allowed to prepare multiple SQL statements in advance
 and evaluate them as needed.
 There is no arbitrary limit to the number of outstanding
 [prepared statements](c3ref/stmt.html).
 Some applications call [sqlite3\_prepare()](c3ref/prepare.html) multiple times at start\-up to
 create all of the [prepared statements](c3ref/stmt.html) they will ever need. Other
 applications keep a cache of the most recently used [prepared statements](c3ref/stmt.html)
 and then reuse [prepared statements](c3ref/stmt.html) out of the cache when available.
 Another approach is to only reuse [prepared statements](c3ref/stmt.html) when they are
 inside of a loop.



