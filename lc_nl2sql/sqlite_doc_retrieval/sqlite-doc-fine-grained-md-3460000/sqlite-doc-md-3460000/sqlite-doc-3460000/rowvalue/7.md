## 3\.1\. Scrolling Window Queries


Suppose an application wants to display a list of contacts
in alphabetical order by lastname, firstname, in a scrolling window
that can only show 7 contacts at a time. Initialize the scrolling
window to the first 7 entries is easy:




```
SELECT * FROM contacts
 ORDER BY lastname, firstname
 LIMIT 7;

```

When the user scrolls down, the application needs to find the
second set of 7 entries. One way to do this is to use the OFFSET clause:




```
SELECT * FROM contacts
 ORDER BY lastname, firstname
 LIMIT 7 OFFSET 7;

```

OFFSET gives the correct answer. However, OFFSET requires time
proportional to the offset value. What really happens
with "LIMIT x OFFSET y" is that SQLite computes the query as
"LIMIT x\+y" and discards the first y values without returning them
to the application. So as the window scrolls down toward
the bottom of a long list, and the y value becomes larger and larger,
successive offset computations take more and more time.



A more efficient approach is to remember the last entry currently
displayed and then use a row value comparison in the WHERE
clause:




```
SELECT * FROM contacts
 WHERE (lastname,firstname) > (?1,?2)
 ORDER BY lastname, firstname
 LIMIT 7;

```

If the lastname and firstname on the bottom row of the previous
screen are bound to ?1 and ?2, then the query above computes the next
7 rows. And, assuming there is an appropriate index, it does so
very efficiently â€” much more efficiently than OFFSET.



