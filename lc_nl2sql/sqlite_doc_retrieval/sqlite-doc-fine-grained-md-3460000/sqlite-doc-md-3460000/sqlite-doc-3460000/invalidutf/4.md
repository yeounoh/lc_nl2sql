# 3\. Best effort to preserve text



SQLite does not promise to always preserve invalid UTF, but it does
make an effort. Generally speaking, if you insert invalid UTF into
SQLite, you will get the exact same byte sequence back out, as long
as you do not ask SQLite to transform the text in any way.




For example, if you insert some UTF\-16LE with invalid surrogates into
a TEXT column of a table of a database that has [PRAGMA encoding\=UTF16LE](pragma.html#pragma_encoding),
then later query that column using [sqlite3\_column\_text16()](c3ref/column_blob.html), you will 
probably get back the same exact invalid UTF\-16\. But if you insert the
same invalid UTF\-16LE content in a [PRAGMA encoding\=UTF8](pragma.html#pragma_encoding) database,
the content must be converted into UTF8 when it is stored, which could
cause irreversible changes to the content. Or if you insert that
same invalid UTF\-16LE content into a [PRAGMA encoding\=UTF16LE](pragma.html#pragma_encoding) database
but then read it out using [sqlite3\_column\_text()](c3ref/column_blob.html), then a UTF16 to
UTF8 conversion must occur during the read\-out and that conversion might
introduce irreversible changes.




Or, suppose you are doing everything using UTF\-8 (the most common case).
Invalid UTF\-8 will normally pass through the database without any change
in its byte sequence. However, if you try to transform the invalid
UTF\-8 with SQL function like [substr()](lang_corefunc.html#substr) or [replace()](lang_corefunc.html#replace)
or if you try to do string matching with the [LIKE](lang_expr.html#like) operator, then
you might get unexpected results.




So, in other words, SQLite does not actively try to subvert your
invalid text. But when you ask SQLite to make transformations of invalid
UTF, there are no guarantees that those transformations will be reversible
or even sensible.



