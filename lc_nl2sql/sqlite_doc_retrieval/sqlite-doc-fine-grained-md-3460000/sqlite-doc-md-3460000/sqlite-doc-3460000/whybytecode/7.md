## 2\.1\. Bytecode Is Easier To Understand


A flat list of opcodes can be easily printed to see exactly
how an SQL statement is being implemented. This is what happens in SQLite
when you preface an SQL statement with the "EXPLAIN" keyword: Instead of
actually running the SQL, the result is a listing of the bytecode
that would have been used to implement that SQL.



Bytecode lends itself to this because a bytecode program is easily
represented as a table. In SQLite bytecode, each instruction
has one opcode and five operands. Thus a prepared statement can be
rendered as if it were a query against a six\-column table.



A tree\-of\-objects representation is more difficult to publish in
a human\-readable form. The objects that comprise the tree tend to
all be very different, and thus it is tricky to come up with a 
consistent and simple table representation with which to display
the objects. Any such table representation that you do come up
with would almost certainly have more than six columns, probably many more.
The problem of rendering a tree\-of\-objects as a table is sufficiently
difficult that nobody does it, as far as I know. Hence, no
tree\-of\-objects database engine provides the level
of detail in their "EXPLAIN" output that SQLite provides.



